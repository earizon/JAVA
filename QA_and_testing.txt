┌────────────────────────────┐
│ JAVA QA & Testing "Zipped" │
└────────────────────────────┘
(This page is an always-work-in-progress.
 Contribute

# Cost of software failures [[{qa.billion_dolar_mistake]]
$312 billion per year: global cost of software bug (2013)
$300 billion dealing with the Y2K problem

$440 million loss by Knight Capital group Inc. in 30 minutes, August 2012
$650 million loss by NASA Mars missions in 1999; unit conversion bug
$500 million Arian 5 maiden flight in 1996; 64-bit to 16-bit conversion bug
"$Nightmare" billion Boeing 737Max

2011: Software caused 25% of all medical device recalls.
[[}]]

# Checker framework (Java 8+) [[{qa.101.checker_fw,qa.error_control,qa.billion_dolar_mistake]]
 fix errors at compile time  (vs later on at execution/runtime)
@[https://github.com/typetools/checker-framework]
@[https://checkerframework.org/manual/]
@[https://www.youtube.com/watch?v=6E1CSydgzQc]
@[https://www.baeldung.com/checker-framework]

  COMPARED TO ALTERNATIVES (SpotBugs, Infer  Jlint, PMD,...)
                 ┌─────────────┬────────┬────────┐                 ┌──────────────────┬─────────────────────┐
                 │ Null Pointer│        │        │                 │ Verification     │ Bug─Finding         │
                 │    errors   │ False  │Annotat.│                 │ ( Checker FW ,)  │ (Infer,StopBugs,    │
                 │             │        │        │                 │                  │  SonarQube,...      │
                 │Found│ Missed│warnings│written │  ┌──────────────┼──────────────────┼─────────────────────┤
  ┌──────────────┼─────┼───────┼────────┼────────┤  │Goal          │ prove that       │ find some bugs      │
  │ Checker FW.  │9    │ 9     │  4     │  35    │  │              │ no bug exits     │ at "low cost"       │
  ├──────────────┼─────┼───────┼────────┼────────┤  ├──────────────┼──────────────────┼─────────────────────┤
  │StopBugs      │0    │ 9     │  1     │  0     │  │Check specifis│ user provided    │ infer likely specs  │
  ├──────────────┼─────┼───────┼────────┼────────┤  │specificat    │                  │                     │
  │Jlint         │0    │ 9     │  8     │  0     │  ├──────────────┼──────────────────┼─────────────────────┤
  ├──────────────┼─────┼───────┼────────┼────────┤  │False         │ None!!!          │ acceptable          │
  │PMD           │0    │ 9     │  0     │  0     │  │negatives     │                  │                     │
  ├──────────────┼─────┼───────┼────────┼────────┤  ├──────────────┼──────────────────┼─────────────────────┤
  │Eclipse 2017  │0    │ 9     │  8     │  0     │  │False         │ manually supress │ heuristics focus on │
  ├──────────────┼─────┼───────┼────────┼────────┤  │positives     │ warnings         │ most important bugs │
  │IntelliJ      │0    │ 9     │  1     │  0     │  ├──────────────┼──────────────────┼─────────────────────┤
  │+@NotNull 2017│3    │ 6     │  1     │ 925+8  │  │Downside      │ user burden      │ missed bugs         │
  └──────────────┴─────┴───────┴────────┴────────┘  └──────────────┴──────────────────┴─────────────────────┘

  PROBLEM: STANDARD JAVA TYPE SYSTEM IS NOT GOOD ENOUGH
   - Next examples compile, but fail at runtime:
     System.console().readLine()       ; <·· Ex.1 NullPointer

     Collections.emptyList().add("one"); <·· Ex.2 Unsupported Operation

     Date key1 = new Date();             <·· Ex.3
     myMap.put(key1, "now");
     myMap.get(key1);                        <··  returns "now"
     key1.setSeconds(0);                     <··  Mutate key
     myMap.get(key1);                        <··  returns null


  SOLUTION:
   Java 8+ allows to compile programs using "PLUGGABLE TYPE SYSTEMs" ,
   allowing to apply stricter checks than default ones in compiler like
   Ex:
   $ javac  -processor NullnessChecker  MyFile.java

    PLUGABLE TYPE SYSTEM COMPILATION SCHEMA:
            (1)           No errors ²
     Source ···> Compiler ·(No error ·····┬···> Executable
       ^            │       detected      ·²         ^
       ·            v                     v          ·
       ·         Standard               Optional     · Guaranteed
       ·         Compiler               Type      ···┘ Behaviour
       ·         Errors                 Checker
       ·                                  ·
       ·                                  v
       └·················· Warnings ······┘

       ² plugable type system allows generation
         of executable to allow CI continue the
         pipeline with further tests (functional
         testing, configuration testing, ...)

## Instalation [[{]]

0. Check new releases/versions at
  @[https://search.maven.org/search?q=g:org.checkerframework]

1. Add next pom.xml dependencies like:
   <dependency>
       <groupId>org.checkerframework</groupId>
       <artifactId>checker-qual</artifactId>
       <version>2.11.0</version>
   </dependency>
   <dependency>
       <groupId>org.checkerframework</groupId>
       <artifactId>checker</artifactId>
       <version>2.11.0</version>
   </dependency>
   <dependency>
       <groupId>org.checkerframework</groupId>
       <artifactId>jdk8</artifactId>
       <version>2.11.0</version>
   </dependency>


 2. tweak maven-compiler-plugin to use Checker Framework
    as a pluggable Type System:
    <plugin>
      <artifactId> maven-compiler-plugin </artifactId>
      <version>3.6.1</version>
      <configuration>
        <source>1.8</source>
        <target>1.8</target>
        <compilerArguments>
          <Xmaxerrs>10000</Xmaxerrs>
          <Xmaxwarns>10000</Xmaxwarns>
        </compilerArguments>
        <annotationProcessors>                            <······ "==" javac -processor ...
          <annotationProcessor>
             org.checkerframework.checker.nullness.NullnessChecker
           </annotationProcessor>
           <annotationProcessor>
             org.checkerframework.checker.interning.InterningChecker
           </annotationProcessor>
           <annotationProcessor>
             org.checkerframework.checker.fenum.FenumChecker
           </annotationProcessor>
           <annotationProcessor>
             org.checkerframework.checker.formatter.FormatterChecker
           </annotationProcessor>
        </annotationProcessors>
        <compilerArgs>
          <arg>-AprintErrorStack</arg>
          <arg>-Awarns</arg>
        </compilerArgs>
      </configuration>
    </plugin>

3.  Manually add extended type annotations in real Java code
[[}]]

## Ussage [[{]]
-   Avoiding Nulls

  CHECKS  ON TYPES


  private static int func1 (
     @RequiresNonNull  String[] args   <·· func. preconditions.
  ) {
      @EnsuresNonNull final result;    <·· func. post-condition. variable is guaranteed to be non─null on return.
      result = args.length;                Also: @EnsuresNonNullIf: variables is guaranteed to be non─null on ret.true/false
      return result;
  }

  public static void main
    ( @Nullable  String[] args) {
      ...
      func1(args);  //                 <·· [WARNING] ... [argument.type.incompatible]
  }                                        incompatible types in argument.
                                           found    : null
                                           required : @Initialized @NonNull ...

  static final
     @Fenum("country") String ITALY = "IT",   <·· Safe Enum with Fenum (Fake enum)
     @Fenum("country") String US    = "US",
     ...
     @Fenum("planet" ) String MARS   = "Mars",
     @Fenum("planet" ) String EARTH   = "Earth";
  ...

  void function1(                      <·· Function expected "planet" string
    @Fenum("planet") String inputPlanet){
      System.out.println("Hello " + planet);
  }

  public static void main(String[] args) {
      obj.greetPlanets(US);            <·· [WARNING] ... incompatible types in argument.
  }                                         found   : @Fenum("country") String
                                            required: @Fenum("planet")  String


  @Regex(1) static                     <·· Force regext string with at least one matching group
      String FIND_NUMBERS = "\\d*";        <·· [WARNING] ... incompatible types in assignment.
                                               found   : @Regex String
                                               required: @Regex(1) String

   @Untainted String                   <·· Validating tainted (non-trusted) input
   validate (String sqlInput) {
      // ... Do any suitable checks
      //     OR THROW ON ERROR
      @SuppressWarnings("tainting")        <·· "swear" that developer got sure
      @Untainted String result = ...;           of input correctness
      return result;
  }

  void execSQL(@Untainted  String sqlInput) {
      ...
  }

  public static void main(String[] args) {
      obj.execSQL(arg[0]);                 <··  warning at compile time
      obj.execSQL(validate(arg[0]));       <·· "OK". validate un-tain the input
  }

  @Immutable Date date = new Date();       <·· Mark as real immutable (vs weak "final")
  date.setSeconds(0);                      <·· compile-time error
[[}]]

## Avoiding (certain) concurrency errors [[{]]
  Lock Checker enforces a locking discipline:
  "which locks must be held when a given operation occurs"

  CHECKS ON TYPES                             │ CHECKS ON FUNCTION DECLARATION
                                              │                 ┌────┬────┬───────────────────────────┐
   @GuardedBy("lockexpr1","lockexpr2",...)    │                 │FUNC│FUNC│DESCRIPTION                │
             int var1 = ....;                 │                 │PRE─│POST│                           │
   ^^^^^^^^^^                                 │                 │COND│COND│                           │
  a thread may dereference the value referred │┌────────────────┼────┼────┼───────────────────────────┤
  to by var1 only when the thread holds all   ││@Holding        │X   │    │All the given lock exprs   │
  the locks that ["lockexpr1",...] currently  ││(String[] locks)│    │    │are held at method call    │
  evaluates to.                               │├────────────────┼────┼────┼───────────────────────────┤
                                              ││@EnsuresLockHeld│    │X   │Ensures locks are locked on│
                                              ││(String[] locks)│    │    │return,ex. lock adquired by│
                                              ││                │    │    │ReentrantLock.lock().      │
                                              │├────────────────┼────┼────┼───────────────────────────┤
                                              ││@EnsuresLockHeld│    │X   │Ensures locks are locked on│
                                              ││(String[] locks)│    │    │return,ex.lock conditionaly│
                                              ││                │    │    │adquired by ReentrantLock  │
                                              ││                │    │    │.lock()                    │
                                              ││                │    │    │if method return true|false│
                                              │└────────────────┴────┴────┴───────────────────────────┘
   SIDE EFFECT SPECIFICATIONS
  ┌────────────────────┬───────────────────────────────────────────────┐
  │ @LockingFree       │method does NOT acquire│release locks:         │
  │                    │· it is not synchronized,                      │
  │                    │· it contains NO synchronized blocks           │
  │                    │· it contains no calls to lock│unlock methods  │
  │                    │· it contains no calls to methods that are not │
  │                    │  themselves @LockingFree                      │
  │                    │(@SideEffectFree implies @LockingFree)         │
  ├────────────────────┼───────────────────────────────────────────────┤
  │ @ReleasesNoLocks   │· method maintains a strictly                  │
  │                    │  nondecreasing lock hold count                │
  │                    │  on the current thread for any locks          │
  │                    │  held at method call.                         │
  ├────────────────────┼───────────────────────────────────────────────┤
  │ @EnsuresLockHeld   │method adquires new locsk                      │
  │ @EnsuresLockHeldIf │(default if no @LockingFree│@MayReleaseLocks│  │
  │                    │@SideEffectFree│@Pure used).                   │
  └────────────────────┴───────────────────────────────────────────────┘
[[}]]

-  Format String Checker
  - prevents use of incorrect format strings in System.out.printf,....

    void printFloatAndInt
         ( @Format({FLOAT, INT})  String   format )
    {
      System.out.printf(  format , 3.1415, 42);
    }
- I18n Format Checker examples
  MessageFormat.format("{0} {1}", 3.1415);
                                        ^
                              second argument missing
  MessageFormat.format("{0, time}", "my string");
                                    ^^^^^^^^^^^
                                    cannot be formatted
                                    as Time type.
  MessageFormat.format("{0, thyme}", new Date());
                            ^^^^^
                            unknown format type

  MessageFormat.format("{0, number, #.#.#}", 3.1415);
                                    ^^^^^
                              subformat is invalid.

- Property File Checker!!!!    TODO
  - It ensures that used keys are found in the corresponding
    property file or resource bundle.

- GUI Effect Checker
  - It is difficult for a programmer to remember
    which methods may be called on which thread(s).
    (Main GUI thread or others)
   Checker types the method as if:
   - It accesses no UI elements (and may run on any thread);
   - It may access UI elements  (and must run on the UI thread)

- (physical) Internation System UNIT annotations :
  @Acceleration: Meter Per Second Square @mPERs2
  @Angle       : Radians @radians
                 Degrees @degrees
  @Area        : square millimeters @mm2,
                 square meters @m2
                 square kilometers @km2
  @Current     : Ampere @A
  @Length      : Meters @m
                 millimeters @mm
                 kilometers @km
  @Luminance   : Candela @cd
  @Mass        : kilograms @kg
                     grams @g
  @Speed       : meters per second   @m
                 kilometers per hour @kmPERh
  @Substance   : Mole @mol
  @Temperature : Kelvin @K
                 Celsius @C
  @Time        : seconds @s
                 minutes @min
                 hours @h

- @Unsigned/@Signed ← guarantees values are not mixed

- type alias or typedef
  share same representation as another type
  but is conceptually distinct from it.
  Ex 1: get sure that Strings representing addresses
        and passwords are NOT mixed
  Ex 2: get sure that integers used for meters are
        not mixed with integers used for centimeters.

  Example:
  @NonNull List<String>
  List<@NonNull String>
  @Regex String validation = "(Java|JDK) [7,8]"

  private String getInput(String parameterName){
   final String retval = @Tainted request.getParameter(parameterName);
   return retval;
  }

  private void runCommand(@Untainted String… commands){
   // the previously tainted String must be validated before being passed in here.
   ProcessBuilder processBuilder = new ProcessBuilder(command);
   Process process = processBuilder.start();
  }
<hr/>
# SpotBugs
@[https://github.com/spotbugs/spotbugs/issues]
* OOSS static analysis tool for java code bugs.
* Well maintained (as of 2021-12-21)
* "spiritual successor of FindBugs"
* SpotBugs checks for more than 400 bug patterns.
* Works from GUI+cli, maven/gradle/eclipse integration.
* Plugin extension support (just download plugin jar and
  it will be detected and included):
  • fb-contrib:
  • Security Audits for Java Web applications:
  @[https://find-sec-bugs.github.io/]
    It can detect 141 different vulnerability types with
    over 823 unique API signatures.

## Running SpotBugs [[{]]
  · Presetup. Compile java code to classes or jars.
    SpotBugs runs against compiles class files, using source code
    as a reference when displaying output.

  $ java -jar ../spotbugs.jar ...$SPOTBUG_ OPTIONS ..

                             JVM OPTIONS
                             ===========
  -Xmx1500m                ← set JVM heap to big/1500MB  (recomended)

                             STANDARD OPTIONS
                             ================
  -textui                  ← vs -gui
  -effort min              ← := min|less|default|more|max
                             min: decrease mem use/precision/exec.time
                             max: increase mem use/precision/exec.time
  -project ... \           ← project *.fb or *.fbp created through the GUI
                             (fb == FindBugs)
  -pluginList jar1;jar2     \
  -home $SPOTBUG_DIR       ← ex: /opt/spotbugs
  -adjustExperimental      ← Lower priority of experimental Bug Patterns.
  -workHard                ← Ensure analysis effort is at least ‘default’.
  -sortByClass=dir1/spotbugs.txt ← textui only
                                   also supported to set multiple reports
  -include filter01.xml     ← show only bugs match filter specified.
  -exclude filter02.xml     ← *1
  -onlyAnalyze com.foo.*,com.bar.* ← Unlike filter, analysis is skipt
                              for any other class type
                              WARN: some detectors may produce inaccurate
                              results
  -low                      ← Report all bugs.
  -medium                   ← Report medium and high priority bugs.
  -high                     ← Report only high priority bugs.
  -relaxed                  ← suppress heuristics, avoidin false positives.
  -html=../report.html      ← Output HTML. Alternative:
                            ← Output HTML. Alternative:
                              NOTE : It is -html=value while other flags work like
                                     -flag value (without the "=" sign)
                              -html:fancy.xsl=...  (DOM+JS for navigation + CSS)
                              -html:fancy-hist.xsl=...  fancy.xsl evolution
                              Other output formats include xml/sarif/emacs/xdocs
  -nested false             ← disable scanning of nested jar (def:enabled)
  -auxclasspath ...         ← It should include all jar/dirs containing classes
                              that are part of the program being analyzed but
                              you do not want to have analyzed for bugs.
  -auxclasspathFromInput    ← Read auxclasspath from STDIN, line by line
  -auxclasspathFromFile
  -analyzeFromFile fileI    ← Read input file list from file line-by-line.
  -showPlugins              ← listavailable detector plugins.

                              OUTPUT CUSTOMIZATION OPTIONS
                              ============================
  -timestampNow             ← Set results timestamp to current time.
  -quiet                    ← Suppress error messages.
  -longBugCodes             ← Report long bug codes.
  -progress                 ← Display progress in console.
  -release $name            ← Set release name in report
  -maxRank $rank            ← Only report issues with a bug rank at least
                              as scary as that provided.
  -dontCombineWarnings      ← Don’t combine warnings differing only in line num.
  -train[:outputDir]:       ← Save training data (experimental);
  -useTraining[:inputDir]:  ← Use training data (experimental);
  -redoAnalysis $filenam    ← Redo using config. from previous analysis.
  -sourceInfo $file         ← Specify source info file (line numbers for
                              fields/classes).
  -projectName $name        ← Descriptive name of project.
  -reanalyze $filename      ← Redo analysis in provided file.

                              OUTPUT FILTERING OPTIONS
                              ========================
  -bugCategories cat1,cat2  ← Only report bugs in those categories.
  -excludeBugs baseline_bug ← Exclude bugs that are also reported in
                              baseline xml output.
  -applySuppression         ← Exclude bugs matching suppress.filter from *fbp

                              DETECTOR (VISITOR) CONFIGURATION OPTIONS
                              ========================================
  -visitors v1,v2,...       ← Run only named visitors.
  -omitVisitors v1,v2,...   ← Omit named visitors.
  -chooseVisitors +v1,-v2,. ← enable/disable detectors.
  -choosePlugins +p1,-p2,   ← Selectively en/dis-able plugins.
  -adjustPriority v1=raise|lower,v2=...

                              PROJECT CONFIGURATION OPTIONS
                              =============================
  -sourcepath $source_path  ← Set source path for analyzed classes.
  -exitcode                 ← Set exit code of process.
  -noClassOk                ← Output empty warning file if no classes are
                              specified.
  -xargs                    ← Get list of class/jar files from STDIN
  -bugReporters name,-name2,.. ← Bug-reporter decorators to explicitly
                                 enable/disable.
  -printConfiguration       ← Print configuration and exit

*1┌── myIncludeOrExcludeFilter.xml ────
  │
  │ <?xml version="1.0" encoding="UTF-8"?>
  │ <FindBugsFilter>
  │ <Match>
  │   <Bug                       match if  pattern and/or code and/or category match
  │     pattern="..."          ← comma-separated list of patterns to match
  │                              ex.: DLS_DEAD_LOCAL_STORE,DM_EXIT,
  │     code="..."             ← coarse-grained matching comma-sep. list of bug
  │                              abbreviations(DC,DE,IC,IJU,MS,SIC,URF,UUF,XYZ,...)
  │     category="..."         ← even more coarse-grained :=
  │                              CORRECTNESS, BAD_PRACTICICE,
  │   />                         PERFORMANCE, STYLE, MT_CORRECTNESS
  │                                 (M)ulti(T)hreaded ┘
  │
  │
  │   <Confidence value="1"/>  ← 1 match high-confidence warnings,
  │                              2 match normal-confidence warnings
  │                              3 match low-confidence warnings
  │
  │    <Rank value="1" />     ←  1  to 4 : scariest
  │                              5  to 9 : scary
  │                             10 to 14: troubling
  │                             15 to 20: concern
  │
  │   <Package name="~.."/> ← name/regex. Nested packages are NOT included
  │   <Class   name="~.. /> ← name/regex. NOTE: Some bug instances relate to
  │                                       2+ classes.
  │   <Source  name="..."/> ← name/regex.  match warnings associated to source file.
  │                           └────┬────┘
  │                         regex if prefixed by ~
  │
  │   <Method
  │    name="funcXXX"
  │    params="int,..."
  │    returns="void"
  │   />
  │
  │   <Field name="..." />   ← type=... instead of name can also be used
  │   <Local name="..." />
  │   <Type  name="..." />
  │ </Match>
  │
  │ <Or>  <Match /><Match /></Or>
  │ <And> <Match /><Match /></And>
  │ <Not> <Match />         </Not>
  │
  │ </FindBugsFilter>
  └────────────────────────────────────────────
[[}]]


# Lint4j
@[http://www.jutils.com/]
*  WARN : Not maintained any more.
* Lint4j ("Lint for Java") is a static Java source and byte code
  analyzer that detects locking and threading issues, performance and
  scalability problems, and checks complex contracts such as Java
  serialization by performing type, data flow, and lock graph analysis.

## Ussage
  @[http://www.jutils.com/uguide.html]
  $ lint4j \
     -sourcepath src/main \             ← analyze source
     -classpath lib/bcel.jar:... \
     -exclude "packagename"   \         ← package or package-prefix
     "com.jutils.lint4j.*"

  $ lint4j -sourcepath .../log4j.jar    ← analyze binary
      "org.apache.*"

  $ lint4j  \
     -sourcepath ./build/log4j.jar      ← analyze 2 package in jar
     org.apache.log4j \
     org.apache.log4j.spi

  $ lint4j \
    -sourcepath com/.../ClassN.java \
                com/.../CalssJ.java

[[qa.101.checker_fw}]]

# SonarQube [[{qa.101.snarqube,01_PM.low_code,]]
            [[concurrency.101,JAVA_LANG.DEBUGGING]]
            [[scalability.profiling,01_PM.WiP]]
* SonarQube empowers all developers to write cleaner and safer code.
* Comunity with 200K+ dev. teams.
* Easely integrates with CI/CD pipelines.
  Jenkins, GitHub Actions, Bitbucket Pipelines, GitLab CI, Azure Pipelines, ...

* A simple client/server working enviroment can be setup in minutes like:

## Running SonarQube:

 1. Launch SonarQube Server:
    ```
    $ docker run -d --name sonarqube               \
      -e SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true    \
      -v $(pwd)/sonarqube_data:/opt/sonarqube/data \
      -p 9000:9000 sonarqube:latest
    ```

 2. Create a new project through the web console
    and annotate the 40-random-chars TOKEN.
    (Needed by client-side sonar-scanner).

 3. "CLIENT SIDE"
    * Setup `${PROJECT_SRC_ROOT}/sonar-project.properties`
      ```
      ┌─ sonar-project.properties ──
      │sonar.projectKey=my:project  ← Required
      │
      │#sonar.projectName=...       ← def:project key
      │#sonar.projectVersion=1.0    ← def:'not provided'
      │sonar.sources=src/java/      ← relative to
      │                               sonar-project.properties
      │#sonar.sourceEncoding=UTF-8
      │sonar.java.binaries=./build/ ← compiled *class dir.
      │sonar.java.libraries=...     ← ex: /lib/*.jar,./plugins/lib/*jar
      └─────────────────────────────
      ```

    * launch client scanner like:
       ```
       $ mvn clean verify sonar:sonar \        <· alt1) using mvn plugin
           -Dsonar.projectKey=test2 \
           -Dsonar.host.url=http://...:9000 \
           -Dsonar.login=$PROJECT_TOKEN

       $ docker run \                          <· alt2) using docker
         --rm \
         -e SONAR_HOST_URL="http:...:9000" \
         -e SONAR_LOGIN="$PROJECT_TOKEN" \
         -v "${YOUR_REPO}:/usr/src" \
         sonarsource/sonar-scanner-cli


* See original source for more info about SonarScanner Troubleshooting
  recipes, advanced docker config, running, caching scanner files,
  usng self-signed certs:
  @[https://docs.sonarqube.org/latest/analysis/scan/sonarscanner/]
  *1: not needed if the associated project is already linked to a
      git repository on the server side.

[[qa.101.snarqube}]]


# JavaDoc [[{qa.101.javadoc,qa.documentation]]



   Example
   /**
    * Short one line description.
    * <p>
    * Longer description. ...
    * ...here.
    * <p>
    * And even more explanations to follow
    * in consecutive paragraphs
    *                                           Applies to:
    * @author John Bla                          Class, Interface, Enum
    * @param  varname Description ....                                         Method
    * @return description                                                      Method
    * @version  1.2.3                           Class, Interface, Enum (Max: 1 per Class|Interface)
    * @since  1.1.1                             Class, Interface, Enum, Field, Method
    * @seereference  link_to_another_element    Class, Interface, Enum, Field, Method
    * @exceptionclass desc                                                     Method
    * @throwsclass desc                                                        Method
    * @deprecated description_of_outdated Elem. Class, Interface, Enum, Field, Method
    * {@inheritDoc}     Copies desc. from parent
    * {@linkreference}  Link to other symbol    Class, Interface, Enum, Field, Method
    * {@value#STATIC_FIELD}  Return the value of static field.                         Static Field
    * {@codeliteral}    (Formats literal text   Class, Interface, Enum, Field, Method
    *                  in the code font. It is
    *                  equivalent to  {@literal}
    * {@literalliteral} Denotes literal text.                           Field, Method
    *                   The enclosed text is interpreted as not
    *                   containing HTML markup or nested javadoc tags.
    *
    */
   public int methodName (...) {
       // method body with a return statement
   }
[[}]]


# Junit [[{101.qa.101,02_doc_has.comparative,01_PM.WiP]] @[testing_summary]
  Junit (TEST scoped) dependencies:
  org.junit.jupiter:junit-jupiter-api:${junit_version}
  org.junit.jupiter:junit-jupiter-engine:${junit_version}

  @org.junit.jupiter.api.Test

  @DisplayName("Display name Class Level")
  @DisplayNameGeneration(ReplaceCamelCase.class)
  class JUnitAPISummaryTest {
                          // testing Life-Cycle methods:
    @BeforeEach { ... } // ← executed before each @Test in class
    @AfterEach  { ... } // ← executed after  each @Test in class
    @BeforeAll  { ... } // ← executes before all tests.
    @AfterAll   { ... } // ← executes after  all tests.



    @org.junit.jupiter.api.Test
    @DisplayName("Test parameters with nice names")
    @ParameterizedTest(name = "Use the value {0} for test")
    @ValueSource(insts = { -1, -4 })
    void test01( int number ) {
      Assumptions.assumeTrue (...);            // ← failed assumption aborts test
      Assumptions.assumeFalse(...);            //   Continuing execution will fail.
                                               //   Example: Initial state is not expected one

                                               // Frequently Used:
      Assertions.assertTrue   (param1);        // or assertFalse
      Assertions.assertNull   (param1);        // or assertNotNull
      Assertions.assertEquals (param1,param2); // or assertNotEquals
      Assertions.assertNotSame(param1,param2);
      Assertions.fail         ("code must not be reached");

      assertAll("check ...",                   //  grouped
        () -> assertEquals(..),
        () -> assertEquals(..),
        () -> assertEquals(..)
      );

                                               // Collections:
      Assertions.assertArrayEquals   (array1, array2, "...");
      Assertions.assertIterableEquals(list1, list2);


      Assertions.assertTimeout(                // Timeouts:
        Duration.ofMillis(100), () -> {
          Thread.sleep(50);
          return "result";
        });

      Throwable exception =                    // Assert exception thrown
         Assertions.assertThrows(
           IllegalArgumentException.class,
           () -> {
             throw new IllegalArgumentException("...");
           });
    }

    @Test @Disabled   ...                      // Conditional execution
    @Test @EnabledOnOs({ OS.LINUX }) ...
    @Test @DisabledIfSystemProperty(named = "ci-server", matches = "true")
    @Test @EnabledIfEnvironmentVariable(named = "ENV", matches = "test-env")

   @RepeatedTest(
      value = 9,
      name = "{displayName}-{currentRepetition}/{totalRepetitions}")
   void valuesCannotPassTen(RepetitionInfo info) {
       ...info.getCurrentRepetition() ...
   }

   @ParameterizedTest(
    name = "Test fruit \"{0}\" with rank {1}")
   @CsvSource({
           "'string1', 1",         // ← Repeat test with different input
           "'string2', 2",
           ...
   })
   void testWithCsvSource(String fruit, int rank) {
       assertNotNull(fruit);
       assertNotEquals(0, rank);
   }
  }

## Testsuites: run tests in multiple test classes and/or different packages.
  @RunWith(JUnitPlatform.class)
  @SelectPackages("com.myComp.junit5.package01")
  public class JUnit5TestSuiteExample
  { }

* See also: @[https://www.infoq.com/news/2018/01/VSCodeJunit]
[[}]]

## AssertJ (Fluent Assertions) is composed of several modules:  [[{01_PM.TODO]]
  - core      module: assertions for JDK types (String, Iterable, Stream, Path, File, Map...)
  - Guava     module: assertions for Guava types (Multimap, Optional...)
  - Joda Time module: assertions for Joda Time types (DateTime, LocalDateTime)
  - Neo4J     module: assertions for Neo4J types (Path, Node, Relationship...)
  - DB        module: assertions for relational database types (Table, Row, Column...)
  - Swing     module provides a simple and intuitive API for functional testing of Swing user interfaces

  import static org.assertj.core.api.Assertions.*;
  ...
  assertThat(frodo.getName()).isEqualTo("Frodo"); //  ← basic assertions
  assertThat(frodo).isNotEqualTo(sauron);

  assertThat(frodo.getName())                     // ← chaining string specific assertions
      .startsWith("Fro")
      .endsWith("do")
      .isEqualToIgnoringCase("frodo");

  assertThat(fellowshipOfTheRingList)            // ← collection specific assertions
     .hasSize(9)                                 //   (there are plenty more)
     .contains(frodo, sam)
     .doesNotContain(sauron);

  assertThat(frodo.getAge())
     .as("check %s's age", frodo.getName())     // ← as() used to describe the test
     .isEqualTo(33);                            //    will be shown before the error message

  assertThatThrownBy(() -> {                    // ← exception assertion ( standard style)
     throw new Exception("boom!"); })
  .hasMessage("boom!");
  Throwable thrown = catchThrowable(() -> {     // ← exception assertion  ( BDD style)
     throw new Exception("boom!");
  });
  assertThat(thrown).hasMessageContaining("boom");

  assertThat(fellowshipOfTheRingList)
      .extracting(TolkienCharacter::getName)    // ← 'extracting' feature on Collection
      .doesNotContain("Sauron", "Elrond");      //

  assertThat(fellowshipOfTheRingList)
     .extracting("name", "age", "race.name")    // extracting multiple values at once grouped in tuples
     .contains(
        tuple("Boromir",   37, "Man"   ),
        tuple("Sam"    ,   38, "Hobbit"),
        tuple("Legolas", 1000, "Elf"   ) );

  assertThat(fellowshipOfTheRingList)
    .filteredOn(                              // ← filtering before asserting
      fellow -> fellow.getName().contains("o")
    )
    .containsOnly(aragorn, frodo);

  assertThat(fellowshipOfTheRingList)
    .filteredOn(                              // combining filtering and extraction
      fellow -> fellow.getName().contains("o")
    )
    .containsOnly(aragorn, frodo)
    .extracting(
       fellow -> fellow.getRace().getName())
    .contains("Hobbit", "Elf");

  // and many more assertions:
  // iterable, stream, array, map, dates, path, file, numbers, predicate, optional ...
[[}]]

# Property Testing [[{qa.testing.property]]
* A property testing is just something like:

  for all (x, y, ...)
  such as precondition(x, y, ...) holds
  property(x, y, ...) is true

  It checks that a function/program/whatever is under test
  abides by a property.  Most of the time, properties do not
  have to go into too much details about the output, they
  just have to check for useful characteristics that must be
  seen in the output.

* Property based testing has become quite famous in the functional
  world. Mainly introduced by QuickCheck framework in Haskell, it
  suggests another way to test software. IT TARGETS ALL THE SCOPE
  COVERED BY EXAMPLE BASED TESTING: (UNIT TESTS TO INTEGRATION TESTS).

* Available automated test technics:
 @[https://medium.com/criteo-engineering/introduction-to-property-based-testing-f5236229d237]

          △ • Random
     full ┆   - Fuzzing
       △  ┆   - Monkey testing
       ┆  ┆
    Input ┆ • Static Analysis
    scope ┆   - Mem. leaks        • Example based
  covered ┆   - Unitialized mem.    - Unit tests
       ┆  ┆   - Nulls.              - QA test
       ▽  ┆   - Threading issues    - UI tests
   partial┆   - ...
         ─┼─╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶▷
            Low  ← Feature compliance →    High


* Extracted from @[https://en.wikipedia.org/wiki/QuickCheck].
  List of Java libs for property testing :
  "FunctionalJava's QuickCheck module". FunctionalJava.  2015-08-14
  "Quickcheck for Java". Quickcheck.dev.java.net.        2011-12-09
  "JCheck". JCheck.                                      2011-12-09
  "junit-quickcheck". junit-quickcheck.                  2013-07-03
  "jqwik for the JUnit5 Platform". jqwik.                2017-06-19
  "Quick Theories property tests Java 8"                 2017-10-30
  "jetCheck prop.-based tests    Java 8" (JetBrains)     2018-07-10


* e.g. test using 'jqwik':
  """ fizzBuzz() must return "Fizz"
      for every divisible-by-3 input """
  →  PRECONDITION: Consider inputs in [1 ... 100] divisible by 3
  → POSTCONDITION: fizzBuzz() returns "Fizz"

  import java.util.*;
  import java.util.stream.*;
  import net.jqwik.api.*;

  class FizzBuzzTests {

      String fizzBuzz(int i) {               // ← function to test
         boolean div3 = (i % 3 == 0),
                 div5 = (i % 5 == 0);
         if (div3&& div5) return "FizzBuzz";
         if (div3) return "Fizz";
         if (div5) return "Buzz"
         return String.valueOf(i);
      }

      @Provide
      Arbitrary<Integer> divisibleBy3() {    // ← Precondition
        return Arbitraries.integers()        //   input to function
          .between(1, 100)                   //   divides by 3.
          .filter(i -> i % 3 == 0);
      }

      final List<String> IN_OUT =
        IntStream.range(1, 100)
          .mapToObj((int i) -> )
          .collect(Collectors.toList());

      @Property                              // ← Test to execute
      boolean divBy3_starts_with_Fizz(
        @ForAll("divisibleBy3") int i) {     // ← "inject" precondition
        return IN_OUT
               .get(i - 1)
               .startsWith("Fizz");          // ← check Postcondition
      }
  }
[[qa.testing.property}]]


# JSR Annotations for Defect Detection [[{qa.error_control,qa.billion_dolar_mistake]]
@[https://stackoverflow.com/questions/1476757/jsr305-vs-jsr308-java-type-anotations-which-is-going-to-be-the-standard]
[[}]]

# TYPE ANNOTATIONS: [[{qa.billion_dolar_mistake,01_PM.TODO]]
@[https://blogs.oracle.com/java-platform-group/entry/java_8_s_new_type]
( TODO: Compare how it compares/overlaps CheckerFramework )

  @NonNull      compiler can determine cases where a      │ @(Un)Tainted          Identity types of data that should
                code path might receive a null value,     │                       not be used together, such as remote
                without ever having to debug a            │                       user input being used in system
                NullPointerException. The compiler        │                       commands, or sensitive information in
                just print a warning, but it              │                       log streams
                continues to compile!!!                   │
                                                          │ @                     Units of measure ensures that numbers
  @ReadOnly     compiler will flag any attempt to         │                       used for measuring objects are used
                change the object. This is similar to     │                       and compared correctly, or have
                Collections.unmodifiableList, but         │                       undergone the proper unit
                more general and verified at compile time.│                       conversion.
                                                          │
  @Regex        Provides compile-time verification        │ @FunctionalInterface  indicates that the type declaration
                that a String intended to be used as      │                       is intended to be a functional
                a regular expression is a properly        │                       interface, as defined by the Java
                formatted regular expression.             │                       Language Spec.

└  Examples :
  Annotation
  @NonNull List<String>                              ← A non-null list of Strings.
  List<@NonNull String>                              ← A list of non-null Strings.
  @Regex String validation = "(Java|JDK) [7,8]"      ← Check at compile time that this String is a valid regular expression.
  private String getInput(String parameterName){     ← The object assigned to retval is tainted and not for use in sensitive operations.
    final String retval =
      @Tainted request.getParameter(parameterName);
    return retval;
  }

  private void runCommand(@Untainted String… commands){            Each command must be untainted. For example, the previously
    ProcessBuilder processBuilder = new ProcessBuilder(command);   tainted String must be validated before being passed in here.

    Process process = processBuilder.start();
  }
[[}]]

# Behavior Driven Development (BDD)
## BDD KEYPOINTS [[{]]
  C&P&Summarized from "The Cucumber For Java Book" (by Seb Rose, Matt Wynne and Aslak Hellesøy)
* Help developers, project managers, product owners and testers
  develop functional-test scripts:
  BDD might just seem like a testing tool, but at its heart it’s really a
  collaboration tool. If you make a genuine effort to write features that work as
  documentation for the NONTECHNICAL STAKEHOLDERS on your team, you’ll find
  you are forced to talk with them about details that you might never have
  otherwise made the time to talk about. Those conversations reveal insights
  about their understanding of the problem, insights that will help you build
  a much better solution than you would have otherwise. This is Cucumber’s
  big secret: the tests and documentation are just a happy side effect; the real
  value lies in the knowledge you discover during those conversations.
* For a suite of automated tests to be useful, the team must have
  absolute trust in it. When even just a single test is compromising that trust,
  it has a corrosive effect on how everyone feels about the whole test suite.
* The ubiquitous language your team uses will be driven by the domain you’re
  working in. If you’re building a system for live-music fans, your ubiquitous
  language will include words like concert, performance, artist, and venue. If
  you’re building a catalog of TV shows, you’ll have words like broadcaster,
  genre, duration, and transmission date in your ubiquitous language.
  The point is for everyone on the team to use the same words, everywhere. It’s
  not OK to have a database table called tbl_Performer if the rows in that table
  represent things that most of the team refers to as artists. Wherever you see
  schism like this, stop, decide which is the right word to use, make the
  appropriate correction, and then stick with it.
  We talk about developing a ubiquitous language because it’s an ongoing
  process. That development takes work. It takes effort to really listen to one
  another and agree on the words you’ll use, and it takes discipline to stick to
  those commitments.
[[}]]

# Cucumber BDD [[{]]
* Multilanguage (Java, Ruby, Go, Python,...)

* Cucumber test flow:
  ```
         Project                              1. Describe behaviour
           │                                  2. Write step definition
           v                                  3. Run and fail
        Features      ····┐                   4. Write code to make step pass
           │              │                   5. Run and pass
           v              │  Business
       Scenarios          │  Facing
           │              │
           v              │
         Steps        ····┘
           │
           v
      Step Definitions  ··┐
           │              │
           v              │  Technology
       Support Code       │  Facing
           │              │
           v              │
      Automation Library··┘
           │
           v
      Testing Enviroment  <·· Infra/DevOps
  ```

## Cucumber JAVA + Maven Setup:

  ```
  <dependency>
    <groupId>info.cukes</groupId>
    <artifactId>cucumber-java</artifactId>
    <version>1.0.2</version>
    <scope>test</scope>
  </dependency>

  <dependency>
    <groupId>info.cukes</groupId>
    <artifactId>cucumber-junit</artifactId>
    <version>1.0.2</version>
    <scope>test</scope>
  </dependency>
  ```

## Ussage from command line:
   $ java -cp "jars/*" cucumber.api.cli.Main --help

   Example shell script to launch cucumber tests:
   javac -cp "jars/*" \
      step_definitions/CheckoutSteps.java <··· compile Steps definitions
   java -cp "jars/*:." \
      cucumber.api.cli.Main \             <··· Cucumber CLI interface
      -p pretty \                         <··· use pretty formatter plugin (or -p progress ..)
      --snippets camelcase \
      -g step_definitions \               <··· Where to look for Step definitions
      --strict                            <··· Returns -1 if there are undef.|pending steps.
      features/                           <··· Path to *.feature files

--------------------------------------------------------

## Features KEYPOINT:
> When writing Cucumber features, make readability your main goal.
> Otherwise, a reader can easily feel more like they’re reading a computer pro-
> gram than a specification document, which is something we want you to try
> to avoid at all costs. After all, if your features aren’t easy for nonprogrammers
> to read, you might as well just be writing your tests in plain old code.
> Each `Feature` is tested in one or more `Scenario`s (`Scenario Outline`s)

Feature: The user must be able to checkout provided
  he has control of a credit card
  # `Background` avoid repetitive code to all scenarios
  # Don't use it to set up complicated state unless that
  # state is something the reader actually needs to know.
  Background:
    Given I have been issued a new card
    And I insert the card, entering the correct PIN
    And I choose "Change PIN" from the menu


  # Each scenario is a single concrete example. (isolate test)
  # Each feature typically has somewhere between five and twenty scenarios,
  # each describing different examples of how that feature should behave in dif-
  # ferent circumstances.
  # Each scenario must be executed **independently** of any other scenario,
  # that is, they must NOT share state.
  # Each scenario has one or more steps (`Given`, `When`, `Then`, ...)
  Scenario
    Given the price of a "banana" is 40c
    But the price of 10 "banana" is 300c
    When I checkout 1 "banana"
    Then the total price should be 40
    And I should receive a ticket

  Scenario:
    Given these Users:
      | name       | date of birth   | action    |
      | Michael    | August 29, 1858 | died      |
      | John       | October 9, 1943 | married   |
      | Emma       | July    7, 2021 | played    |
    When the user x
    Then their marital status should look like:
      | Michael    | Deceased        |
      | John       | Married         |
      | Emma       | Unmarried       |


  # Scenario Outline is used when several scenarios
  # follow exactly the same "pattern" of steps with
  # just different input values. Placeholders <...>
  # indicate where we want real values to be replaced.
  # @tags allows to organize scenarios in cross-cutting
  # (multidimensional) concerns. This help in:
  # * Documentation
  # * Filtering: Cucumbers Hooks executions can be
  #              conditioned to the existence of a given
  #              tag for a given Scenario.

  @shopping  @UI  @error_management
  Scenario Outline: Checkout bananas
    Given the price of a "banana" is 40c
    But the price of 10 "banana" is 300c
    When I checkout <count> "banana"
    Then the total price should be <total>
    And I should receive a ticket that looks like
      """
         Ticket XXXX-XX-XX

         concept                  | quantity
         bananas                  | ...
      """

    # `Examples` provid the table input to the Scenario Outline
    # See also:
    # https://github.com/cucumber/cucumber-jvm/tree/main/datatable
    Examples: Succesul checkout
      | count | total |
      | 1     |  40   |
      | 2     |  80   |
      | 30    |  300  |
    Examples: Attempt to buy too many bananas
      The system doesn't allow to buy more than 100 per person
      | count | total                |
      | 1000  | see an error message |
      | 2000  | see an error message |
      | 3000  | see an error message |


  NOTE: `Given`, `When`, `Then`, `And`, `But` are actually ALIASES to
        `StepDefAnnotation`. The distintion is made just for human readability.


## Tabulated test data [[{]]
   ```
   ┌─ BoardSteps ─────────────────────────────────────┐ ┌─ board.feature ──────────────────────────┐
   │ package tic_tac_toe;                             │ │ Feature:                                 │
   │                                                  │ │   Scenario:                              │
   │ import cucumber.api.java.en.*;                   │ │                                          │
   │ import cucumber.api.PendingException;            │ │                                          │
   │ import cucumber.api.DataTable;                   │ │                                          │
   │                                                  │ │                                          │
   │ // Managing tests with tables:                   │ │                                          │
   │ public class BoardSteps {                        │ │                                          │
   │                                                  │ │                                          │
   │   @Given("^a board like this:$")                 │ │     Given a board like this:             │
┌··>   public void aBoardLikeThis(DataTable arg1)     │ │     |   | 1 | 2 | 3 |                    │
·  │  throws Throwable {                              │ │     | 1 |   |   |   |                    │
·  │     // Mark as pending!!!                        │ │     | 2 |   |   |   |                    │
·  │     throw new PendingException();                │ │     | 3 |   |   |   |                    │
·  │   }                                              │ │                                          │
·  │                                                  │ │                                          │
·  │   @When("^X plays in row (\\d+), column (\\d+)$")│ │    When X plays in row 2, column 1       │
·  │   public void                                    │ │                                          │
·  │     playerXPlaysInRowColumn(int arg1, int arg2)  │ │                                          │
·  │   throws Throwable {                             │ │                                          │
·  │     throw new PendingException();                │ │                                          │
·  │   }                                              │ │                                          │
·  │                                                  │ │                                          │
·  │   @Then("^the board should look like this:$")    │ │    Then the board should look like this: │
·  │   public void                                    │ │     |   | 1 | 2 | 3 |                    │
├··>      theBoardShouldLookLikeThis(DataTable arg1)  │ │     | 1 |   |   |   |                    │
·  │   throws Throwable {                             │ │     | 2 | x |   |   |                    │
·  │     throw new PendingException();                │ │     | 3 |   |   |   |                    │
·  │   }                                              │ └──────────────────────────────────────────┘
·  │ }                                                │
·  └──────────────────────────────────────────────────┘
└·· For automatic transformation, change DataTable to one of
    List<YourType>, List<List<E>>, List<Map<K,V>> or Map<K,V>.
    E,K,V must be a scalar (String, Integer, Date, enum etc)
   ```
[[}]]

## Step Definition Code Snippets
  ```
  assertEquals(total, checkout.total()); // Launch AssertionError if false
  throw new PendingException(); // mark test as pending ("half way" done)

  Cucumber Hooks examples:
  package hooks;
  import cucumber.api.Scenario;

  public class SomeTestHooks {
   //                        /--------v-··· optional: Selectively run the hook
   @cucumber.api.java.Before("@webTest")  // If Scenario is tagged with tag.
   public void resetBeforeCallingScenario() {
     // let's reset to stable state "anything"
     ...
   }

   @cucumber.api.java.After
   public void afterRunningScenario(Scenario scenario) {
   System.out.println("... " + scenario.getStatus());
   }
  }
  ```

[[}]]

# BDD Serenity Testing [[{qa.testing.bdd.serenity,qa.documentation,01_PM.TODO]]
@[https://serenity-bdd.github.io/theserenitybook/latest/index.html]

* Serenity BDD provides strong support for different
  types of automated acceptance testing, including:
- Web testing with Selenium.
- REST API testing with RestAssured.
- Highly readable, maintainable and scalable automated
  testing with the Screenplay pattern.
- BDD-style executable specifications with Cucumber

* Serenity reports also include how tests were tested,
  including step-by-step details and optional screenshots,
  to truly document what your application does.
   It not documents what tests have been executed, but
  WHAT REQUIREMENTS HAVE BEEN TESTED.

* It can also integrate with requirements stored in an
  external source (JIRA or any other test cases management
  tool), or just use a simple directory-based approach.

* Serenity BDD automated acceptance testing libraries
  includ:
  - REST API testing with RestAssured.
  - Highly readable, maintainable and scalable automated
    testing with the Screenplay pattern.
  - Rich built-in support for web testing with Selenium.
  - Cucumber or JBehave for BDD.


## Screenplay Pattern [[{]]
https://serenity-bdd.github.io/docs/tutorials/screenplay
* write readable test automation modeled around the user.
* built on good software engineering principles such as:
  * Single Responsibility Principle.
  * Open-Closed Principle
  * effective use of Layers of Abstraction.

 ┌·performs··>|tasks|¹    ¹Task       : action/s to perform some goal.
 ·              ◇         ²Interaction: action    with the App.(UI,...)
 ·              ·
 ·           made up of
 ·              ·
 ├·performs··>|interac-|····· interact with ······┐
 ·            |tions  ²|··enable·┐                ·
 ·                               v                v
|Actor|·······has·········>|Abilities|··invoke··>Tested
 ·                              ^                test
 ·                              ·
 ·                ┌······enable·┘
 └·· answers·┐    ·
             v    ·
         |Questions|
          about the system

* Example:
  ```

  ┌───┬─·····················  Screenplay test: User-centric model:
  ·   ·                        "everything" starts
  ·   ·                        with the actor, interacting with the app
  wendy                        to perform tasks and achieve their goals.
  .attemptsTo(            <··  takes a list of actions ("performables") that
                               the actor needs to perform. They divide into:
                               Interactions: when interacting directly with
                                    the app. (Click button, Open URL, ...)

    Navigate.toTheHomePage(),    <·· Interaction: action with the App.
    Search.byKeyword("Everest"), <·· Task: action to perform some goal.
    Ensure
    .that(DisplayedArticle.firstHeading())
    .isEqualTo("Mount Everest")
  );
  ```

Quick start: clone one of the starter projects.

https://github.com/serenity-bdd/serenity-cucumber-starter
https://github.com/serenity-bdd/serenity-junit-starter
https://github.com/serenity-bdd/serenity-junit-screenplay-starter
https://github.com/serenity-bdd/docs-starter-tutorial
https://github.com/serenity-bdd/serenity-rest-starter
https://github.com/serenity-bdd/serenity-jbehave-starter
https://github.com/serenity-bdd/serenity-cucumber4-starter
https://github.com/serenity-bdd/bdd-starter
>https://github.com/serenity-bdd/serenity-cucumber5-starter

Ex: Serenity Screenplay and JUnit 5.

We will use some simple conventions to organise our test classes, based on the standard Maven project structure you can see here:


 ┌────────────┬─··········  standard maven convention for JAVA tests
 src/test/java/todomvc/features   <·· test clases
 src/test/java/todomvc/screenplay <·· Screenplay classes, designed to be highly modular and reusable,
                                      and often appear in many tests, so it makes sense to keep them
                                      separate from the tests themselves.

 src/test/resources/serenity.conf <·· JUnit test results are based on the package structure
                                      set here the root package for tests.
 + serenity.test.root = todomvc.features

### Writing an scenario

* Creating the test case:
   Test: add a 'to do' item (say, "Buy some milk") to an empty list.

  src/test/java/todomvc/features

  package todomvc.features;
  import net.serenitybdd.junit5.SerenityJUnit5Extension;
  import net.serenitybdd.screenplay.Actor;
  import net.serenitybdd.screenplay.actions.Enter;
  import net.serenitybdd.screenplay.actions.Open;
  import net.serenitybdd.screenplay.annotations.CastMember;
  import net.serenitybdd.screenplay.questions.Text;
  import org.junit.jupiter.api.DisplayName;
  import org.junit.jupiter.api.Test;
  import org.junit.jupiter.api.extension.ExtendWith;
  import org.openqa.selenium.Keys;
  import static org.assertj.core.api.Assertions.assertThat;

  @ExtendWith(SerenityJUnit5Extension.class)
  class AddNewTodos {
    @CastMember(name = "Toby")  <·· declare and instantiate new actor "Toby"
    Actor toby;                     for our test and assign a webdriver instance
                                    that he can use to interact with our app
    @Test                           performing tasks and interactions
    @DisplayName("Add todo item to empty list")
    void addToEmptyList() {
        toby.attemptsTo(
          Open.url("https://..."),               <·· Interaction 1
          Enter.theValue("Buy some milk")        <·· Interaction 2
               .into(".new-todo")
          .thenHit(Keys.RETURN)                  <·· Interaction 3
        );
        var todos = toby.asksFor(
          Text                          <·· Question: class that knows how to
            .ofEach(".todo-list label")     retrieve a specific piece of info.
        );                                  about the state of the application.
    }
  }

  $ mvn clean verify  # Generate test reports

$ mvn verify...
[INFO] -----------------------------------------
[INFO]  SERENITY TESTS: SUCCESS
[INFO] -----------------------------------------
[INFO] | Test cases executed    | 1
[INFO] | Tests executed         | 1
[INFO] | Tests passed           | 1
[INFO] | ...
...
[INFO] SERENITY REPORTS
[INFO]   - Full Report: file:.../index.html
[INFO] ...
[INFO] BUILD SUCCESS
[[}]]

## Rest Testing:  [[{]]
* TIGHT INTEGRATION WITH REST ASSURED !!!
  https://serenity-bdd.github.io/docs/tutorials/rest

* PRESETUP:
 $ editor pom.xml
   <dependencies>
     ...
 +   <dependency>
 +     <groupId>net.serenity-bdd</groupId>
 +     <artifactId>serenity-rest-assured</artifactId>
 +     <version>${serenity.version}</version>
 +     <scope>test</scope>
 +   </dependency>
     ...
   <dependencies>
   ...
 - <reports>single-page-html</reports>      <·· by deleting this line detailed report is generated.
   src/main/java/starter                    <·· empty. Just testing public Pet Store API
   src/test/java/starter                    <·· test class/es + helpers
   src/test/java/starter/petstore/resources <·· re-use (from the template) the contents already there


  package starter.petstore;
  import io.cucumber.java.en.Given;
  import io.cucumber.java.en.Then;
  import io.cucumber.java.en.When;
  import io.restassured.http.ContentType;
  import io.restassured.mapper.ObjectMapperType;
  import net.serenitybdd.core.steps.UIInteractions;
  import org.hamcrest.Matchers;
  import static net.serenitybdd.rest.SerenityRest.*;
  public class PetApiActions extends UIInteractions { // <·· Action class (small & reusable)

    @Given("Kitty is available in the pet store")     // <·· Arrange (POST) new pet
      public Long givenKittyIsAvailableInPetStore() {
        Pet pet = new Pet("Kitty", "available");
        Long newId = given()
          .baseUri("https://petstore.swagger.io")     // <·· config reused in following tests
          .basePath("/v2/pet")                        // <·· config reused in following tests
          .body(pet, ObjectMapperType.GSON)
          .accept(ContentType.JSON)
          .contentType(ContentType.JSON)
          .post().getBody().as(Pet.class, ObjectMapperType.GSON)
          .getId();
        return newId;                                 // <·· Used as input in next step
      }

                                           //  ┌─┬─ It will take the value of param (Long) id
      @When("I ask for a pet using Kitty's ID: {0}")  // <·· Act on the API
      public void whenIAskForAPetWithId(Long id) {
        when().get("/" + id);
      }
      @Then("I get Kitty as result")                  // <·· Assert. Check API returned JSON.
      public void thenISeeKittyAsResult() {
        then()
        .body("name", Matchers.equalTo("Kitty"));
      }
  }

  ──────────────────────────────────────────────────────
  package starter.petstore;
  import net.serenitybdd.junit5.SerenityJUnit5Extension;
  import org.junit.jupiter.api.Test;                  // <··· WARN: Don't mix with org.junit.Test
  import org.junit.jupiter.api.extension.ExtendWith;  //            (JUnit4)
  @ExtendWith(SerenityJUnit5Extension.class)          // <··· Don't forget
  public class WhenFetchingAlreadyAvailablePet {      // <··· test class
            // └──┴─····· `When` prefix is one of the ways to make sure the method
            //            is recognized as a test to be run in the Maven build process.
            //            See pom.xml (maven-failsafe-plugin) for more details on this.
    Long newPetId = null;
    PetApiActions petApi;
    @Test
    public void fetchAlreadyAvailablePet() {         // ┌─ BDD ──────────────────────────────────┐
      newPetId = petApi                              // │ Given Kitty is available in pet store  │
                 .givenKittyIsAvailableInPetStore(); // │   When I ask for a pet using Kitty's ID│
      petApi.whenIAskForAPetWithId(newPetId);        // │   Then I get Kitty as result           │
    }                                                // └────────────────────────────────────────┘
    public void fetchAlreadyAvailablePet() {
      petApi.thenISeeKittyAsResult();
    }
  }

  $ mvn clean verify # Execute tests  # Report generated in target/site/serenity/index.html
  [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0,

  ...
[[}]]

## Cucumber + screenplay [[{]]
  https://serenity-bdd.github.io/docs/tutorials/cucumber-screenplay

  Use Gherkin language in `.feature` file for the well-known TodoMVC project
  Create living documentation that also serves as a test report and a progress report

  src/main/java/starter
  src/test/java/starter/helpers
  src/test/resources/features/*.feature      <··· Executable *.feature specification file
  src/test/java/starter/stepdefinitions      <··· "glue" code implementing steps mentioned in *.feature files.

  ┌─ add_new_todo.feature ─────────────────────────────────────────────┐
  │ Feature: Add new item to TODO list                                 │
  │ Scenario: Add buying milk to the list                              │
  │              Given Rama is looking at his TODO list                │
  │              When he adds "Buy some milk" to the list              │
  │              Then he sees "Buy some milk" as item in the TODO list │
  └────────────────────────────────────────────────────────────────────┘

  package starter.helpers;
  import net.serenitybdd.core.pages.PageObject;
  import net.serenitybdd.screenplay.targets.Target;
  import net.thucydides.core.annotations.DefaultUrl;
  @DefaultUrl("https://todomvc.com/examples/angularjs/#/")
  public class TodoListPage extends PageObject {  // <·· PageObject: (Screenplay pattern) helper class
                                                  //      containing all the information needed to use
                                                  //      a given web page
    public static Target ITEM_NAME_FIELD =
      Target.the("item name field").locatedBy(".new-todo");
    public static Target ITEMS_LIST =
      Target.the(" item list").locatedBy(".todo-list li");
  }

  package starter.helpers;
  import net.serenitybdd.screenplay.Performable;
  import net.serenitybdd.screenplay.Task;
  import net.serenitybdd.screenplay.actions.Open;
  public class NavigateTo {
    public static Performable theTodoListPage() {
      return Task.where(
        "{0} opens the Todo list page",
          Open.browserOn().the(TodoListPage.class));
      }
  }

  ────────────────────────────────────────────────────────────────────────────────────
  package starter.helpers;
  import net.serenitybdd.screenplay.Performable;
  import net.serenitybdd.screenplay.Task;
  import net.serenitybdd.screenplay.actions.Enter;
  import org.openqa.selenium.Keys;
  public class AddAnItem {                      // <·· (Screenplay pattern) Utility class
                                                //     explaining the steps needed to add
                                                //     an item to the list.
    public static Performable withName(String itemName){
      return Task.where(
        "{0} adds an item with name "+itemName,
             Enter.theValue(itemName)
                  .into(TodoListPage.ITEM_NAME_FIELD)
                  .thenHit(Keys.ENTER)
        );
      }
  }

  ───────────────────────────────────────────────────────────────────────────────────────────
  package starter.stepdefinitions;
  import io.cucumber.java.en.Given;
  import io.cucumber.java.en.Then;
  import io.cucumber.java.en.When;
  import net.serenitybdd.screenplay.Actor;
  import net.serenitybdd.screenplay.ensure.Ensure;
  import starter.helpers.AddAnItem;
  import starter.helpers.NavigateTo;
  import starter.helpers.TodoListPage;
  import io.cucumber.java.PendingException;

  public class AddItemStepDefinitions {               // <·· translate *feature into code
                                                      //     It looks like "spoken" English.
                                                      //     (pleasant side-effect of using Screenplay pattern)
      @Given("{actor} is looking at his TODO list")
      public void actor_is_looking_at_his_todo_list(Actor actor) {
          // throw new PendingException("Not Implemented");          // <·· Throw to mark test as peding (to fulfill)
          actor.wasAbleTo(NavigateTo.theTodoListPage());
      }
      @When("{actor} adds {string} to the list")
      public void he_adds_to_the_list(Actor actor, String itemName) {
         actor.attemptsTo(AddAnItem.withName(itemName));
      }
      @Then("{actor} sees {string} as item in the TODO list")
      public void he_sees_as_an_item_in_the_todo_list(Actor actor, String expectedItemName) {
          actor.attemptsTo(Ensure.that(TodoListPage.ITEMS_LIST).hasText(expectedItemName));
      }
  }

     $ mvn clean verify   # Run tests.
     [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 28.42 s - in starter.CucumberTestSuite
     ...
[[}]]

## 1/2-way integration with JIRA [[{]]
https://serenity-bdd.github.io/docs/reporting/integrating_with_jira

### One way integration with JIRA

* ... JIRA commonly store requirements as story cards grouped into epics.
  placed into sprints for project planning
  ┌─ JIRA Story card: ──────────────────────────────────────────────────────┐
  │ Flying High / FH-17                                                     │
  │ "Calculating status based on points"                                    │
  │ │Edit││Comment│  │Assign││More v│  │Start Progress││Resolve││Close│ ... │
  │ Details ─────────────────────────────────────────────────────────────── │
  │ Type:         Story             Status:  OPEN                           │
  │ Priority:     Major             Resolution: Unresolved                  │
  │ Affect Ver/s: None              Fix Version/s:  None                    │
  │ Labels:       None                                                      │
  │ Epic Link:    "Earning Points"                                          │
  │ Acceptance:   * New members should start with Bronze status             │
  │   Criteria    * Memebers should get status updates based on             │
  │                 status points earned.                                   │
  │ Description ─────────────────────────────────────────────────────────── │
  │ As a Frequent Flyer member                                              │
  │ I want my status to be upgraded as soon as I earn enough points         │
  │ So that I can benefit from my igher status sooner                       │
  └─────────────────────────────────────────────────────────────────────────┘

  ┌─ KEYPOINT  ──────────────────────────────────────────────────────────────
  │ acceptance criteria can be built into more detailed scenarios, based on
  │ concrete examples. We can then automate these scenarios using a BDD
  │ tool like JBehave.
  └──────────────────────────────────────────────────────────────────────────

  Acceptance criteria as seen by JBehave scenario:
  │ Frequent Flyer status is calculated based on points
┌·> Meta:@issue #FH-17
· │ Scenario: New members should start out as Bronze members
· │ Given Jill Smith is not a Frequent Flyer member
· │ When she registers on the Frequent Flyer program
· │ Then she should have a status of Bronze
· │
· │ Scenario: Members should get status updates based on status points earned
· │ Given a member has a status of <initialStatus>
· │ And he has <initialStatusPoints> status points
· │ When he earns <extraPoints> extra status points
· │ Then he should have a status of <finalStatus>
· │
· │ Examples:
· │ | initialStatus| initialStatusPoints|extraPoints|finalStatus|notes                |
· │ | Bronze       | 0                  |300        |Silver     |300 points for Silver|
· │ | Silver       | 0                  |700        |Gold       |700 points for Gold  |
· │ | Gold         | 0                  |1500       |Platinum   |1500 points for Plat.|
·
└─ @issue associate JBehave-stories|JUnit-tests to JIRA card
          creating  HTML links to JIRA task.

   JIRA setup:
   serenity.properties
 + jira.url=https://srv1.atlassian.netjira.project=FHjira.username=$user.password=$pass

   (props. can also be set in graddle.settings or maven pom.xml)

* Automatically feedback JIRA about tests results:

   pom.xml:
  │<dependencies>
  │    ...
 +│    <dependency>
 +│        <groupId>net.serenity.plugins.jira</groupId>
 +│        <artifactId>serenity-jira-requirements-provider</artifactId>
 +│        <version>xxx</version>
 +│    </dependency></dependencies>
  │</dependencies>
  │...
  │<build>
  │    ...
  │    <plugins>
  │        ...
  │        <plugin>
  │            <groupId>net.serenity.maven.plugins</groupId>
  │            <artifactId>maven-serenity-plugin</artifactId>
  │            <version>xxx</version>
  │            <executions>
 +│                <execution>
 +│                    <id>serenity-reports</id>
 +│                    <phase>post-integration-test</phase>
 +│                    <goals>
 +│                        <goal>aggregate</goal>
 +│                    </goals>
 +│                </execution>
  │            </executions>
  │            <dependencies>
 +│                <dependency>
 +│                    <groupId>net.serenity.plugins.jira</groupId>
 +│                    <artifactId>serenity-jira-requirements-provider</artifactId>
 +│                    <version>xxx</version>
 +│                </dependency>
  │            </dependencies>
  │        </plugin>
  │    </plugins>
  │</build>

   serenity.properties
  │...
 +│jira.custom.field.1=Acceptance Criteria     <··· add to report output

   Now, when running the tests,  Serenity will query JIRA to determine
   the epics and stories that you have defined and list them on the
   Requirements page of the output report.

   |Overall Test Result|   |Requirements|  |Releases|  ....

    Requirements Overview
    Requirement Type  |   Total  | Pass   | Fail  | Pending   | Ignored | Untested
    Epics                   7  ...
    Stories                15  ...
    Acceptance Criteria   100  ...  (tests)


### Two way integration with JIRA

* Simplest way:
   ┌─ serenity.properties  ────
   │ ...
  +│ serenity.public.url=https://.../serenity/report <·· tell Serenity where reports live
   │ ...                                                 Serenity will then insert a link
   │                                                     into the JIRA issue card
  +│ serenity.jira.workflow.active=true
                                   └┬─┘
     (Optional) Update JIRA issue states (deactivated by default)
     default JIRA workflow: open or in progress issues associated with
     successful tests will be resolved, and closed or resolved issues
     associated with failing tests will be reopened.


    NOTE: to skip updates to JIRA (for example, testing in local -vs QA enviroment)
     serenity.skip.jira.updates=true

  Customized JIRA workflows:  (Groovy DSL)

   + serenity.jira.workflow=my-workflow.groovy
   ┌────────────────┬─·····─┴────────────────┘
   my-workflow.groovy
   when 'Open'       , {    'success' should: 'Resolve Issue'}
   when 'Reopened'   , {    'success' should: 'Resolve Issue'}
   when 'Resolved'   , {    'failure' should: 'Reopen Issue'}
   when 'In Progress', {    'success' should: ['Stop Progress','Resolve Issue']}
   when 'Closed'     , {    'failure' should: 'Reopen Issue'}


### RELEASE MANAGEMENT
In JIRA, project releases are commonly organised into versions:

   PROJECT XXXX
     Key: FH Lead: ...

     |Overview| |Administration|
      ^^^^^^^^
      Summary    ┌─────────────────────────────────────────────────────────────
      Issues     │ VERSIONS
      Agile      │ Name           Start Date     Release Date    Description
      Change Log │ ──────────────────────────────────────────────────────────
      Reports    │ Release 2.0
      Versions  ─┤ Iteration 1.3
      Calendar   │ ...
                 │ Release 1.0
                   └─────┬──────┘
                  - To JIRA they all are flat versions.
                  - Serenity use a hierarchical structure based on naming convention:
                    "release"  : 1st level
                    "iteration": 2nd level
                    (or "sprint")
                   - Use next config. property to customize the behaviour. Ex:
                     serenity.release.types=milestone, release, version
[[}]]

## TODO:
  https://serenity-bdd.github.io/docs/reporting/the_serenity_reports
  Serenity reports aim not only to report test results, but also
  to document how features are tested, and what the application does.

  https://serenity-bdd.github.io/docs/reporting/living_documentation !!!
  - BDD Tests as Living documentation describing the software

  https://serenity-bdd.github.io/docs/reporting/filtering_reports
  https://serenity-bdd.github.io/docs/reporting/additional_reports
  - e-mail reports!
  - Single page react app reports.

  https://serenity-bdd.github.io/docs/reporting/reports_custom_info
  Custom fields can be included in the reports, using values that are
  either taken from the environment variables or passed into the build
  via system properties. This can be useful if you want to include the
  product or build version, the environment the tests were run on, or
  the test run date.

  https://serenity-bdd.github.io/docs/cloud/selenium-grid
  execute WebDriver scripts on remote parallel machines (virtual or real)
  by routing commands sent by the client to remote browser instances.


  https://serenity-bdd.github.io/docs/cloud/lambdatest
  LambdaTest is a cloud platform for test execution and test
  orchestration. With LambdaTest, Serenity users can extend their
  automation test coverage of their web and mobile apps on 3000+ real
  devices, browsers, and operating systems.

  https://serenity-bdd.github.io/docs/cloud/browserstack
  online platform that allows you to run cross-browser tests in parallel at scale.

  https://serenity-bdd.github.io/docs/cloud/saucelabs
  seamless integration with the SauceLabs online test automation platform.
  "Test on thousands of device, browser, and OS configurations – anywhere, any time"

  https://serenity-bdd.github.io/docs/cloud/bitbar
  seamless integration with the BitBar online test automation platform
  web, native, or hybrid, securely test your app across real environments

  https://serenity-bdd.github.io/docs/mobile/appium
  running tests on mobile devices/emulators

  https://serenity-bdd.github.io/docs/reference/serenity-properties
  Serenity configuration options.



[[qa.testing.bdd.serenity}]]

[[{async/reactive.testing,qa.testing.async/reactive,01_PM.TODO]]
# Awaitility(Async->Sync) Tests
@[https://github.com/awaitility/awaitility]
- Awaitility: DSL allowing to express async results (test expectations) easely.
  removing complexity of handling threads, timeouts, concurrency issues, ...
  that obscured test code.

- Ex 1:
  @Test
  public void updatesCustomerStatus() {
    // Publish a (async) message to a message broker:
    messageBroker.publishMessage(updateCustomerStatusMessage);
    await().atMost(5, SECONDS).until(customerStatusIsUpdated()) ;
    ...
  }
[[}]]

# RESTAssured: REST API Full Journey testing [[{qa.testing.REST_API,persistence.json]]

*

## Maven setup

  ```
  <properties>
    <restassured.ver>5.2.0</restassured.ver>
  </properties>
  ...
  <dependency>
      <groupId>io.rest-assured</groupId>
      <artifactId>json-schema-validator</artifactId>
      <version>${restassured.ver}</version>
      <scope>test</scope>
  </dependency>
  <dependency>
      <groupId>io.rest-assured</groupId>
      <artifactId>json-schema-validator</artifactId>
      <version>${restassured.ver}</version>
  </dependency>

## REST Assured summary
* Gherkins standard BDD syntax "GIVEN > WHEN > THEN "
  replaces RestAssured 1.0 syntax `given()...expect()... when()`
  (still supported for compatibility)

  given().param("x", "y")....
   when().get("/lotto").
   then().statusCode(400).
    and().body("lotto.lottoId", equalTo(6));
    └───┴─ syntactic sugar. Not really needed.

import from io.restassured.RestAssured.*                   // Static imports, recomended
import from io.restassured.matcher.RestAssuredMatchers.*
import from org.hamcrest.Matchers.*                   // equalTo, hasItems

import from io.restassured.module.jsv.JsonSchemaValidator.* // Json Schema validation Support !!!
                                                            // See original link to configure options
import from io.restassured.module.mockmvc.RestAssuredMockMvc.* // spring-mock-mvc unit test support


                given().
                        param("key1", "val1"). // <·· set request params. REST Assured will
                        param("key2", "val2").        automatically try  query|form format
                        param("key3").         // <·· no value
                        param("list1", "val1", "val2").
                        param("list1", "val1", "val2").
                        cookie("favourite", "Red", "Green"). // <·· Use new Cookie.Builder for details.
                        header("MyHeader", "Something").
                        contentType("application/json").   // or ContentType.TEXT or
                                                           // noContentType() (for no contentType at all)
                        request().body("some body").       // Works for POST, PUT and DELETE requests
                                       ^^^^^^^^^^^         // request() is optional. It makes it more explicit
                        //         or  new byte[]{42,1,..}
                  ····  pathParam("pathKey1", "23").
                  ·     // queryParam("queryParamName", "value2"). <·· explicit query or post
              ┌───┴────┐// formParam("formParamName", "value1").
   > GET /AAA/{pathKey1}
                 when().
                        get("/AAA/{pathKey1}").
                 then().
                        assertThat().                      // Syntax Sugar. Not really needed.
                        body( // match against JSON-schema
                          matchesJsonSchemaInClasspath("myschema.json")).
                        body(equalTo("{...}")). // <·· Full body/content matching
                        body("key1.%s[%d]", withArgs(key2, index2), equalTo(...)) // path arguments
                        and().cookie("cookieName", "cookieValue" /*or containsString("cookieValue1")*/ ).
                        and().statusCode(200).
                        and().statusLine("something" /* or containsString("some") */).
                        and().contentType(ContentType.JSON).
                        and().header("headerName", "headerValue").
                        and().header("Content-Length",
                                      Integer::parseInt,   // <·· Use mapping function
                                      lessThan(1000));

   Ex: JSON Response like:           JSON assert:
   < {                               ...assertThat()....
   <   "lotto":{
   <    "lottoId":5,                 and().body("lotto.lottoId", equalTo(5));
   <    "winning-numbers":[2,45,34],
   <    "winners":[{
   <      "winnerId":[23,54],        and().body("lotto.winners.winnerId", hasItems(23, 54));
   <      "numbers":[2,45,34]                                └── Groovy's GPath ───┘
   <    },{                                                      Not to be confused with Jayway's
   <      "winnerId":54,                                        JsonPath syntax
   <      "numbers":[52,3,12]
   <    }]
   <   }
   <   "price":12.12                 and().body("price", is(12.12f))
   < }                                                   └────┬───┘
                                                     or  is(new BigDecimal(12.12)
                                             NOTE: to convert to BigDecimal:
                                                given().config(
                                                  RestAssured.config().jsonConfig(
                                                   jsonConfig().numberReturnType(BIG_DECIMAL)))
                                             NOTE: is(12.12) fails (double, expected float)
## Recipes:
* Validating JSON root documents with "$":
   tested body JSON:     RESTAssured test:
   [1, 2, 3]             body("$", hasItems(1, 2, 3));

  > POST /greetXML                      given().parameters(
  > firstName=John                        "firstName", "John",
  > lastName=Doe                          "lastName", "Doe").when().post("/greetXML").
                                          then().
  < <greeting>                            assertThat().body(matchesXsd(xsd).
  <    <firstName>John</firstName>        body("greeting.firstName", equalTo("John")).
  <    <lastName>Doe</lastName>           body("greeting.lastName", equalTo("Doe"));
  < </greeting>                           └──────────────────┬────────────────────┘
                                 or  body(hasXPath("/greeting/lastName", containsString("Do"))
                                 or       hasXPath("/greeting/firstName[text()='John']"));

## Default values [[{]]
RestAssured.baseURI = "http://myhost.org";  // defaults to http://localhost
RestAssured.port = 80;                      // defaults to 8080
RestAssured.basePath = "/resource";         // get("/hello") => GET /resource/hello
RestAssured.authentication = basic(...);
RestAssured.rootPath = "x.y.z";             // body("x.y.z.keyX",..) => body("keyX",..)

RestAssured.filters(..);               // List of default filters
RestAssured.requestSpecification = ..  // Default request specification
RestAssured.responseSpecification = .. // Default response specification
RestAssured.urlEncodingEnabled = ..    // should URL encode the parameters? def: true
RestAssured.defaultParser = ..         // default parser for response bodies
                                          if no registered parser can handle data
                                          of the response content-type
RestAssured.registerParser(..)         // Specify a parser for given content-type
RestAssured.unregisterParser(..)       // Unregister a parser for the given content-type

RestAssured.reset();                   // Reset baseURI, basePath, port, root path, Auth.Scheme
                                          and url encoding to defaults
RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();
[[}]]

## Complex parsing and validation:  [[{]]
*  (where REST Assured really starts to shine!)

    POST /shopping

    <shopping>
  ··> <category type="grocery">
  ·     <item>Cream</item>
  ·     <item>Coffee</item>
  ·   </category>
  ·   <category type="supplies">
  ·     ...
  ·   </category>
  ·     ...
  · </shopping>
  ·
  · given().get(..).when().
  └ body(
    "shopping.category.find { it.@type == 'grocery' }.item", hasItems("Cream", "Coffee"));
     └──────┬────────┘
      Depth-first·> **.find
      shorcut in XML   └┬─┘ └────────────┬──────────┘
      document          ·      Groovy Closure
                        ·
    ┌─·················─┘
    find:    finds first item  matching a closure predicate
    findAll: finds all   items matching a closure predicate
    collect: collect the return value of calling a closure on each item in a collection
    sum:     Sum all the items in the collection
    max/min: returns the max/min values of the collection

    Alternatively. Do not validate to Hamcrest. Keep processing manually
    String response = get("/shopping").asString(); // Get response body as String
    List<String> groceries = get("/shopping")
                             .path("shopping.category.find { it.@type == 'groceries' }.item");

    POST /store                      when().get("/store").then()
    {
     "store":{                       .body(
      "book":[                          "store.book.findAll { it.price < 10 }.title",
         {"price":8.95, ... },          hasItems("title1", "title2"));
         {"price":8.99, ... },       Or ...
         ...                         final List<String> bookTitles =
                                     from(response).getList( // "from":JsonPath static import
      ]                               "store.book.findAll { it.price < 10 }.title");
     }
    }

  when().get("/...").then().body(
   "store.book.author.collect { it.length() }.sum()", // Check: length sum of all-author-names > 50
   greaterThan(50));
  or ...
   body("store.book.author*.length().sum()", greaterThan(50))
                          ^ └──────^·····┐
    ┌─···················─┘              ·
   `*.`: Groovy spread operator, call function for
         each element in list returning new list with
         lengths results (sort of map)

  or:
  String response = get("/store").asString(); // get response as string
  int sumOfAllAuthorLengths = from(response)
      .getInt("store.book.author*.length().sum()");
  assertThat(sumOfAllAuthorLengths, is(53));
[[}]]

## Deserialization with Generics 3.3+ [[{]]
   [                                    final List<
     {                                   Map<String /* key: id, name, price, tags, ...*/, Object>
       "id": 2,                         > products = get("/products").as(new TypeRef<List<Map<String, Object>>>() {});
       "name": "An ice sculpture",
       "price": 12.50,                  assertThat(products, hasSize(2));
       "tags": ["cold", "ice"],         assertThat(products.get(0).get("id"   ), equalTo(2));
       "dimensions": { ... },           assertThat(products.get(0).get("name" ), equalTo("An ice sculpture"));
     },                                 assertThat(products.get(0).get("price"), equalTo(12.5));
     {
       "id": 3,                         assertThat(products.get(1).get("id"   ), equalTo(3));
       "name": "A blue mouse",          assertThat(products.get(1).get("name" ), equalTo("A blue mouse"));
       "price": 25.50,                  assertThat(products.get(1).get("price"), equalTo(25.5));```
       ...
     }
   ]
[[}]]

### GETTING RESPONSE DATA
  with (InputStream stream = get("/lotto").asInputStream()) { // Alt 1:
    ...
  }
  byte[] byteArray = get("/lotto").asByteArray(); // Alt 2
  String json = get("/lotto").asString(); // Alt 3

### Validate response, then extract data:

  final String nextTitleLink =
    given().param("param_name", "param_value").  ┐
    when().get("/title").                        ├ validate response
    then().contentType(JSON).                    │
           body("title", equalTo("My Title")).   ┘
    extract().path("links.next.href");           ├ <· extract object from json tree

    Alternatively, get all response:
    final Response fullRes = ...
       extract().response();
    final String
      s1 = fullRes.path("links.next.href"),
      s2 = fullRes.header("headerName");
    final Headers             allHeaders = response.getHeaders();
    final List<String>       sAllHeaders = response.getHeaders().getValues();
    final Map<String, String> allCookies = response.getCookies();
    final List<String>        sAllCokies = response.getCookies().getValues();
    final String              statusLine = response.getStatusLine();
    final int statusCode                 = response.getStatusCode();
    final ??? detailedCookie             = response.getDetailedCookie("cookie1"); // path, expiry date, ...

## Recipe: ReposnoseAware>Matcher:

  > GET /some-id
  < { "userId" : "some-id", "href" : ".../some-id" }
                  └─────┴─·· must be == ··┴─────┘

  Test like:
  ....body("href", response -> equalTo(".../" + response.path("userId"));

## predefined matchers:
   get("/x").then().body("href", endsWithPath("userId"));
                   .body("href", and(                           // <·· composing ResponseAwareMatchers
                                  startsWith("..."),
                                  endsWithPath("userId")  ));

## Measuring response time: (v 2.8+)
  * Added support to measure and test response time. Examples:
    long timeInMs = get("/lotto").time()
    long timeInSc = get("/lotto").timeIn(TimeUnit.SECONDS);
    when().get("/lotto").then().time(lessThan(2000L)); // Milliseconds
    when().get("/lotto").then().time(lessThan(2L), TimeUnit.SECONDS);

    WARN: time measurement should be performed when the JVM is hot!

## OAuth 1/2 Authentication [[{]]
### Presetup (OAuth 1 and OAuth 2 when supplying token as query parameter):
   $ editor pom.xml
     ...
   + <dependency>
   +   <groupId>com.github.scribejava</groupId>
   +   <artifactId>scribejava-apis</artifactId>
   +   <version>2.5.3</version>
   +   <scope>test</scope>
   + </dependency>


   given().auth().oauth(..          )... // OAuth 1
   given().auth().oauth2(accessToken)...            // OAuth 2. Put OAuth2 accessToken in a header.
   given().auth().preemptive().oauth2(accessToken). // OAuth 2. explicit alternative
   given().auth().oauth2(accessToken,               // OAuth 2. with token in query param (requirest Scribe)
                        OAuthSignature.QUERY_STRING).
[[}]]

## Other Authentication Schemas
  given().auth().form("John", "Doe").              // Form auth
  given().auth().digest("username", "password").   // Digest auth.
  given().auth().basic ("username", "password").   // Basic preemptive | Challenged Alt 1.
   when().get(...)....
  RestAssured.authentication =                     // Basic preemptive | Challenged Alt 2.
                 basic ("username", "password");


## Cross-site Request Forgery Support (CSRF)
* Today it's common for the server to supply a CSRF token with
  the response in order to avoid these kinds of attacks.
* REST Assured has support for automatically parsing and supplying the CSRF token to the server.
  In order for this to work REST Assured must make an additional request and parse (parts) of the website.

* REST Assured supports two ways of providing CSRF tokens to the server:
1. submitting the CSRF token in a form

  <form action="/users" method="POST">
    <input type="hidden" name="_csrf"                <·· CSRF token that "we" want to "forward"
      value="8adf2ea1-b246-40aa-8e13-a85fb7914341"/>     in new request
    ...
  </form>

  // RestAssuredConfig.config()
  //    .csrfConfig(csrfConfig().with()
  //       .csrfInputFieldName("_mycsrf"));  // <·· change default "_csrf" name
  given(). csrf("/users/form", "_csrf")          // <·· Exec. GET request to /users, expecting
          formParam("firstName", "John")         //     as result a form as response with input field `_csrf`
          formParam("lastName", "Doe")
   when().post("/users").
   then().statusCode(200);

2. submitting the CSRF token as a header.

   > GET /LOGIN

   < <head>
   <   <meta name="_csrf_header"
   <      content="ab8722b1-1f23-4dcf-bf63-fb8b94be4107"/>
   <   ...
   < </head>

  // RestAssuredConfig.config()
  //    .csrfConfig(csrfConfig().with()
  //       .csrfMetaTagName("_my_csrf_header") // <·· Change default "_csrf_header" name
  //       .csrfHeaderName("MyHeader"));       // <·· Change default "X-CSRF-TOKEN" name
     RestAssuredConfig.config().
   given().csrf("/login").  // fetch _csrf_header token to be included next as X-CSRF-TOKEN in POST
    when().post("/pageRequiringCSRF").
    then()....

   RestAssuredConfig.config()
     .csrfConfig(csrfConfig().with()

## Object Mapping
* Jackson/2 for JSON, Gson, Johnzon for classpath and Jakarta EE or JAXB for XML
  // Refer to original doc.

## Specification Re-use
* Use RequestSpecBuilder and/or ResponseSpecBuilder.


  final RequestSpecBuilder builder = new RequestSpecBuilder();
  builder.addParam("parameter1", "parameterValue");
  builder.addHeader("header1", "headerValue");
  RequestSpecification requestSpec = builder.build();
  //          ┌────────┴─────────┘
  // Querying it later on
  // QueryableRequestSpecification queryable = SpecificationQuerier.query(requestSpec);
  // String headerValue = queryable.getHeaders().getValue("header");
  // String param = queryable.getFormParams().get("someparam");


  final ResponseSpecBuilder builder = new ResponseSpecBuilder();
  builder.expectStatusCode(200);
  builder.expectBody("x.y.size()", is(2));
  ResponseSpecification responseSpec = builder.build();

  given().spec(requestSpec).                     // <·· RESUE REQUEST SPEC !!
          param("parameter2", "paramValue").     // <·· extend it
   when().get("/something").
   then().spec(responseSpec).                    // <·· REUSE RESPONSE SPEC !!
          body("x.y.z", equalTo("something"));   // <·· Extend it


## Filters: inspect&alter requests and responses.  [[{]]

* Filters can be used to implement custom authentication schemes,
  session management, logging etc.

   import io.restassured.filter.Filter
   io.restassured.filter.OrderedFilter // v 3.0.2+
   given().filter(new MyFilter()). ..

   // NOTE: sometimes is useful to change the response. Do it like:
   final Response newResponse = new ResponseBuilder().
         clone(originalResponse).setBody("Something").build();

### ready to use filters
* io.restassured.filter.log.RequestLoggingFilter : print request spec details.
  given().log().XXX().    // v1.5+
                └─┴─··· all │ params │ body │ headers │ cookies │ method │path
                        WARN: underlying HTTP Builder & HTTP Client can add extra
                        info (HEADERs, ...) not logged.
          log().ifValidationFails().
          get().
   then().log().XXX()                        // alt 1: log all responses
   then().log().ifError().                   // alt 2: log only on errors
   then().log().ifStatusCodeIsEqualTo(302).  // alt 3
   then().log().ifStatusCodeMatches(matcher).// alt 4
   then().log().ifValidationFails().
          onFailMessage("messageXXX").       // to be displayed on failure 4.5.0+
   ...
          └─┴─········· all | statusLine | headers | cookies



* io.restassured.filter.log.ResponseLoggingFilter: print response details if matching
                                                   a given status code.
* io.restassured.filter.log.ErrorLoggingFilter   : print response body if error raised
                                                   [400... 599]
[[}]]


## Session Support
given().sessionId("1234").            // Alt 1
given().cookie("JSESSIONID", "1234"). // Alt 2
RestAssured.sessionId = "1234";       // Alt 3
RequestSpecBuilder reqSpec =
   new RequestSpecBuilder()...        // Alt 4. Reusable spec
       setSessionId("value1").build();
SessionFilter sessionFilter =         // Alt 5. Session Filter v2.0.0+
             new SessionFilter();
given().filter(sessionFilter)....

RestAssured.config = RestAssured.config().
   sessionConfig(
    new SessionConfig()
      .sessionIdName("phpsessionid")); // Change JSESSIONID ··> phpsessionid

String sessionId = get("/").sessionId(); // Retrieve in response

Session Filter

## SSL for non-standard certificates or PKI setups.  [[{]]

* Relaxed verification setup:
   SSLPeerUnverifiedException
      given().relaxedHTTPSValidation()      // SSL
      given().relaxedHTTPSValidation("TLS") // TLS

   RestAssured.useRelaxedHTTPSValidation();

* Custom PKI (Certificate chains):

  given().keystore("/pathToJksInClassPath", pass). ..   // alt 1
  RestAssured.keystore("/pathToJksInClassPath", pass);  // alt 2
  RestAssured.trustStore(keystore);                           // alt 3. An keystore is already loaded

* SSL invalid hostname error "relaxing":
  RestAssured.config().sslConfig(sslConfig().allowAllHostnames());

[[}]]

## Disable URL Encoding
   Use case: URL already encoded
String response = given().urlEncodingEnabled(false)
                   then().get("/v1/search?jql=project%20=%20BAM%20AND%20issuetype%20=%20Bug");

## Proxy Configuration
  given().proxy("localhost", 8888).  // Setup HTTP Proxy 2.3.2+
  given().proxy(host("localhost").withScheme("https")). // Setup HTTPs proxy 2.3.2+
  given().proxy(auth("username", "password")).when() .. // Setup HTTP proxy with preemptive basic auth.

  RestAssured.proxy("localhost", 8888);     // Config HTTP proxy globally
  RequestSpecification reqSpec = new        // Config HTTP proxy in reusable request spec.
     RequestSpecBuilder().setProxy("localhost").build();

## Redirect DSL

   given().redirects().max(12).and().redirects().follow(true).when(). ..

## Connection Config

   RestAssured.config = RestAssured.config().connectionConfig(
     connectionConfig().closeIdleConnectionsAfterEachResponse());

## FailureConfig 3.3.0+ (log, notify failures)
   It allows to get callbacks when validations fails.
  e.g.: get email in case of failure:
  final ResponseValidationFailureListener emailOnFailure =
    (reqSpec, respSpec, resp) -> emailService.sendEmail(...);
  given().
    config(RestAssured.config().failureConfig(
       failureConfig().with().failureListeners(emailOnFailure)))....


  ```

## FULL JOURNEY Example
  (WARN: Some code can be outdated)

  ```java
  package com.mycompany.myproject.mymodule;

  import static junit.framework.TestCase.assertTrue;
  import static org.hamcrest.Matchers.*;

  import static io.restassured.RestAssured.given;

  import io.restassured.RestAssured;
  import io.restassured.config.HttpClientConfig;
  import io.restassured.path.json.JsonPath;
  import io.restassured.response.Response;
  import io.restassured.specification.RequestSpecification;
  import junit.framework.TestCase;
  import org.apache.http.client.HttpClient;
  import org.apache.http.impl.client.SystemDefaultHttpClient;
  import org.apache.http.params.HttpConnectionParams;
  import org.apache.http.params.HttpParams;
  import org.eclipse.jetty.http.HttpStatus;
  import org.junit.Ignore;
  import org.junit.Test;
  import org.junit.BeforeClass;

  import org.hamcrest.BaseMatcher;
  import org.hamcrest.Description;

  import java.util.Base64;
  import java.util.Map;

  public class FullJourneyTest {

    public static class RegexMatcher
    extends BaseMatcher<Object> {                        // <··· PRESETUP: CREATE CUSTOM REGEX MATCHER
      private final String regex;
      public RegexMatcher (String regex){
        this.regex = regex;
      }

      @Override
      public boolean matches (Object o){
        return ((String)o).matches(regex);
      }

      @Override
      public void describeTo(Description desc){
        desc.appendText("matches regex="+this.regex);
      }
    }

    public static classG Base64Matcher                     // <···· PRESETUP: CREATE CUSTOM Base64Matched
    extends BaseMatcher<Object> {

      public Base64Matcher(){}
      @Override
      public boolean matches (Object o){
        try {
          Base64.getDecoder().decode((String)o);
          return true;
        }catch (Exception e){
          return false;
        }
      }

      @Override
      public void describeTo (Description description){
        description.appendText("can be parsed as Base64");
      }
    }

    private static final String
      AUTH_HEADER_VALUE = "Bearer " + ServerConfig.apiKey;  // <·· PRESETUP: An API KEY is available for tests

    protected static
    RequestSpecification setupCommonHeaders() {             // <·· utility class. Setup headers.
      return given()
            .header("Authorization", AUTH_HEADER_VALUE)
            .header("Accept"       , "application/json")
            .header("content-type" , "application/json;charset=utf-8")
      .log().all();
    }

    private final String
      NAME="COMMUNITY_1", SYMBOL="SY1";

    private Response response;

    @BeforeClass
    public static void setup() {                           // <·· PRESETUP: Setup test URL... before each test
      RestAssured.port   = ServerConfig.serverPort;        //     Setup RestAssured config.
      RestAssured.basePath = "/";
      RestAssured.baseURI  = "http://localhost";

      HttpClientConfig clientConfig =
	RestAssured.config().getHttpClientConfig();
      clientConfig = clientConfig.
        httpClientFactory(
        new HttpClientConfig.HttpClientFactory() {
          @Override
          public HttpClient createHttpClient() {
            HttpClient rv =  new SystemDefaultHttpClient();
            HttpParams httpParams = rv.getParams();
            HttpConnectionParams                           // <·· Wait 5s max for a connection
		.setConnectionTimeout(httpParams, 5 * 1000);
            HttpConnectionParams                           // <·· Set Default session Tiemout: 60s
                .setSoTimeout(httpParams, 60 * 1000);
            return rv;
          }
        });

      clientConfig = clientConfig                          // <·· This is necessary to ensure that client is reused
                     .reuseHttpClientInstance();
      RestAssured.config = RestAssured
                             .config()
                             .httpClient(clientConfig);
    }

    @Test
    public void A010_PutNewCommunityAndNewUserForPendingToMineCommunity() {
      String jsonBody1 = String.format("""
        {
          "name"  : "%s",
          "symbol": "%s",
        }
        """, NAME, SYMBOL) ;
      response = setupCommonHeaders().body(jsonBody1)
                 .when().post("/Route/To/REST/API/01") ;
      System.out.println(response.body().prettyPrint());
      response.then()
        .statusCode(HttpStatus.ACCEPTED_202)
        .body("size()", is(5)                      )
        .body("id"    , not(isEmptyString())       )
        .body("pubkey", not(isEmptyString())       ) //  get sure it's not empty
        .body("pubkey", new RegexMatcher("^{65}$") ) // and get sure that it matches Regex
        .body("pubkey", new Base64Matcher()        ) // and get sure it is Bas64 encoded
        .body("name"  , equalTo(NAME)              )
        .body("symbol", equalTo(SYMBOL)            )
      ;
      String NEW_ID = response.getBody().jsonPath().get("id") ;

      // Next related test to execute synchronously after fetching NEW_ID
      final String jsonBody2 = String.format("""
        {
          "FK_ID": "%s",
         ...
        }""", NEW_ID);
      response = setupCommonHeaders().body(jsonBody2)
         .when(). post("/Route/To/REST/API/02") ;
      ...
    }
  }
  ```

## What's new

* 5.2
  * Much improved Cross-site request forgery support. Example  [[{security]]
    given().csrf("/users").                // <·· make a GET request to /users
                                           //     to fetch page containing the  CSRF token.
                                           //     Rest Assured will then automatically try to
                                           //     find the input field that contains the CSRF token
            formParm("firstName", "John").
            when().post("/users").         // <·· and include it in the POST to /users.
            then().statusCode(200);

                                                               [[security}]]
* 5.0
  * Use Groovy 4.0 under the hood.
* 4.5
  * Introduced rest-assured bom project for maven.
  * Add onFailMessage to more easily  distinguish between failed tests
    when().get().then()
      .onFailMessage("Some specific message")
      .statusCode(200);

* 4.2
  * Allows to blacklist displaying headers in request|response log.
    given().config(config().logConfig(logConfig().blacklistHeader("Accept"))). ..

* 4.0
  * Allows to specify multi-expectation body with arguments. Examples:
    when().get("/jsonStore").
    then()
    .rootPath("store.book.find { it.author == '%s' }")
    .body(
      "price", withArgs("Nigel Rees"  ), is(8.95f),
      "price", withArgs("Evelyn Waugh"), is(12.99f)
    );
* 3.2
  * New Spring Web Test Client module to test Spring Reactive Web stack components.
    for example, Spring (Webflux) Controllers.
  * OSGi support.
* 3.1
  * Allow querying (extracting values out of) a request specification without
    using a filter by using `io.restassured.specification.SpecificationQuerier`. For example:
    ```
    RequestSpecification spec = ...
    QueryableRequestSpecification queryable = SpecificationQuerier.query(spec);
    String headerValue = queryable.getHeaders().getValue("header");
    String param = queryable.getFormParams().get("someparam");
    ```
  * Lot's of improvements to filters (FilterableRequestSpecification). Example:
    * FilterableRequestSpecification#path: change request-path from a filter
    * FilterableRequestSpecification#removeQueryParam to remove parameters.
    * Get undefined path parameter placeholders
    * ...
  * Automatically adds supports for spring rest docs path parameter documentation
    if spring-restdocs-mockmvc is in classpath.

* 3.1
  * Allow a mapping function when validating headers. Example:
    when().get("/something").then()
      .header(
          "Content-Length",
          Integer::parseInt,  // <··· Map Header to Integer
          lessThan(1000) );   // <··· Then check that is is smaller than 1000

[[}]]

# TODO:
## Facebook Infer
    @[http://fbinfer.com/] (Static analysis Java/C/...)
## Scrutinizer
## StopBugs
## Eclipse Static Code Analasys [[{]]
    Eclipse → Properties → Java → Compiler → Errors/Warnings → Null analysis:
    * Null pointer access
    * Potential null pointer access
    * Redundant null check:
        - Include 'assert' in null analysis
        - Enable annotation-based null analysis
        - Violation of null specification
        - Conflict between null annotations an null inference
        - Unchecked conversion from non-annotated type to @NonNull type
        - Problems detected by pessimistic analysis fro free type variables
        - Unsafe "@Nonnull" interpretation of the free type variable from library
        - Redundant null anotation:
        - "@NonNull" parametere not annotated in overriding method
        - Missing "@NonNullByDefault" annotation on package
          - Use default annotations for null specifications (configure)
          - Inherit null annotations
          - Enable syntatic null analisys for fields
        - Treat above errors like fatal compile erros
          (make compiled code not executable)

## SpotBug examples
@[https://spotbugs.readthedocs.io/en/latest/filter.html]

# # Mockito [[{qa.testing.101,01_PM.TODO]]
* Top voted Java testing framework in StackOverflow
* Top 10 most-widely used Java amongt 30.000 inspected projects.
[[}]]

## JfrUnit [[{qa.testing,scalability.profiling,01_PM.TODO]]
@[https://github.com/moditect/jfrunit]
- JUnit extension for asserting JDK Flight Recorder events
  emitted by an application identifying performance regressions
  (e.g. increased latencies, reduced throughput).

- JfrUnit supports assertions not on metrics like latency/throughput
  themselves, but on indirect metrics which may impact those.
  - memory allocation,
  - database IO
  - number of executed SQL statements
  - ...

- JfrUnit provide means of identifying and analysizing such issues in
  a reliable, environment independent way in standard JUnit tests,
  before they manifest as performance regressions in production.
[[}]]

## Tablasco [[{qa.testing.data,architecture.batch,01_PM.low_code,01_PM.TODO]]
@[https://github.com/goldmansachs/tablasco]
- (By Goldman Sasch) JUnit rule that adds table verification to unit
  tests. For software products that produce large amounts of data, this
  tool can help to create automated tests that are both comprehensive
  and easy to maintain. Users only need to adapt their existing data to
  a table format that Tablasco understands. “Every test produces a
  color-coded HTML break report, which helps users quickly identify the
  issue,” said Barry, a vice president in the Technology Division.
  Furthermore, Tablasco features automated baseline management,
  allowing users to easily update the baseline file of a failing test.

- JUnit rule for comparing tables and Spark module for comparing large data sets.
[[}]]


[[}]]
