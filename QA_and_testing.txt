## Apropos
* JAVA .
* Content is versioned in git.  commits, issues and pull-requests welcome!
  @[https://www.github.com/earizon/JAVA]
* This __"cheat-sheet with steroids"__ presents an always-growing set of
  Quality Assurance and Testing "Zipped" notes well ordered&amp;classified 
  extracted from many, many places and author's own experience in different
  projects.

# Cost of software failures [[{qa.billion_dolar_mistake]]
$312 billion per year: global cost of software bug (2013)
$300 billion dealing with the Y2K problem

$440 million loss by Knight Capital group Inc. in 30 minutes, August 2012
$650 million loss by NASA Mars missions in 1999; unit conversion bug
$500 million Arian 5 maiden flight in 1996; 64-bit to 16-bit conversion bug
"$Nightmare" billion Boeing 737Max

2011: Software caused 25% of all medical device recalls.
[[}]]

[[{qa.101.checker_fw,qa.error_control,qa.billion_dolar_mistake]]
# Checker framework 

* (Java 8+)
* fix errors at compile time  (vs later on at execution/runtime)
  * <https://github.com/typetools/checker-framework>
  * <https://checkerframework.org/manual/>
  * <https://www.youtube.com/watch?v=6E1CSydgzQc>
  * <https://www.baeldung.com/checker-framework>

* COMPARED TO ALTERNATIVES (SpotBugs, Infer  Jlint, PMD,...)
  ```
  |                ┌─────────────┬────────┬────────┐                 ┌──────────────────┬─────────────────────┐
  |                │ Null Pointer│        │        │                 │ Verification     │ Bug─Finding         │
  |                │    errors   │ False  │Annotat.│                 │ ( Checker FW ,)  │ (Infer,StopBugs,    │
  |                │             │        │        │                 │                  │  SonarQube,...      │
  |                │Found│ Missed│warnings│written │  ┌──────────────┼──────────────────┼─────────────────────┤
  | ┌──────────────┼─────┼───────┼────────┼────────┤  │Goal          │ prove that       │ find some bugs      │
  | │ Checker FW.  │9    │ 9     │  4     │  35    │  │              │ no bug exits     │ at "low cost"       │
  | ├──────────────┼─────┼───────┼────────┼────────┤  ├──────────────┼──────────────────┼─────────────────────┤
  | │StopBugs      │0    │ 9     │  1     │  0     │  │Check specifis│ user provided    │ infer likely specs  │
  | ├──────────────┼─────┼───────┼────────┼────────┤  │specificat    │                  │                     │
  | │Jlint         │0    │ 9     │  8     │  0     │  ├──────────────┼──────────────────┼─────────────────────┤
  | ├──────────────┼─────┼───────┼────────┼────────┤  │False         │ None!!!          │ acceptable          │
  | │PMD           │0    │ 9     │  0     │  0     │  │negatives     │                  │                     │
  | ├──────────────┼─────┼───────┼────────┼────────┤  ├──────────────┼──────────────────┼─────────────────────┤
  | │Eclipse 2017  │0    │ 9     │  8     │  0     │  │False         │ manually supress │ heuristics focus on │
  | ├──────────────┼─────┼───────┼────────┼────────┤  │positives     │ warnings         │ most important bugs │
  | │IntelliJ      │0    │ 9     │  1     │  0     │  ├──────────────┼──────────────────┼─────────────────────┤
  | │+@NotNull 2017│3    │ 6     │  1     │ 925+8  │  │Downside      │ user burden      │ missed bugs         │
  | └──────────────┴─────┴───────┴────────┴────────┘  └──────────────┴──────────────────┴─────────────────────┘
  ```

* **PROBLEM**: STANDARD JAVA TYPE SYSTEM IS NOT GOOD ENOUGH  
  Next examples compile properly, but fail at runtime:
  ```
  | System.console().readLine()       ; <·· Ex.1 NullPointer
  |
  | Collections.emptyList().add("one"); <·· Ex.2 Unsupported Operation
  |
  | Date key1 = new Date();             <·· Ex.3
  | myMap.put(key1, "now");
  | myMap.get(key1);                        <··  returns "now"
  | key1.setSeconds(0);                     <··  Mutate key
  | myMap.get(key1);                        <··  returns null
  ```
  **SOLUTION**:
   Java 8+ allows to compile programs using "PLUGGABLE TYPE SYSTEMs" ,
   allowing to apply stricter checks than default ones in compiler like
   Ex:
   ```
   $ javac  -processor NullnessChecker  MyFile.java
   ```

* PLUGABLE TYPE SYSTEM COMPILATION SCHEMA:
  ```
  |       (1)           No errors ²
  |Source ···> Compiler ·(No error ·····┬···> Executable
  |  ^            │       detected      ·²         ^
  |  ·            v                     v          ·
  |  ·         Standard               Optional     · Guaranteed
  |  ·         Compiler               Type      ···┘ Behaviour
  |  ·         Errors                 Checker
  |  ·                                  ·
  |  ·                                  v
  |  └·················· Warnings ······┘

  |  ² plugable type system allows generation
  |    of executable to allow CI continue the
  |    pipeline with further tests (functional
  |    testing, configuration testing, ...)
  ```

## Instalation <!-- { -->
1. Check new releases/versions at
   <https://search.maven.org/search?q=g:org.checkerframework>

1. Add next pom.xml dependencies like:
   ```
   | <dependency>
   |     <groupId>org.checkerframework</groupId>
   |     <artifactId>checker-qual</artifactId>
   |     <version>2.11.0</version>
   | </dependency>
   | <dependency>
   |     <groupId>org.checkerframework</groupId>
   |     <artifactId>checker</artifactId>
   |     <version>2.11.0</version>
   | </dependency>
   | <dependency>
   |     <groupId>org.checkerframework</groupId>
   |     <artifactId>jdk8</artifactId>
   |     <version>2.11.0</version>
   | </dependency>
   ```
1. tweak maven-compiler-plugin to use Checker Framework
   as a pluggable Type System:
   ```
   | <plugin>
   |   <artifactId> maven-compiler-plugin </artifactId>
   |   <version>3.6.1</version>
   |   <configuration>
   |     <source>1.8</source>
   |     <target>1.8</target>
   |     <compilerArguments>
   |       <Xmaxerrs>10000</Xmaxerrs>
   |       <Xmaxwarns>10000</Xmaxwarns>
   |     </compilerArguments>
   |     <annotationProcessors>                            <······ "==" javac -processor ...
   |       <annotationProcessor>
   |          org.checkerframework.checker.nullness.NullnessChecker
   |        </annotationProcessor>
   |        <annotationProcessor>
   |          org.checkerframework.checker.interning.InterningChecker
   |        </annotationProcessor>
   |        <annotationProcessor>
   |          org.checkerframework.checker.fenum.FenumChecker
   |        </annotationProcessor>
   |        <annotationProcessor>
   |          org.checkerframework.checker.formatter.FormatterChecker
   |        </annotationProcessor>
   |     </annotationProcessors>
   |     <compilerArgs>
   |       <arg>-AprintErrorStack</arg>
   |       <arg>-Awarns</arg>
   |     </compilerArgs>
   |   </configuration>
   | </plugin>
   ```

1. Manually add extended type annotations in real Java code
<!-- } -->

## Daily Ussage [[{]]

* Avoiding Nulls:
  ```
  | private static int func1 (
  |    @RequiresNonNull  String[] args  // <·· func. preconditions.
  | ) {
  |     @EnsuresNonNull final result;   // <·· func. post-condition. variable is guaranteed
  |     result = args.length;           //     to be non-null on return. 
  |     return result;                  //     Also: @EnsuresNonNullIf: variables is guaranteed 
  |                                     //     to be non─null on ret.true/false  
  | }
  |
  | public static void main
  |   ( @Nullable  String[] args) {
  |     ...
  |     func1(args);  //                 // <·· [WARNING] ... [argument.type.incompatible]
  | }                                    //     incompatible types in argument.
  |                                      //     found    : null
  |                                      //     required : @Initialized @NonNull ...
  |
  | static final
  |    @Fenum("country") String ITALY = "IT",         // <·· Safe "country" string.
  |    @Fenum("country") String US    = "US",
  |    ...
  |    @Fenum("planet" ) String MARS   = "Mars",      // <·· Safe "planet" string.
  |    @Fenum("planet" ) String EARTH   = "Earth";
  | ...
  |
  | void function1(                      // <·· Function expected "planet" string
  |   @Fenum("planet") String inputPlanet){
  |     System.out.println("Hello " + planet);
  | }
  |
  | public static void main(String[] args) {
  |     obj.greetPlanets(US);            // <·· [WARNING] ... incompatible types in argument.
  | }                                    //      found   : @Fenum("country") String
  |                                      //      required: @Fenum("planet")  String
  |
  |
  | @Regex(1) static                     // <·· Force regext string with at least one matching group
  |     String FIND_NUMBERS = "\\d*";    //     <·· [WARNING] ... incompatible types in assignment.
  |                                      //         found   : @Regex String
  |                                      //         required: @Regex(1) String
  |
  |  @Untainted String                   // <·· Validating tainted (non-trusted) input
  |  validate (String sqlInput) {
  |     // ... Do any suitable checks
  |     //     OR THROW ON ERROR
  |     @SuppressWarnings("tainting")    //     <·· "swear" that developer got sure
  |     @Untainted String result = ...;  //          of input correctness
  |     return result;
  | }
  |
  | void execSQL(@Untainted  String sqlInput) {
  |     ...
  | }
  |
  | public static void main(String[] args) {
  |     obj.execSQL(arg[0]);             //  <··  warning at compile time
  |     obj.execSQL(validate(arg[0]));   //  <·· "OK". validate un-tain the input
  | }
  |
  | @Immutable Date date = new Date();   //  <·· Mark as real immutable (vs weak "final")
  | date.setSeconds(0);                  //  <·· compile-time error
  ```
[[}]]

## Avoiding (certain) concurrency errors [[{]]
  Lock Checker enforces a locking discipline:
  "which locks must be held when a given operation occurs"

  ```
  | CHECKS ON TYPES                             │ CHECKS ON FUNCTION DECLARATION
  |                                             │                 ┌────┬────┬───────────────────────────┐
  |  @GuardedBy("lockexpr1","lockexpr2",...)    │                 │FUNC│FUNC│DESCRIPTION                │
  |            int var1 = ....;                 │                 │PRE─│POST│                           │
  |  ^^^^^^^^^^                                 │                 │COND│COND│                           │
  | a thread may dereference the value referred │┌────────────────┼────┼────┼───────────────────────────┤
  | to by var1 only when the thread holds all   ││@Holding        │X   │    │All the given lock exprs   │
  | the locks that ["lockexpr1",...] currently  ││(String[] locks)│    │    │are held at method call    │
  | evaluates to.                               │├────────────────┼────┼────┼───────────────────────────┤
  |                                             ││@EnsuresLockHeld│    │X   │Ensures locks are locked on│
  |                                             ││(String[] locks)│    │    │return,ex. lock adquired by│
  |                                             ││                │    │    │ReentrantLock.lock().      │
  |                                             │├────────────────┼────┼────┼───────────────────────────┤
  |                                             ││@EnsuresLockHeld│    │X   │Ensures locks are locked on│
  |                                             ││(String[] locks)│    │    │return,ex.lock conditionaly│
  |                                             ││                │    │    │adquired by ReentrantLock  │
  |                                             ││                │    │    │.lock()                    │
  |                                             ││                │    │    │if method return true|false│
  |                                             │└────────────────┴────┴────┴───────────────────────────┘
  ```
  
  ```
  | SIDE EFFECT SPECIFICATIONS
  | ┌────────────────────┬───────────────────────────────────────────────┐
  | │ @LockingFree       │method does NOT acquire│release locks:         │
  | │                    │· it is not synchronized,                      │
  | │                    │· it contains NO synchronized blocks           │
  | │                    │· it contains no calls to lock│unlock methods  │
  | │                    │· it contains no calls to methods that are not │
  | │                    │  themselves @LockingFree                      │
  | │                    │(@SideEffectFree implies @LockingFree)         │
  | ├────────────────────┼───────────────────────────────────────────────┤
  | │ @ReleasesNoLocks   │· method maintains a strictly                  │
  | │                    │  nondecreasing lock hold count                │
  | │                    │  on the current thread for any locks          │
  | │                    │  held at method call.                         │
  | ├────────────────────┼───────────────────────────────────────────────┤
  | │ @EnsuresLockHeld   │method adquires new locsk                      │
  | │ @EnsuresLockHeldIf │(default if no @LockingFree│@MayReleaseLocks│  │
  | │                    │@SideEffectFree│@Pure used).                   │
  | └────────────────────┴───────────────────────────────────────────────┘
  ```
[[}]]

## Format String Checker
* prevents use of incorrect format strings in System.out.printf,....
  ```
  | void printFloatAndInt
  |      ( @Format({FLOAT, INT})  String   format )
  | {
  |   System.out.printf(  format , 3.1415, 42);
  | }
  ```
* I18n Format Checker examples
  ```
  | MessageFormat.format("{0} {1}", 3.1415);
  |                                       ^
  |                             second argument missing
  | MessageFormat.format("{0, time}", "my string");
  |                                   ^^^^^^^^^^^
  |                                   cannot be formatted
  |                                   as Time type.
  | MessageFormat.format("{0, thyme}", new Date());
  |                           ^^^^^
  |                           unknown format type
  |
  | MessageFormat.format("{0, number, #.#.#}", 3.1415);
  |                                   ^^^^^
  |                             subformat is invalid.
  ```

## Property File Checker!!!!  [[{PM.TODO]]
* It ensures that used keys are found in the corresponding
  property file or resource bundle.
[[}]]  

## GUI Effect Checker
* It is difficult for a programmer to remember
  which methods may be called on which thread(s).
  (Main GUI thread or others)
  Checker types the method as if:
  * It accesses no UI elements (and may run on any thread);
  * It may access UI elements  (and must run on the UI thread)

## (physical) Internation System UNIT annotations :
  ```
  | @Acceleration: Meter Per Second Square @mPERs2
  | @Angle       : Radians @radians
  |                Degrees @degrees
  | @Area        : square millimeters @mm2,
  |                square meters @m2
  |                square kilometers @km2
  | @Current     : Ampere @A
  | @Length      : Meters @m
  |                millimeters @mm
  |                kilometers @km
  | @Luminance   : Candela @cd
  | @Mass        : kilograms @kg
  |                    grams @g
  | @Speed       : meters per second   @m
  |                kilometers per hour @kmPERh
  | @Substance   : Mole @mol
  | @Temperature : Kelvin @K
  |                Celsius @C
  | @Time        : seconds @s
  |                minutes @min
  |                hours @h
  ```

## @Unsigned/@Signed
* guarantees values are not mixed

## type alias or typedef
* share same representation as another type
  but is conceptually distinct from it.
  ```
  | Ex 1: get sure that Strings representing addresses
  |       and passwords are NOT mixed
  | Ex 2: get sure that integers used for meters are
  |       not mixed with integers used for centimeters.
  ```
* Example:
  ```
  | @NonNull List<String>
  | List<@NonNull String>
  | @Regex String validation = "(Java|JDK) [7,8]"
  |
  | private String getInput(String parameterName){
  |  final String retval = @Tainted request.getParameter(parameterName);
  |  return retval;
  | }
  |
  | private void runCommand(@Untainted String… commands){
  |  // the previously tainted String must be validated before being passed in here.
  |  ProcessBuilder processBuilder = new ProcessBuilder(command);
  |  Process process = processBuilder.start();
  | }
  ```
[[qa.101.checker_fw}]]

[[{qa.101.spotbugs]]
# SpotBugs
@[https://github.com/spotbugs/spotbugs/issues]
* OOSS static analysis tool for java code bugs.
* Well maintained (as of 2021-12-21)
* "spiritual successor of FindBugs"
* SpotBugs checks for more than 400 bug patterns.
* Works from GUI+cli, maven/gradle/eclipse integration.
* Plugin extension support (just download plugin jar and
  it will be detected and included):
  • fb-contrib:
  • Security Audits for Java Web applications:
  @[https://find-sec-bugs.github.io/]
    It can detect 141 different vulnerability types with
    over 823 unique API signatures.
* When compared with SonarCube, SpotBugs emmits fewer false
  possitives.

## Running SpotBugs
* Presetup. Compile java code to classes or jars.
  **SpotBugs runs against compiles class files, using source code
  as a reference when displaying output.**
  ```
  | $ java -jar ../spotbugs.jar ...$SPOTBUG_ OPTIONS ..
  |
  |                            JVM OPTIONS
  |                            ===========
  | -Xmx1500m                ← set JVM heap to big/1500MB  (recomended)
  |
  |                            STANDARD OPTIONS
  |                            ================
  | -textui                  ← vs -gui
  | -effort min              ← := min|less|default|more|max
  |                            min: decrease mem use/precision/exec.time
  |                            max: increase mem use/precision/exec.time
  | -project ... \           ← project *.fb or *.fbp created through the GUI
  |                            (fb == FindBugs)
  | -pluginList jar1;jar2     \
  | -home $SPOTBUG_DIR       ← ex: /opt/spotbugs
  | -adjustExperimental      ← Lower priority of experimental Bug Patterns.
  | -workHard                ← Ensure analysis effort is at least ‘default’.
  | -sortByClass=dir1/spotbugs.txt ← textui only
  |                                  also supported to set multiple reports
  | -include filter01.xml     ← show only bugs match filter specified.
  | -exclude filter02.xml     ← *1
  | -onlyAnalyze com.foo.*,com.bar.* ← Unlike filter, analysis is skipt
  |                             for any other class type
  |                             WARN: some detectors may produce inaccurate
  |                             results
  | -low                      ← Report all bugs.
  | -medium                   ← Report medium and high priority bugs.
  | -high                     ← Report only high priority bugs.
  | -relaxed                  ← suppress heuristics, avoidin false positives.
  | -html=../report.html      ← Output HTML. Alternative:
  |                           ← Output HTML. Alternative:
  |                             NOTE : It is -html=value while other flags work like
  |                                    -flag value (without the "=" sign)
  |                             -html:fancy.xsl=...  (DOM+JS for navigation + CSS)
  |                             -html:fancy-hist.xsl=...  fancy.xsl evolution
  |                             Other output formats include xml/sarif/emacs/xdocs
  | -nested false             ← disable scanning of nested jar (def:enabled)
  | -auxclasspath ...         ← It should include all jar/dirs containing classes
  |                             that are part of the program being analyzed but
  |                             you do not want to have analyzed for bugs.
  | -auxclasspathFromInput    ← Read auxclasspath from STDIN, line by line
  | -auxclasspathFromFile
  | -analyzeFromFile fileI    ← Read input file list from file line-by-line.
  | -showPlugins              ← listavailable detector plugins.
  |
  |                             OUTPUT CUSTOMIZATION OPTIONS
  |                             ============================
  | -timestampNow             ← Set results timestamp to current time.
  | -quiet                    ← Suppress error messages.
  | -longBugCodes             ← Report long bug codes.
  | -progress                 ← Display progress in console.
  | -release $name            ← Set release name in report
  | -maxRank $rank            ← Only report issues with a bug rank at least
  |                             as scary as that provided.
  | -dontCombineWarnings      ← Don’t combine warnings differing only in line num.
  | -train[:outputDir]:       ← Save training data (experimental);
  | -useTraining[:inputDir]:  ← Use training data (experimental);
  | -redoAnalysis $filenam    ← Redo using config. from previous analysis.
  | -sourceInfo $file         ← Specify source info file (line numbers for
  |                             fields/classes).
  | -projectName $name        ← Descriptive name of project.
  | -reanalyze $filename      ← Redo analysis in provided file.
  |
  |                             OUTPUT FILTERING OPTIONS
  |                             ========================
  | -bugCategories cat1,cat2  ← Only report bugs in those categories.
  | -excludeBugs baseline_bug ← Exclude bugs that are also reported in
  |                             baseline xml output.
  | -applySuppression         ← Exclude bugs matching suppress.filter from *fbp
  |
  |                             DETECTOR (VISITOR) CONFIGURATION OPTIONS
  |                             ========================================
  | -visitors v1,v2,...       ← Run only named visitors.
  | -omitVisitors v1,v2,...   ← Omit named visitors.
  | -chooseVisitors +v1,-v2,. ← enable/disable detectors.
  | -choosePlugins +p1,-p2,   ← Selectively en/dis-able plugins.
  | -adjustPriority v1=raise|lower,v2=...
  |
  |                             PROJECT CONFIGURATION OPTIONS
  |                             =============================
  | -sourcepath $source_path  ← Set source path for analyzed classes.
  | -exitcode                 ← Set exit code of process.
  | -noClassOk                ← Output empty warning file if no classes are
  |                             specified.
  | -xargs                    ← Get list of class/jar files from STDIN
  | -bugReporters name,-name2,.. ← Bug-reporter decorators to explicitly
  |                                enable/disable.
  | -printConfiguration       ← Print configuration and exit
  |
  |*1┌── myIncludeOrExcludeFilter.xml ────
  |  │
  |  │ <?xml version="1.0" encoding="UTF-8"?>
  |  │ <FindBugsFilter>
  |  │ <Match>
  |  │   <Bug                       match if  pattern and/or code and/or category match
  |  │     pattern="..."          ← comma-separated list of patterns to match
  |  │                              ex.: DLS_DEAD_LOCAL_STORE,DM_EXIT,
  |  │     code="..."             ← coarse-grained matching comma-sep. list of bug
  |  │                              abbreviations(DC,DE,IC,IJU,MS,SIC,URF,UUF,XYZ,...)
  |  │     category="..."         ← even more coarse-grained :=
  |  │                              CORRECTNESS, BAD_PRACTICICE,
  |  │   />                         PERFORMANCE, STYLE, MT_CORRECTNESS
  |  │                                 (M)ulti(T)hreaded ┘
  |  │
  |  │
  |  │   <Confidence value="1"/>  ← 1 match high-confidence warnings,
  |  │                              2 match normal-confidence warnings
  |  │                              3 match low-confidence warnings
  |  │
  |  │    <Rank value="1" />     ←  1  to 4 : scariest
  |  │                              5  to 9 : scary
  |  │                             10 to 14: troubling
  |  │                             15 to 20: concern
  |  │
  |  │   <Package name="~.."/> ← name/regex. Nested packages are NOT included
  |  │   <Class   name="~.. /> ← name/regex. NOTE: Some bug instances relate to
  |  │                                       2+ classes.
  |  │   <Source  name="..."/> ← name/regex.  match warnings associated to source file.
  |  │                           └────┬────┘
  |  │                         regex if prefixed by ~
  |  │
  |  │   <Method
  |  │    name="funcXXX"
  |  │    params="int,..."
  |  │    returns="void"
  |  │   />
  |  │
  |  │   <Field name="..." />   ← type=... instead of name can also be used
  |  │   <Local name="..." />
  |  │   <Type  name="..." />
  |  │ </Match>
  |  │
  |  │ <Or>  <Match /><Match /></Or>
  |  │ <And> <Match /><Match /></And>
  |  │ <Not> <Match />         </Not>
  |  │
  |  │ </FindBugsFilter>
  |  └────────────────────────────────────────────
  ```
[[qa.101.spotbugs}]]


[[{qa.101.error_prone,PM.TODO]]
# Error Prone 
* <https://www.baeldung.com/java-error-prone-library?__s=aw56zebktqtoti1yt59p>

* It hooks directly into the javac compiler.

* Compared to SpotBugs [[{doc_has.comparative]]
> I've used Error Prone for more than two years in a Spring Boot 
> project. I run Spring Boot in debug mode with class reloading all day 
> long. I like that it runs during compilation, so it's immediate 
> feedback during development without having to stop. And whatever 
> changes I make, I then test immediately.
> Running PMD & SpotBugs is a separate build goal for me as part of 
> the release process and the continuous integration. That's delayed 
> feedback.
[[doc_has.comparative}]]

[[qa.101.error_prone}]]

[[{qa.101.PMD,PM.TODO]]
# PMD
* <https://pmd.github.io/>
* It detects errors in Java but also in Maven pom.xml files, JavaScript,
Salesforce.com Apex and Visualforce, PLSQL, Apache Velocity, XML and XSL.

* It includes CPD, the **copy-paste-detector to finds duplicated code** in
  Java, C, C++, C#, Groovy, PHP, Ruby, Fortran, JavaScript, PLSQL,
  Apache Velocity, Scala, Objective C, Matlab, Python, Go, Swift and
  Salesforce.com Apex and Visualforce.
[[qa.101.PMD}]]

[[{qa.101.sonarlint,01_PM.low_code,]]
# SonarLint 
* Provides automatic feedback (vs late one at CI/CD as SonarQube does)
[[qa.101.sonarlint,01_PM.low_code}]]
* Integrates as Eclipse plugin.

[[{qa.101.snarqube,01_PM.low_code,]]
[[concurrency.101,JAVA_LANG.DEBUGGING]]
[[scalability.profiling,01_PM.WiP]]
# SonarQube
* SonarQube empowers all developers to write cleaner and safer code.
* Comunity with 200K+ dev. teams.
* Easely integrates with CI/CD pipelines.
  Jenkins, GitHub Actions, Bitbucket Pipelines, GitLab CI, Azure Pipelines, ...

* A simple client/server working enviroment can be setup in minutes like:

## Running SonarQube:

1. Launch SonarQube Server:
  ```
  | $ docker run -d --name sonarqube               \
  |   -e SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true    \
  |   -v $(pwd)/sonarqube_data:/opt/sonarqube/data \
  |   -p 9000:9000 sonarqube:latest
  ```
2. Create a new project through the web console
   and annotate the 40-random-chars TOKEN.
   (Needed by client-side sonar-scanner).

3. "CLIENT SIDE"
  * Setup `${PROJECT_SRC_ROOT}/sonar-project.properties`
  ```
  | sonar-project.properties 
  | sonar.projectKey=my:project  ← Required
  | 
  | #sonar.projectName=...       ← def:project key
  | #sonar.projectVersion=1.0    ← def:'not provided'
  | sonar.sources=src/java/      ← relative to
  |                                sonar-project.properties
  | #sonar.sourceEncoding=UTF-8
  | sonar.java.binaries=./build/ ← compiled *class dir.
  | sonar.java.libraries=...     ← ex: /lib/*.jar,./plugins/lib/*jar
  ```
  * launch client scanner like:
  ```
  | $ mvn clean verify sonar:sonar \        <· alt1) using mvn plugin
  |     -Dsonar.projectKey=test2 \
  |     -Dsonar.host.url=http://...:9000 \
  |     -Dsonar.login=$PROJECT_TOKEN
  | 
  | $ docker run \                          <· alt2) using docker
  |   --rm \
  |   -e SONAR_HOST_URL="http:...:9000" \
  |   -e SONAR_LOGIN="$PROJECT_TOKEN" \
  |   -v "${YOUR_REPO}:/usr/src" \
  |   sonarsource/sonar-scanner-cli
  ```

* See original source for more info about SonarScanner Troubleshooting
  recipes, advanced docker config, running, caching scanner files,
  usng self-signed certs:
  @[https://docs.sonarqube.org/latest/analysis/scan/sonarscanner/]
  *1: not needed if the associated project is already linked to a
      git repository on the server side.

[[qa.101.snarqube}]]

# JavaDoc [[{qa.101.javadoc,qa.documentation]]

Example:
  ```
  | /**
  |  * Short one line description.
  |  * <p>
  |  * Longer description. ...
  |  * ...here.
  |  * <p>
  |  * And even more explanations to follow
  |  * in consecutive paragraphs
  |  *                                           Applies to:
  |  * @author John Bla                          Class, Interface, Enum
  |  * @param  varname Description ....                                         Method
  |  * @return description                                                      Method
  |  * @version  1.2.3                           Class, Interface, Enum (Max: 1 per Class|Interface)
  |  * @since  1.1.1                             Class, Interface, Enum, Field, Method
  |  * @seereference  link_to_another_element    Class, Interface, Enum, Field, Method
  |  * @exceptionclass desc                                                     Method
  |  * @throwsclass desc                                                        Method
  |  * @deprecated description_of_outdated Elem. Class, Interface, Enum, Field, Method
  |  * {@inheritDoc}     Copies desc. from parent
  |  * {@linkreference}  Link to other symbol    Class, Interface, Enum, Field, Method
  |  * {@value#STATIC_FIELD}  Return the value of static field.                         Static Field
  |  * {@codeliteral}    (Formats literal text   Class, Interface, Enum, Field, Method
  |  *                  in the code font. It is
  |  *                  equivalent to  {@literal}
  |  * {@literalliteral} Denotes literal text.                           Field, Method
  |  *                   The enclosed text is interpreted as not
  |  *                   containing HTML markup or nested javadoc tags.
  |  *
  |  */
  | public int methodName (...) {
  |     // method body with a return statement
  | }
  ```
[[qa.101.javadoc}]]

# Junit [[{qa.junit.101,qa.101,02_doc_has.comparative,01_PM.WiP]] @[testing_summary]

* Junit 5 is the sum of next modules:
  ```
  |+ JUnit Platform <··* == "core" to launch testing frameworks on the JVM.
  |                       + TestEngine API (dev new testing frameworks)
  |                       + Console Launcher
  |                       + JUnit Platform Suite Engine
  |                         (run custom test suite using 1+ test engines)
  |                    * 1st class support in IDEs,Gradle/Maven
  |+ JUnit Jupiter <·· * "combination of"
  |                      1. programming model and
  |                      2. extension model
  |                      (for writing tests&extensions)
  |                    * It provides a `TestEngine` for running Jupiter
  |                      based tests on the platform.
  |+ JUnit Vintage <·· TestEngine to JUnit 3/4 based tests.
  |                    Depends on JUnit 4.12+
  ```
* Junit (maven/gradle TEST scoped) dependencies:
  ```
  | org.junit.jupiter:junit-jupiter-api:${junit_version}
  | //                └───────────────┴─ org.junit.jupiter.api package (@ junit-jupiter-api module)
  | //                contains the standard annotations for testing (@Test/@Before/...)
  | org.junit.jupiter:junit-jupiter-engine:${junit_version}
  ```

## Test life cycle:

* Default behaviour: JUnit creates a new instance of each test class before executing each test method
  "completely" isolating each test.
  **WARN**: Do not use heavy/slow constructors.

* Use `@TestInstance(Lifecycle.PER_CLASS)` to execute all methods on the same instance.
  In that case use @BeforeEach or @AfterEach methods to reset state after each test.
  @BeforeAll and @AfterAll can be used in this case.
  * Java 16+: @BeforeAll, @AfterAll can be declared as static in @Nested test classes.


## Documented test: <!-- { -->
  ```
  | import static org.junit.jupiter.api.Assertions.fail;
  | import static org.junit.jupiter.api.Assertions.assertAll;
  | import static org.junit.jupiter.api.Assertions.assertEquals;
  | import static org.junit.jupiter.api.Assertions.assertNotNull;
  | import static org.junit.jupiter.api.Assertions.assertThrows;
  | import static org.junit.jupiter.api.Assertions.assertTimeout;
  | import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
  | import static org.junit.jupiter.api.Assertions.assertTrue;
  |
  |
  | import static org.junit.jupiter.api.Assumptions.assumeTrue;
  | import static org.junit.jupiter.api.Assertions.assertEquals;
  | import static org.junit.jupiter.api.Assumptions.assumeTrue;
  | import static org.junit.jupiter.api.Assumptions.assumingThat;
  |
  | import org.junit.jupiter.api.AfterAll;
  | import org.junit.jupiter.api.AfterEach;
  | import org.junit.jupiter.api.BeforeAll;
  | import org.junit.jupiter.api.BeforeEach;
  | import org.junit.jupiter.api.Disabled;
  | import org.junit.jupiter.api.Test; // JUnit 5 (vs  org.junit.Test for JUnit <v5)
  | import static org.junit.jupiter.api.Assertions.assertEquals;
  |
  | .10.2. Class Order
  |
  | import org.junit.jupiter.api.Order;                        // Useful for integration & functional tests!!!
  | import org.junit.jupiter.api.TestMethodOrder;              // NOTE: Unit tests must not depend on the order
  |/import org.junit.jupiter.api.ClassOrderer;                 // <·· order can also be applied to full classes
  | import org.junit.jupiter.api.MethodOrderer.DisplayName    : sorts alphanumerically by display name
  | import org.junit.jupiter.api.MethodOrderer.MethodName     : sorts alphanumerically by method name (and formal param list)
  | import org.junit.jupiter.api.MethodOrderer.OrderAnnotation: sorts numerically      by @Order annotation
  | import org.junit.jupiter.api.MethodOrderer.Random         : sorts pseudo-randomly
  |                                            └────┬────────┘
  | @TestMethodOrder(                               ·
  |    OrderAnnotation.class ) <··· (one of )······─┘
  | @DisplayName("😱Display name Class Level")       // custom display name in test runners/reports/IDEs.
  | @DisplayNameGeneration(ReplaceCamelCase.class)
  | class JUnitAPISummaryTest {
  |   //                       // testing Life-Cycle methods:
  |
  |
  |   @BeforeAll          // <·· executes before all tests.          == @BeforeClass in JUnit 4
  |   static void initAll() {
  |   }
  |   @BeforeAll
  |   void tearUp{ ... }
  |   @AfterAll   { ... } // <·· executes after  all tests.          == @AfterClass  in JUnit 4
  |   static void tearDownAll() { }
  |   @BeforeEach         // <·· executed before each @Test in class == @Before      in JUnit 4
  |   @Timeout(           // <·· fail-fast) if execution time exceeds 5 seconds at setup
  |     threadMode = ThreadMode.SEPARATE_THREAD // optional INFERRED*|SAME_THREAD|SEPARATE_THREAD
  |     value = 500,                            // Use -Djunit.jupiter.execution.timeout.default=... for def.value
  |     unit = TimeUnit.MILLISECONDS)           // fine grained config exists for test,factory,lifecycle,beforeall,...
  |   void init() { ... }
  |   @AfterEach  { ... } // <·· executed after  each @Test in class == @After       in JUnit 4
  |   void tearDown() { }                             └─┬─┘
  |                                 (or @RepeatedTest @ParameterizedTest, @TestFactory)
  |
  |   @Test
  |   @Order(1)
  |   void failingTest() {
  |       assertEquals(2, calculator.add(1, 1));
  |       assertEquals(4, calculator.multiply(2, 2),
  |               "The optional failure message is now the last parameter");
  |       assertTrue('a' < 'b', () -> "Assertion messages can be lazily evaluated -- "
  |               + "to avoid constructing complex messages unnecessarily.");
  |       assertAll("person",
  |           () -> assertEquals("Jane", person.getFirstName()),
  |           () -> assertEquals("Doe", person.getLastName())
  |       assertAll("properties",
  |           () -> {
  |               final String firstName = person.getFirstName();
  |               assertNotNull(firstName);
  |               assertAll("first name",
  |                   () -> assertTrue(firstName.startsWith("J")),
  |                   () -> assertTrue(firstName.endsWith("e"))
  |               );
  |           },
  |           () -> { // Grouped assertion, processed independently of results of 1st name assertions
  |               String lastName = person.getLastName();  // ...
  |           }
  |       );
  |
  |       Exception exception = assertThrows(ArithmeticException.class, () -> calculator.divide(1, 0));
  |       assertEquals("/ by zero", exception.getMessage());
  |
  |       assertTimeout(ofMinutes(2), () -> { ... }); //  fails if execution time > timeout
  |
  |       String actualResult = assertTimeout(ofMinutes(2), () -> { return "result01"; });
  |       assertEquals("result01", actualResult);
  |
  |       assertTimeoutPreemptively(ofMillis(10), () -> { // like assertTimeout but executes
  |           new CountDownLatch(1).await();              // in different thread. "execution timed out after 10 ms"
  |       });
  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |       NOTE: Specifically, Spring’s testing support binds
  |       transaction state to the current thread (via a ThreadLocal)
  |       any actions taken by Spring components in assertTimeoutPreemptively()
  |       will not be rolled back with the test-managed transaction.
  |        Such actions will be committed to the persistent store
  |       even though the test-managed transaction is rolled back.
  |
  |
  |       assumeTrue("abc".contains("Z")); // will throw.
  |       assumeTrue( "CI".equals(System.getenv("ENV"))); // TODO:(?) what means assume??
  |           () -> "Aborting test: not on developer workstation");
  |       assumingThat("CI".equals(System.getenv("ENV")),
  |           () -> { // run only on the CI server
  |               assertEquals(2, calculator.divide(4, 2));
  |           });
  |       fail("test should have been aborted");
  |   }
  |
  |
  |   @Nested                       // <··· Nested tests allows for a hierarchical organization of tests
  |   @DisplayName("when new")
  |   class WhenNew { ...  }
  |
  |   @Test
  |   @Order(2)
  |   @DisplayName("Test parameters with nice names")
  |   @ParameterizedTest(name = "Use the value {0} for test")
  |   @ValueSource(insts = { -1, -4 })
  |   void test01( int number ) {            // <·· Test&lifecycle methods MUST NOT be abstract,
  |                                                 neither return a value (except for @TestFactory)
  |                                                 neither be private.
  |     Assumptions.assumeTrue (...);            // ← failed assumption aborts test
  |     Assumptions.assumeFalse(...);            //   Continuing execution will fail.
  |                                              //   Example: Initial state is not expected one
  |
  |                                              // Frequently Used:
  |     Assertions.assertTrue   (param1);        // or assertFalse
  |     Assertions.assertNull   (param1);        // or assertNotNull
  |     Assertions.assertEquals (param1,param2); // or assertNotEquals
  |     Assertions.assertNotSame(param1,param2);
  |     Assertions.fail         ("code must not be reached");
  |
  |     assertAll("check ...",                   //  grouped
  |       () -> assertEquals(..),
  |       () -> assertEquals(..),
  |       () -> assertEquals(..)
  |     );
  |
  |                                              // Collections:
  |     Assertions.assertArrayEquals   (array1, array2, "...");
  |     Assertions.assertIterableEquals(list1, list2);
  |
  |
  |     Assertions.assertTimeout(                // Timeouts:
  |       Duration.ofMillis(100), () -> {
  |         Thread.sleep(50);
  |         return "result";
  |       });
  |
  |     Throwable exception =                    // Assert exception thrown
  |        Assertions.assertThrows(
  |          IllegalArgumentException.class,
  |          () -> {
  |            throw new IllegalArgumentException("...");
  |          });
  |   }
  |
  |
  |   boolean customCondition1() { return true ; }
  |   boolean customCondition2() { return false; }
  |
  | /   ┌ Unlike JUnit 4’s @Test annotation, it does not declare any attributes:
  | /   · JUnit Jupiter test extensions operate based on their own dedicated annotations
  | /   · Such methods are inherited unless they are overridden.
  | / ┌─┴─┐
  |   @Test
  |   @Order(3)
  | / @Disabled("disable until bug #23 is fixed) == @Ignore in JUnit 4
  |   @EnabledIf ("com.mycomp.myprj.mypck.myclass#customCondition1")
  |   // boolean method (and probably static ) ─────────┬─────────┐
  |   @DisabledIf(value = "java.awt.GraphicsEnvironment#isHeadless",
  |       disabledReason = "headless environment")
  |
  |  @Test @Order(4) @EnabledOnOs({ OS.LINUX }) ...
  |  @Test @Order(5) @DisabledIfSystemProperty(named = "ci-server", matches = "true")
  |  @Test @Order(6) @EnabledIfEnvironmentVariable(named = "ENV", matches = "test-env")
  |
  |  @RepeatedTest(
  |     value = 9,
  |     name = "{displayName}-{currentRepetition}/{totalRepetitions}")
  |  void valuesCannotPassTen(RepetitionInfo info) {
  |      ...info.getCurrentRepetition() ...
  |  }
  |
  |  @ParameterizedTest(
  |   name = "Test fruit \"{0}\" with rank {1}")
  |  @CsvSource({
  |          "'string1', 1",         // ← Repeat test with different input
  |          "'string2', 2",
  |          ...
  |  })
  |  void testWithCsvSource(String fruit, int rank) {
  |      assertNotNull(fruit);
  |      assertNotEquals(0, rank);
  |  }
  | }
  ```
<!-- } -->


## Other JUnit annotations <!-- { -->

  ```
  | @TestFactory : mark method as test factory for dynamic tests.
  | @TestTemplate: mark method as template feeded with a number
  |                of `invocation contexts` returned by the
  |                registered providers. # TODO: Complete
  | @TestClassOrder : set `@Nested class` execution order
  | @TestMethodOrder: set `test method`   execution order
  | @TestInstance   : Used to configure instance lifecycle
  | @DisplayNameGeneration: set custom display name generator
  | 
  | 
  | @Nested         : mark class as non-static nested test class.
  |                   WARN: In Java 8-15, @BeforeAll and @AfterAll methods
  |                         cannot be used directly in @Nested class unless
  |                         the "per-class" test instance lifecycle is used.
  |                         In Java 16 they can be declared as static in
  |                         @Nested test class with either test instance lifecycle mode.
  | @Tag: Used to filter-test-by-tag (class|method)
  |       Similar to test groups in TestNG or
  |       Categories in JUnit 4.  Tags name rules:
  |       A tag must not be null or blank.
  |       A trimmed tag must not contain whitespace.
  |       A trimmed tag must not contain ISO control characters.
  |       A trimmed tag must not contain next chars: , ( ) & | !
  | 
  | 
  |       To filter by tags:
  |         <build>
  |           <plugins>
  |             <plugin>                                             Plguin will scan for test classes
  |               <artifactId>maven-surefire-plugin</artifactId> <·· whose fully qualified names match
  |               <version>3.0.0-M7</version>                        the following patterns.
  |                                                                  **/Test*.java  **/*Tests.java
  |                                                                  **/*Test.java  **/*TestCase.java
  |        +      <configuration>
  |        +        <groups>acceptance | !feature-a</groups>
  |        +        <excludedGroups>integration, regression</excludedGroups>
  |        +            <properties>                          <··· -D... flags / properties
  |        +                <configurationParameters>
  |        +                    junit.jupiter.testinstance.lifecycle.default = per_class
  |        +                </configurationParameters>
  |        +            </properties>
  |        +      </configuration>
  |             </plugin>
  |           </plugins>
  |         </build>
  | 
  |       * Tag Expressions:
  |         * boolean expression.
  |         * operators: ! & | ( ... )
  |         * any() : select all tests with tags
  |         * none(): select all tests without tags
  |         * Example: (micro | integration) & (product | shipping)
  | 
  | 
  | @Timeout: fail test,test-factory, test-template or lifecycle method if
  |           execution exceeds timeout.
  | 
  | @ExtendWith: register extensions declaratively. Example:
  |          @ExtendWith(SerenityJUnit5Extension.class)
  | 
  | @RegisterExtension: Register extensions programmatically via fields.
  | 
  | @TempDir: supply temp dir via field|parameter injection in lifecycle|test method.
  |           (org.junit.jupiter.api.io)
  ```
<!-- } -->

## Testsuites: run tests in multiple test classes and/or different packages.
  ```
  |@RunWith(JUnitPlatform.class)
  |@SelectPackages("com.myComp.junit5.package01")
  |public class JUnit5TestSuiteExample
  |{ }
  ```
See also: @[https://www.infoq.com/news/2018/01/VSCodeJunit]

## Dependency Injection for Constructors and Methods [[{]]
* Junit 4: constructors or methods have zero params<br/>
* Junit 5: constructors or methods have zero or more params
           allowing for Dependency Injection.
* Injection Rules:
  1. If constructor, method or lifecycle method accepts a parameter
     the parameter must be resolved at runtime by a registered ParameterResolver.
  2. if constructor or method parameter is of type TestInfo, the TestInfoParameterResolver
     will supply an instance of TestInfo corresponding to the current container or test
     as the value for the parameter.<br/>
     **TestInfo**: provides info about the current container or test (display name,
     test class,method,associated tags,...)
     (drop-in replacement for `TestName` JUnit 4)
     ```
     | TestInfoDemo(TestInfo testInfo) {
     |     assertEquals("TestInfo Demo", testInfo.getDisplayName());
     | }
     ```
 3. In a @RepeatedTest, @BeforeEach, or @AfterEach method there is a parameter
    of type RepetitionInfo, the RepetitionInfoParameterResolver will inject
    an instance that can be used to retrieve total number of repetitions.
 4. If parameter is of type TestReporter, the TestReporterParameterResolver will
    inject an instancte that can  be used to publish additional data about the
    current test run.
 5. Other parameter resolvers must be explicitly enabled by registering appropriate
    extensions via @ExtendWith.
[[}]]

## Parameterized Tests [[{]]
  ```
  | @ParameterizedTest // <··························· Each parameterized test needs a
  | @NullSource : provides a single null argument   // <·· test null inputs
  | @EmptySource: provides a single empty argument  // <·· test empty imputs
  | @ValueSource( strings = { "racecar", "radar" }) // <·· value source
  |                                                 // Set autoCloseArguments to false
  |                                                 // to false to avoid autoclossing
  |                                                 // params after each test if needed .
  | @MethodSource("someMethodProvidindStrings")     // <·· example:
  | void palindromes(String candidate) {                   static Stream<String> stringProvider() {
  |     assertTrue(StringUtils.isPalindrome(candidate));       return Stream.of("...", ...);
  | }                                                      }
  | 
  | 
  | // Enum params
  | @ParameterizedTest
  | @EnumSource(ChronoUnit.class)
  | @EnumSource(names = { "DAYS", "HOURS" })
  | @EnumSource(mode = EXCLUDE, names = { "ERAS", "FOREVER" })
  | @EnumSource(mode = MATCH_ALL, names = "^.*DAYS$")
  | void testWithEnumSourceInclude(ChronoUnit unit) {
  |     assertTrue(EnumSet.of(ChronoUnit.DAYS, ChronoUnit.HOURS).contains(unit));
  | }
  | 
  | // Multi-argument examples
  | static Stream<Arguments> stringIntAndListProvider() {
  |    return Stream.of(
  |        arguments("apple", 1, Arrays.asList("a", "b")),
  |        ...);
  | }
  | 
  | @ParameterizedTest
  | @MethodSource("stringIntAndListProvider")
  | void multiArgumentTest(String str, int num, List<String> list) {
  |     ...
  | }
  | 
  | @ParameterizedTest
  | @CsvSource({
  |      "apple,         1",
  |      "banana,        2",
  |      "'lemon, lime', 0xF1",
  |      "NIL,           700_000"
  |    },
  |    nullValues = "NIL"
  |    ignoreLeadingAndTrailingWhitespace = true,
  | // textBlock = """        <··· Java 15+
  | //   apple,         1
  | //   NILL,    700_000
  | //   ... """
  | )
  | @CsvFileSource(resources = "/two-column.csv", numLinesToSkip = 1)
  | void test(String fruit, int rank) { ...  }
  ```
[[}]]

## Console Launcher (junit-platform-console-standalone-x.x.x.jar)
  ```
  |$ java -jar junit-platform-console-standalone-1.9.3.jar  # alt 1.
  |$ java -cp classes:testlib/*                             # alt 2.
  |     org.junit.platform.console.ConsoleLauncher
  ```

## Listeners [[{]]
* APIs allowing JUnit, third parties, and custom code to react to events fired at
  various points during the discovery and execution of a TestPlan.
* LauncherSessionListener: receives events when a LauncherSession is opened and closed.
* LauncherDiscoveryListener: receives events that occur during test discovery.
* TestExecutionListener: receives events that occur during test execution.
[[}]]

## Test Suite [[{PM.TODO]]
[[}]]


[[qa.junit.101}]]

## AssertJ (Fluent Assertions) [[{01_PM.TODO,qa.junit.assertj]]
* composed of several modules: 
  ```
  | MODULE 
  | - core      assertions for JDK types (String, Iterable, Stream, Path, File, Map...)
  | - core      assertions for JDK types (String, Iterable, Stream, Path, File, Map...)
  | - Guava     assertions for Guava types (Multimap, Optional...)
  | - Joda Time assertions for Joda Time types (DateTime, LocalDateTime)
  | - Neo4J     assertions for Neo4J types (Path, Node, Relationship...)
  | - DB        assertions for relational database types (Table, Row, Column...)
  | - Swing     provides a simple and intuitive API for functional testing of Swing user interfaces
  ```

* Example:
  ```
  |import static org.assertj.core.api.Assertions.*;
  |...
  |assertThat(frodo.getName()).isEqualTo("Frodo"); //  ← basic assertions
  |assertThat(frodo).isNotEqualTo(sauron);
  |
  |assertThat(frodo.getName())                     // ← chaining string specific assertions
  |    .startsWith("Fro")
  |    .endsWith("do")
  |    .isEqualToIgnoringCase("frodo");
  |
  |assertThat(fellowshipOfTheRingList)            // ← collection specific assertions
  |   .hasSize(9)                                 //   (there are plenty more)
  |   .contains(frodo, sam)
  |   .doesNotContain(sauron);
  |
  |assertThat(frodo.getAge())
  |   .as("check %s's age", frodo.getName())     // ← as() used to describe the test
  |   .isEqualTo(33);                            //    will be shown before the error message
  |
  |assertThatThrownBy(() -> {                    // ← exception assertion ( standard style)
  |   throw new Exception("boom!"); })
  |.hasMessage("boom!");
  |Throwable thrown = catchThrowable(() -> {     // ← exception assertion  ( BDD style)
  |   throw new Exception("boom!");
  |});
  |assertThat(thrown).hasMessageContaining("boom");
  |
  |assertThat(fellowshipOfTheRingList)
  |    .extracting(TolkienCharacter::getName)    // ← 'extracting' feature on Collection
  |    .doesNotContain("Sauron", "Elrond");      //
  |
  |assertThat(fellowshipOfTheRingList)
  |   .extracting("name", "age", "race.name")    // extracting multiple values at once grouped in tuples
  |   .contains(
  |      tuple("Boromir",   37, "Man"   ),
  |      tuple("Sam"    ,   38, "Hobbit"),
  |      tuple("Legolas", 1000, "Elf"   ) );
  |
  |assertThat(fellowshipOfTheRingList)
  |  .filteredOn(                              // ← filtering before asserting
  |    fellow -> fellow.getName().contains("o")
  |  )
  |  .containsOnly(aragorn, frodo);
  |
  |assertThat(fellowshipOfTheRingList)
  |  .filteredOn(                              // combining filtering and extraction
  |    fellow -> fellow.getName().contains("o")
  |  )
  |  .containsOnly(aragorn, frodo)
  |  .extracting(
  |     fellow -> fellow.getRace().getName())
  |  .contains("Hobbit", "Elf");
  |
  |// and many more assertions:
  |// iterable, stream, array, map, dates, path, file, numbers, predicate, optional ...
  ```
[[01_PM.TODO,qa.junit.assertj}]]

[[{qa.testing.property]]
# Property Testing

 A property testing is just something like:
 ```
 | for all (x, y, ...)
 | such as precondition(x, y, ...) holds
 | property(x, y, ...) is true
 ```

 It checks that a function/program/whatever is under test
abides by a property.  Most of the time, properties do not
have to go into too much details about the output, they
just have to check for useful characteristics that must be
seen in the output.

 Property based testing has become quite famous in the functional
world. Mainly introduced by QuickCheck framework in Haskell, it
suggests another way to test software. IT TARGETS ALL THE SCOPE
COVERED BY EXAMPLE BASED TESTING: (UNIT TESTS TO INTEGRATION TESTS).

* Available automated test technics:
 @[https://medium.com/criteo-engineering/introduction-to-property-based-testing-f5236229d237]
 ```
 |         △ • Random
 |    full ┆   - Fuzzing
 |      △  ┆   - Monkey testing
 |      ┆  ┆
 |   Input ┆ • Static Analysis
 |   scope ┆   - Mem. leaks        • Example based
 | covered ┆   - Unitialized mem.    - Unit tests
 |      ┆  ┆   - Nulls.              - QA test
 |      ▽  ┆   - Threading issues    - UI tests
 |  partial┆   - ...
 |        ─┼─╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶▷
 |           Low  ← Feature compliance →    High
 ```

Extracted from @[https://en.wikipedia.org/wiki/QuickCheck]<br/>
* List of Java libs for property testing 
  ```
  |"FunctionalJava's QuickCheck module". FunctionalJava.  2015-08-14
  |"Quickcheck for Java". Quickcheck.dev.java.net.        2011-12-09
  |"JCheck". JCheck.                                      2011-12-09
  |"junit-quickcheck". junit-quickcheck.                  2013-07-03
  |"jqwik for the JUnit5 Platform". jqwik.                2017-06-19
  |"Quick Theories property tests Java 8"                 2017-10-30
  |"jetCheck prop.-based tests    Java 8" (JetBrains)     2018-07-10
  ```

* e.g. test using 'jqwik':
  ```
  |""" fizzBuzz() must return "Fizz"
  |    for every divisible-by-3 input """
  |→  PRECONDITION: Consider inputs in [1 ... 100] divisible by 3
  |→ POSTCONDITION: fizzBuzz() returns "Fizz"

  |import java.util.*;
  |import java.util.stream.*;
  |import net.jqwik.api.*;

  |class FizzBuzzTests {

  |    String fizzBuzz(int i) {               // ← function to test
  |       boolean div3 = (i % 3 == 0),
  |               div5 = (i % 5 == 0);
  |       if (div3&& div5) return "FizzBuzz";
  |       if (div3) return "Fizz";
  |       if (div5) return "Buzz"
  |       return String.valueOf(i);
  |    }

  |    @Provide
  |    Arbitrary<Integer> divisibleBy3() {    // ← Precondition
  |      return Arbitraries.integers()        //   input to function
  |        .between(1, 100)                   //   divides by 3.
  |        .filter(i -> i % 3 == 0);
  |    }

  |    final List<String> IN_OUT =
  |      IntStream.range(1, 100)
  |        .mapToObj((int i) -> )
  |        .collect(Collectors.toList());

  |    @Property                              // ← Test to execute
  |    boolean divBy3_starts_with_Fizz(
  |      @ForAll("divisibleBy3") int i) {     // ← "inject" precondition
  |      return IN_OUT
  |             .get(i - 1)
  |             .startsWith("Fizz");          // ← check Postcondition
  |    }
  |}
  ```
[[qa.testing.property}]]


# JSR Annotations for Defect Detection [[{qa.error_control,qa.billion_dolar_mistake]]
@[https://stackoverflow.com/questions/1476757/jsr305-vs-jsr308-java-type-anotations-which-is-going-to-be-the-standard]
[[}]]

# TYPE ANNOTATIONS: [[{qa.billion_dolar_mistake,01_PM.TODO]]
@[https://blogs.oracle.com/java-platform-group/entry/java_8_s_new_type]
( TODO: Compare how it compares/overlaps CheckerFramework )
  ```
  |  @NonNull  compiler can determine cases where a │ @(Un)Tainted   Identity types of data that should
  |            code path might receive a null value,│                not be used together, such as remote
  |            without ever having to debug a       │                user input being used in system
  |            NullPointerException. The compiler   │                commands, or sensitive information in
  |            just print a warning, but it         │                log streams
  |            continues to compile!!!              │
  |                                                 │ @              Units of measure ensures that numbers
  |  @ReadOnly compiler will flag any attempt to    │                used for measuring objects are used
  |            change the object. This is similar to│                and compared correctly, or have
  |            Collections.unmodifiableList, but    │                undergone the proper unit
  |            more general and verified at compile │                conversion.
  |            time.                                │
  |  @Regex    Provides compile-time verification   │ @FunctionalInterface  indicates that the type declaration
  |            that a String intended to be used as │                is intended to be a functional
  |            a regular expression is a properly   │                interface, as defined by the Java
  |            formatted regular expression.        │                Language Spec.
  ```

* Examples :
  ```
  |Annotation
  |@NonNull List<String>                          // <·· A non-null list of Strings.
  |List<@NonNull String>                          // <·· A list of non-null Strings.
  |@Regex String validation = "(Java|JDK) [7,8]"  // <·· Check at compile time that this 
  |                                               //     String is a valid regular expression.
  |private String getInput(String parameterName){ // <·· The object assigned to retval is tainted
  |                                               //     and not for use in sensitive operations.
  |  final String retval =
  |    @Tainted request.getParameter(parameterName);
  |  return retval;
  |}
  |
  |private void 
  |runCommand(@Untainted String... commands){     // <·· Each command must be untainted. 
  |  ProcessBuilder processBuilder                //     For example, the previously tainted
  |     = new ProcessBuilder(command);            //     String must be validated before 
  |                                               //     being passed in here.
  |  Process process = processBuilder.start();
  |}
  ```
[[}]]

# Behavior Driven Development (BDD)
## BDD KEYPOINTS  <!-- { -->
  C&P&Summarized from "The Cucumber For Java Book" (by Seb Rose, Matt Wynne and Aslak Hellesøy)
* Help developers, project managers, product owners and testers
  develop functional-test scripts:
  BDD might just seem like a testing tool, but at its heart it’s really a
  collaboration tool. If you make a genuine effort to write features that work as
  documentation for the NONTECHNICAL STAKEHOLDERS on your team, you’ll find
  you are forced to talk with them about details that you might never have
  otherwise made the time to talk about. Those conversations reveal insights
  about their understanding of the problem, insights that will help you build
  a much better solution than you would have otherwise. This is Cucumber’s
  big secret: the tests and documentation are just a happy side effect; the real
  value lies in the knowledge you discover during those conversations.
* For a suite of automated tests to be useful, the team must have
  absolute trust in it. When even just a single test is compromising that trust,
  it has a corrosive effect on how everyone feels about the whole test suite.
* The ubiquitous language your team uses will be driven by the domain you’re
  working in. If you’re building a system for live-music fans, your ubiquitous
  language will include words like concert, performance, artist, and venue. If
  you’re building a catalog of TV shows, you’ll have words like broadcaster,
  genre, duration, and transmission date in your ubiquitous language.
  The point is for everyone on the team to use the same words, everywhere. It’s
  not OK to have a database table called tbl_Performer if the rows in that table
  represent things that most of the team refers to as artists. Wherever you see
  schism like this, stop, decide which is the right word to use, make the
  appropriate correction, and then stick with it.
  We talk about developing a ubiquitous language because it’s an ongoing
  process. That development takes work. It takes effort to really listen to one
  another and agree on the words you’ll use, and it takes discipline to stick to
  those commitments.
<!-- } -->

# Cucumber BDD [[{]]
* Multilanguage (Java, Ruby, Go, Python,...)

* Cucumber test flow:
  ```
  |       Project                              1. Describe behaviour
  |         │                                  2. Write step definition
  |         v                                  3. Run and fail
  |      Features      ····┐                   4. Write code to make step pass
  |         │              │                   5. Run and pass
  |         v              │  Business
  |     Scenarios          │  Facing
  |         │              │
  |         v              │
  |       Steps        ····┘
  |         │
  |         v
  |    Step Definitions  ··┐
  |         │              │
  |         v              │  Technology
  |     Support Code       │  Facing
  |         │              │
  |         v              │
  |    Automation Library··┘
  |         │
  |         v
  |    Testing Enviroment  <·· Infra/DevOps
  ```

## Cucumber JAVA + Maven Setup:

 ```
 | <dependency>
 |   <groupId>info.cukes</groupId>
 |   <artifactId>cucumber-java</artifactId>
 |   <version>1.0.2</version>
 |   <scope>test</scope>
 | </dependency>
 | 
 | <dependency>
 |   <groupId>info.cukes</groupId>
 |   <artifactId>cucumber-junit</artifactId>
 |   <version>1.0.2</version>
 |   <scope>test</scope>
 | </dependency>
 ```

## Ussage from command line:

 ```
 | $ java -cp "jars/*" cucumber.api.cli.Main --help
 |
 | Example shell script to launch cucumber tests:
 | javac -cp "jars/*" \
 |    step_definitions/CheckoutSteps.java <··· compile Steps definitions
 | java -cp "jars/*:." \
 |    cucumber.api.cli.Main \             <··· Cucumber CLI interface
 |    -p pretty \                         <··· use pretty formatter plugin (or -p progress ..)
 |    --snippets camelcase \
 |    -g step_definitions \               <··· Where to look for Step definitions
 |    --strict                            <··· Returns -1 if there are undef.|pending steps.
 |    features/                           <··· Path to *.feature files
 ```

## Features KEYPOINT

> When writing Cucumber features, make readability your main goal.
> Otherwise, a reader can easily feel more like they’re reading a computer pro-
> gram than a specification document, which is something we want you to try
> to avoid at all costs. After all, if your features aren’t easy for nonprogrammers
> to read, you might as well just be writing your tests in plain old code.
> Each `Feature` is tested in one or more `Scenario`s (`Scenario Outline`s)

 ```
 |Feature: The user must be able to checkout provided
 |  he has control of a credit card
 |  # `Background` avoid repetitive code to all scenarios
 |  # Don't use it to set up complicated state unless that
 |  # state is something the reader actually needs to know.
 |  Background:
 |    Given I have been issued a new card
 |    And I insert the card, entering the correct PIN
 |    And I choose "Change PIN" from the menu
 |
 |
 |  # Each scenario is a single concrete example. (isolate test)
 |  # Each feature typically has somewhere between five and twenty scenarios,
 |  # each describing different examples of how that feature should behave in dif-
 |  # ferent circumstances.
 |  # Each scenario must be executed **independently** of any other scenario,
 |  # that is, they must NOT share state.
 |  # Each scenario has one or more steps (`Given`, `When`, `Then`, ...)
 |  Scenario
 |    Given the price of a "banana" is 40c
 |    But the price of 10 "banana" is 300c
 |    When I checkout 1 "banana"
 |    Then the total price should be 40
 |    And I should receive a ticket
 |
 |  Scenario:
 |    Given these Users:
 |      | name       | date of birth   | action    |
 |      | Michael    | August 29, 1858 | died      |
 |      | John       | October 9, 1943 | married   |
 |      | Emma       | July    7, 2021 | played    |
 |    When the user x
 |    Then their marital status should look like:
 |      | Michael    | Deceased        |
 |      | John       | Married         |
 |      | Emma       | Unmarried       |
 |
 |
 |  # Scenario Outline is used when several scenarios
 |  # follow exactly the same "pattern" of steps with
 |  # just different input values. Placeholders <...>
 |  # indicate where we want real values to be replaced.
 |  # @tags allows to organize scenarios in cross-cutting
 |  # (multidimensional) concerns. This help in:
 |  # * Documentation
 |  # * Filtering: Cucumbers Hooks executions can be
 |  #              conditioned to the existence of a given
 |  #              tag for a given Scenario.
 |
 |  @shopping  @UI  @error_management
 |  Scenario Outline: Checkout bananas
 |    Given the price of a "banana" is 40c
 |    But the price of 10 "banana" is 300c
 |    When I checkout <count> "banana"
 |    Then the total price should be <total>
 |    And I should receive a ticket that looks like
 |      """
 |         Ticket XXXX-XX-XX
 |
 |         concept                  | quantity
 |         bananas                  | ...
 |      """
 |
 |    # `Examples` provid the table input to the Scenario Outline
 |    # See also:
 |    # https://github.com/cucumber/cucumber-jvm/tree/main/datatable
 |    Examples: Succesul checkout
 |      | count | total |
 |      | 1     |  40   |
 |      | 2     |  80   |
 |      | 30    |  300  |
 |    Examples: Attempt to buy too many bananas
 |      The system doesn't allow to buy more than 100 per person
 |      | count | total                |
 |      | 1000  | see an error message |
 |      | 2000  | see an error message |
 |      | 3000  | see an error message |
 |
 |
 |  NOTE: `Given`, `When`, `Then`, `And`, `But` are actually ALIASES to
 |        `StepDefAnnotation`. The distintion is made just for human readability.
 ```

## Tabulated test data <!-- { -->

  ```
  |     ┌─ BoardSteps ─────────────────────────────────────┐ ┌─ board.feature ──────────────────────────┐
  |     │ package tic_tac_toe;                             │ │ Feature:                                 │
  |     │                                                  │ │   Scenario:                              │
  |     │ import cucumber.api.java.en.*;                   │ │                                          │
  |     │ import cucumber.api.PendingException;            │ │                                          │
  |     │ import cucumber.api.DataTable;                   │ │                                          │
  |     │                                                  │ │                                          │
  |     │ // Managing tests with tables:                   │ │                                          │
  |     │ public class BoardSteps {                        │ │                                          │
  |     │                                                  │ │                                          │
  |     │   @Given("^a board like this:$")                 │ │     Given a board like this:             │
  |  ┌··>   public void aBoardLikeThis(DataTable arg1)     │ │     |   | 1 | 2 | 3 |                    │
  |  ·  │  throws Throwable {                              │ │     | 1 |   |   |   |                    │
  |  ·  │     // Mark as pending!!!                        │ │     | 2 |   |   |   |                    │
  |  ·  │     throw new PendingException();                │ │     | 3 |   |   |   |                    │
  |  ·  │   }                                              │ │                                          │
  |  ·  │                                                  │ │                                          │
  |  ·  │   @When("^X plays in row (\\d+), column (\\d+)$")│ │    When X plays in row 2, column 1       │
  |  ·  │   public void                                    │ │                                          │
  |  ·  │     playerXPlaysInRowColumn(int arg1, int arg2)  │ │                                          │
  |  ·  │   throws Throwable {                             │ │                                          │
  |  ·  │     throw new PendingException();                │ │                                          │
  |  ·  │   }                                              │ │                                          │
  |  ·  │                                                  │ │                                          │
  |  ·  │   @Then("^the board should look like this:$")    │ │    Then the board should look like this: │
  |  ·  │   public void                                    │ │     |   | 1 | 2 | 3 |                    │
  |  ├··>      theBoardShouldLookLikeThis(DataTable arg1)  │ │     | 1 |   |   |   |                    │
  |  ·  │   throws Throwable {                             │ │     | 2 | x |   |   |                    │
  |  ·  │     throw new PendingException();                │ │     | 3 |   |   |   |                    │
  |  ·  │   }                                              │ └──────────────────────────────────────────┘
  |  ·  │ }                                                │
  |  ·  └──────────────────────────────────────────────────┘
  |  └·· For automatic transformation, change DataTable to one of
  |      List<YourType>, List<List<E>>, List<Map<K,V>> or Map<K,V>.
  |      E,K,V must be a scalar (String, Integer, Date, enum etc)
  ```
<!-- } -->

## Step Definition Code Snippets

 ```
 |assertEquals(total, checkout.total()); // Launch AssertionError if false
 |throw new PendingException(); // mark test as pending ("half way" done)
 |
 |Cucumber Hooks examples:
 |package hooks;
 |import cucumber.api.Scenario;
 |
 |public class SomeTestHooks {
 | //                        /--------v-··· optional: Selectively run the hook
 | @cucumber.api.java.Before("@webTest")  // If Scenario is tagged with tag.
 | public void resetBeforeCallingScenario() {
 |   // let's reset to stable state "anything"
 |   ...
 | }
 |
 | @cucumber.api.java.After
 | public void afterRunningScenario(Scenario scenario) {
 | System.out.println("... " + scenario.getStatus());
 | }
 |}
 ```
[[}]]

[[{qa.testing.bdd.serenity,qa.documentation,01_PM.TODO]]
# BDD Serenity Testing
@[https://serenity-bdd.github.io/theserenitybook/latest/index.html]

* Serenity BDD provides strong support for different
  types of automated acceptance testing, including:
  * Web testing with Selenium.
  * REST API testing with RestAssured.
  * Highly readable, maintainable and scalable automated
    testing with the Screenplay pattern.
  * BDD-style executable specifications with Cucumber

* Serenity reports also include how tests were tested,
  including step-by-step details and optional screenshots,
  to truly document what your application does.
   It not documents what tests have been executed, but
  WHAT REQUIREMENTS HAVE BEEN TESTED.

* It can also integrate with requirements stored in an
  external source (JIRA or any other test cases management
  tool), or just use a simple directory-based approach.

* Serenity BDD automated acceptance testing libraries
  includ:
  * REST API testing with RestAssured.
  * Highly readable, maintainable and scalable automated
    testing with the Screenplay pattern.
  * Rich built-in support for web testing with Selenium.
  * Cucumber or JBehave for BDD.


## Screenplay Pattern [[{]]

* <https://serenity-bdd.github.io/docs/tutorials/screenplay>
* write readable test automation modeled around the user.
* built on good software engineering principles such as:
  * Single Responsibility Principle.
  * Open-Closed Principle
  * effective use of Layers of Abstraction.
 ```
 |┌·performs··>|tasks|¹    ¹Task       : action/s to perform some goal.
 |·              ◇         ²Interaction: action    with the App.(UI,...)
 |·              ·
 |·           made up of
 |·              ·
 |├·performs··>|interac-|····· interact with ······┐
 |·            |tions  ²|··enable·┐                ·
 |·                               v                v
||Actor|·······has·········>|Abilities|··invoke··>Tested
 |·                              ^                test
 |·                              ·
 |·                ┌······enable·┘
 |└·· answers·┐    ·
 |            v    ·
 |        |Questions|
 |         about the system
 ```

* Example:
  ```
  |┌───┬─·····················  Screenplay test: User-centric model:
  |·   ·                        "everything" starts
  |·   ·                        with the actor, interacting with the app
  |wendy                        to perform tasks and achieve their goals.
  |.attemptsTo(            <··  takes a list of actions ("performables") that
  |                             the actor needs to perform. They divide into:
  |                             Interactions: when interacting directly with
  |                                  the app. (Click button, Open URL, ...)

  |  Navigate.toTheHomePage(),    <·· Interaction: action with the App.
  |  Search.byKeyword("Everest"), <·· Task: action to perform some goal.
  |  Ensure
  |  .that(DisplayedArticle.firstHeading())
  |  .isEqualTo("Mount Everest")
  |);
  ```

* Quick start: clone one of the starter projects.
  * <https://github.com/serenity-bdd/serenity-cucumber-starter>
  * <https://github.com/serenity-bdd/serenity-junit-starter>
  * <https://github.com/serenity-bdd/serenity-junit-screenplay-starter>
  * <https://github.com/serenity-bdd/docs-starter-tutorial>
  * <https://github.com/serenity-bdd/serenity-rest-starter>
  * <https://github.com/serenity-bdd/serenity-jbehave-starter>
  * <https://github.com/serenity-bdd/serenity-cucumber4-starter>
  * <https://github.com/serenity-bdd/bdd-starter>
  * <https://github.com/serenity-bdd/serenity-cucumber5-starter>

* Ex: Serenity Screenplay and JUnit 5.<b re/>
  We will use some simple conventions to organise our test classes, 
  based on the standard Maven project structure you can see here:
  ```
  | ┌────────────┬─··········  standard maven convention for JAVA tests
  | src/test/java/todomvc/features   <·· test clases
  | src/test/java/todomvc/screenplay <·· Screenplay classes, designed to be highly modular and reusable,
  |                                      and often appear in many tests, so it makes sense to keep them
  |                                      separate from the tests themselves.
  |
  | src/test/resources/serenity.conf <·· JUnit test results are based on the package structure
  |                                      set here the root package for tests.
  | + serenity.test.root = todomvc.features
  ```

### Writing an scenario

* Creating the test case:
  Test: add a 'to do' item (say, "Buy some milk") to an empty list.

  ```
  |src/test/java/todomvc/features

  |package todomvc.features;
  |import net.serenitybdd.junit5.SerenityJUnit5Extension;
  |import net.serenitybdd.screenplay.Actor;
  |import net.serenitybdd.screenplay.actions.Enter;
  |import net.serenitybdd.screenplay.actions.Open;
  |import net.serenitybdd.screenplay.annotations.CastMember;
  |import net.serenitybdd.screenplay.questions.Text;
  |import org.junit.jupiter.api.DisplayName;
  |import org.junit.jupiter.api.Test;
  |import org.junit.jupiter.api.extension.ExtendWith;
  |import org.openqa.selenium.Keys;
  |import static org.assertj.core.api.Assertions.assertThat;

  |@ExtendWith(SerenityJUnit5Extension.class)
  |class AddNewTodos {
  |  @CastMember(name = "Toby")  <·· declare and instantiate new actor "Toby"
  |  Actor toby;                     for our test and assign a webdriver instance
  |                                  that he can use to interact with our app
  |  @Test                           performing tasks and interactions
  |  @DisplayName("Add todo item to empty list")
  |  void addToEmptyList() {
  |      toby.attemptsTo(
  |        Open.url("https://..."),               <·· Interaction 1
  |        Enter.theValue("Buy some milk")        <·· Interaction 2
  |             .into(".new-todo")
  |        .thenHit(Keys.RETURN)                  <·· Interaction 3
  |      );
  |      var todos = toby.asksFor(
  |        Text                          <·· Question: class that knows how to
  |          .ofEach(".todo-list label")     retrieve a specific piece of info.
  |      );                                  about the state of the application.
  |  }
  |}
  ```

  ```
  |$ mvn clean verify  # Generate test reports
  |$ mvn verify...
  |[INFO] -----------------------------------------
  |[INFO]  SERENITY TESTS: SUCCESS
  |[INFO] -----------------------------------------
  |[INFO] | Test cases executed    | 1
  |[INFO] | Tests executed         | 1
  |[INFO] | Tests passed           | 1
  |[INFO] | ...
  |...
  |[INFO] SERENITY REPORTS
  |[INFO]   - Full Report: file:.../index.html
  |[INFO] ...
  |[INFO] BUILD SUCCESS
  ```
[[}]]

## Rest Testing:  [[{]]
* TIGHT INTEGRATION WITH REST ASSURED !!!
  <https://serenity-bdd.github.io/docs/tutorials/rest>

* PRESETUP:
  ```
  |$ editor pom.xml
  |  <dependencies>
  |    ...
  |+   <dependency>
  |+     <groupId>net.serenity-bdd</groupId>
  |+     <artifactId>serenity-rest-assured</artifactId>
  |+     <version>${serenity.version}</version>
  |+     <scope>test</scope>
  |+   </dependency>
  |    ...
  |  <dependencies>
  |  ...
  |- <reports>single-page-html</reports>      <·· by deleting this line detailed report is generated.
  |  src/main/java/starter                    <·· empty. Just testing public Pet Store API
  |  src/test/java/starter                    <·· test class/es + helpers
  |  src/test/java/starter/petstore/resources <·· re-use (from the template) the contents already there
  ```

* Ussage:
  ```
  | package starter.petstore;
  | import io.cucumber.java.en.Given;
  | import io.cucumber.java.en.Then;
  | import io.cucumber.java.en.When;
  | import io.restassured.http.ContentType;
  | import io.restassured.mapper.ObjectMapperType;
  | import net.serenitybdd.core.steps.UIInteractions;
  | import org.hamcrest.Matchers;
  | import static net.serenitybdd.rest.SerenityRest.*;
  | public class PetApiActions extends UIInteractions { // <·· Action class (small & reusable)

  |   @Given("Kitty is available in the pet store")     // <·· Arrange (POST) new pet
  |     public Long givenKittyIsAvailableInPetStore() {
  |       Pet pet = new Pet("Kitty", "available");
  |       Long newId = given()
  |         .baseUri("https://petstore.swagger.io")     // <·· config reused in following tests
  |         .basePath("/v2/pet")                        // <·· config reused in following tests
  |         .body(pet, ObjectMapperType.GSON)
  |         .accept(ContentType.JSON)
  |         .contentType(ContentType.JSON)
  |         .post().getBody().as(Pet.class, ObjectMapperType.GSON)
  |         .getId();
  |       return newId;                                 // <·· Used as input in next step
  |     }

  |                                          //  ┌─┬─ It will take the value of param (Long) id
  |     @When("I ask for a pet using Kitty's ID: {0}")  // <·· Act on the API
  |     public void whenIAskForAPetWithId(Long id) {
  |       when().get("/" + id);
  |     }
  |     @Then("I get Kitty as result")                  // <·· Assert. Check API returned JSON.
  |     public void thenISeeKittyAsResult() {
  |       then()
  |       .body("name", Matchers.equalTo("Kitty"));
  |     }
  | }
  ```

* ```
  | package starter.petstore;
  | import net.serenitybdd.junit5.SerenityJUnit5Extension;
  | import org.junit.jupiter.api.Test;                  // <··· WARN: Don't mix with org.junit.Test
  | import org.junit.jupiter.api.extension.ExtendWith;  //            (JUnit4)
  | @ExtendWith(SerenityJUnit5Extension.class)          // <··· Don't forget
  | public class WhenFetchingAlreadyAvailablePet {      // <··· test class
  |           // └──┴─····· `When` prefix is one of the ways to make sure the method
  |           //            is recognized as a test to be run in the Maven build process.
  |           //            See pom.xml (maven-failsafe-plugin) for more details on this.
  |   Long newPetId = null;
  |   PetApiActions petApi;
  |   @Test
  |   public void fetchAlreadyAvailablePet() {         // ┌─ BDD ──────────────────────────────────┐
  |     newPetId = petApi                              // │ Given Kitty is available in pet store  │
  |                .givenKittyIsAvailableInPetStore(); // │   When I ask for a pet using Kitty's ID│
  |     petApi.whenIAskForAPetWithId(newPetId);        // │   Then I get Kitty as result           │
  |   }                                                // └────────────────────────────────────────┘
  |   public void fetchAlreadyAvailablePet() {
  |     petApi.thenISeeKittyAsResult();
  |   }
  | }
  ```

  ```
  |$ mvn clean verify # Execute tests  
  |( Report generated in target/site/serenity/index.html )
  |[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0,
  |...
  ```
[[}]]

## Cucumber + screenplay [[{]]
* <https://serenity-bdd.github.io/docs/tutorials/cucumber-screenplay>

* Use Gherkin language in `.feature` file for the well-known TodoMVC project
  Create living documentation that also serves as a test report and a progress report
  ```
  | src/main/java/starter
  | src/test/java/starter/helpers
  | src/test/resources/features/*.feature      <··· Executable *.feature specification file
  | src/test/java/starter/stepdefinitions      <··· "glue" code implementing steps mentioned in *.feature files.
  ```

  ```
  | ─ add_new_todo.feature ─────────────────────────────────────────────
  |  Feature: Add new item to TODO list
  |  Scenario: Add buying milk to the list
  |               Given Rama is looking at his TODO list
  |               When he adds "Buy some milk" to the list
  |               Then he sees "Buy some milk" as item in the TODO list
  ```

  ```
  package starter.helpers;
  import net.serenitybdd.core.pages.PageObject;
  import net.serenitybdd.screenplay.targets.Target;
  import net.thucydides.core.annotations.DefaultUrl;
  @DefaultUrl("https://todomvc.com/examples/angularjs/#/")
  public class TodoListPage extends PageObject {  // <·· PageObject: (Screenplay pattern) helper class
                                                  //      containing all the information needed to use
                                                  //      a given web page
    public static Target ITEM_NAME_FIELD =
      Target.the("item name field").locatedBy(".new-todo");
    public static Target ITEMS_LIST =
      Target.the(" item list").locatedBy(".todo-list li");
  }

  package starter.helpers;
  import net.serenitybdd.screenplay.Performable;
  import net.serenitybdd.screenplay.Task;
  import net.serenitybdd.screenplay.actions.Open;
  public class NavigateTo {
    public static Performable theTodoListPage() {
      return Task.where(
        "{0} opens the Todo list page",
          Open.browserOn().the(TodoListPage.class));
      }
  }
  ```

  ```
  | package starter.helpers;
  | import net.serenitybdd.screenplay.Performable;
  | import net.serenitybdd.screenplay.Task;
  | import net.serenitybdd.screenplay.actions.Enter;
  | import org.openqa.selenium.Keys;
  | public class AddAnItem {                      // <·· (Screenplay pattern) Utility class
  |                                               //     explaining the steps needed to add
  |                                               //     an item to the list.
  |   public static Performable withName(String itemName){
  |     return Task.where(
  |       "{0} adds an item with name "+itemName,
  |            Enter.theValue(itemName)
  |                 .into(TodoListPage.ITEM_NAME_FIELD)
  |                 .thenHit(Keys.ENTER)
  |       );
  |     }
  | }
  ```
  
  ```
  | package starter.stepdefinitions;
  | import io.cucumber.java.en.Given;
  | import io.cucumber.java.en.Then;
  | import io.cucumber.java.en.When;
  | import net.serenitybdd.screenplay.Actor;
  | import net.serenitybdd.screenplay.ensure.Ensure;
  | import starter.helpers.AddAnItem;
  | import starter.helpers.NavigateTo;
  | import starter.helpers.TodoListPage;
  | import io.cucumber.java.PendingException;
  |
  | public class AddItemStepDefinitions {               // <·· translate *feature into code
  |                                                     //     It looks like "spoken" English.
  |                                                     //     (pleasant side-effect of using Screenplay pattern)
  |   @Given("{actor} is looking at his TODO list")
  |   public void actor_is_looking_at_his_todo_list(Actor actor) {
  |       // throw new PendingException("Not Implemented");          // <·· Throw to mark test as peding (to fulfill)
  |       actor.wasAbleTo(NavigateTo.theTodoListPage());
  |   }
  |   @When("{actor} adds {string} to the list")
  |   public void he_adds_to_the_list(Actor actor, String itemName) {
  |      actor.attemptsTo(AddAnItem.withName(itemName));
  |   }
  |   @Then("{actor} sees {string} as item in the TODO list")
  |   public void he_sees_as_an_item_in_the_todo_list(Actor actor, String expectedItemName) {
  |       actor.attemptsTo(Ensure.that(TodoListPage.ITEMS_LIST).hasText(expectedItemName));
  |   }
  | }
  ```

  ```
  | $ mvn clean verify   # Run tests.
  | [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 28.42 s - in starter.CucumberTestSuite
  | ...
  ```
[[}]]

## 1/2-way integration with JIRA [[{]]
* REF: <https://serenity-bdd.github.io/docs/reporting/integrating_with_jira>

### One way integration with JIRA

* ... JIRA commonly store requirements as story cards grouped into epics.
  placed into sprints for project planning
  ```
  | ┌─ JIRA Story card: ──────────────────────────────────────────────────────┐
  | │ Flying High / FH-17                                                     │
  | │ "Calculating status based on points"                                    │
  | │ │Edit││Comment│  │Assign││More v│  │Start Progress││Resolve││Close│ ... │
  | │ Details ─────────────────────────────────────────────────────────────── │
  | │ Type:         Story             Status:  OPEN                           │
  | │ Priority:     Major             Resolution: Unresolved                  │
  | │ Affect Ver/s: None              Fix Version/s:  None                    │
  | │ Labels:       None                                                      │
  | │ Epic Link:    "Earning Points"                                          │
  | │ Acceptance:   * New members should start with Bronze status             │
  | │   Criteria    * Memebers should get status updates based on             │
  | │                 status points earned.                                   │
  | │ Description ─────────────────────────────────────────────────────────── │
  | │ As a Frequent Flyer member                                              │
  | │ I want my status to be upgraded as soon as I earn enough points         │
  | │ So that I can benefit from my igher status sooner                       │
  | └─────────────────────────────────────────────────────────────────────────┘
  |
  | ┌──────────────────────────────────────────────────────────────────┐[[{doc_has.keypoint}]]
  | │ acceptance criteria can be built into more detailed scenarios,   │
  | │ based on concrete examples. We can then automate these scenarios │
  | │ using a BDD tool like JBehave.                                   │
  | └──────────────────────────────────────────────────────────────────┘
  ```
* Acceptance criteria as seen by JBehave scenario:
  ```
  |  │ Frequent Flyer status is calculated based on points
  |┌·> Meta:@issue #FH-17
  |· │ Scenario: New members should start out as Bronze members
  |· │ Given Jill Smith is not a Frequent Flyer member
  |· │ When she registers on the Frequent Flyer program
  |· │ Then she should have a status of Bronze
  |· │
  |· │ Scenario: Members should get status updates based on status points earned
  |· │ Given a member has a status of <initialStatus>
  |· │ And he has <initialStatusPoints> status points
  |· │ When he earns <extraPoints> extra status points
  |· │ Then he should have a status of <finalStatus>
  |· │
  |· │ Examples:
  |· │ | initialStatus| initialStatusPoints|extraPoints|finalStatus|notes                |
  |· │ | Bronze       | 0                  |300        |Silver     |300 points for Silver|
  |· │ | Silver       | 0                  |700        |Gold       |700 points for Gold  |
  |· │ | Gold         | 0                  |1500       |Platinum   |1500 points for Plat.|
  |·
  |└─ @issue associate JBehave-stories|JUnit-tests to JIRA card
  |          creating  HTML links to JIRA task.
  ```
* JIRA setup:
  ```
  |  serenity.properties
  |+ jira.url=https://srv1.atlassian.netjira.project=FHjira.username=$user.password=$pass
  |
  |  (props. can also be set in graddle.settings or maven pom.xml)
  ```
* Automatically feedback JIRA about tests results:
  ```
  |   pom.xml
  |   <dependencies>
  |       ...
  | +     <dependency>
  | +         <groupId>net.serenity.plugins.jira</groupId>
  | +         <artifactId>serenity-jira-requirements-provider</artifactId>
  | +         <version>xxx</version>
  | +     </dependency></dependencies>
  |   </dependencies>
  |   ...
  |   <build>
  |       ...
  |       <plugins>
  |           ...
  |           <plugin>
  |               <groupId>net.serenity.maven.plugins</groupId>
  |               <artifactId>maven-serenity-plugin</artifactId>
  |               <version>xxx</version>
  |               <executions>
  | +                 <execution>
  | +                     <id>serenity-reports</id>
  | +                     <phase>post-integration-test</phase>
  | +                     <goals>
  | +                         <goal>aggregate</goal>
  | +                     </goals>
  | +                 </execution>
  |               </executions>
  |               <dependencies>
  | +                 <dependency>
  | +                     <groupId>net.serenity.plugins.jira</groupId>
  | +                     <artifactId>serenity-jira-requirements-provider</artifactId>
  | +                     <version>xxx</version>
  | +                 </dependency>
  |               </dependencies>
  |           </plugin>
  |       </plugins>
  |   </build>
  ```
* serenity.properties
  ```
  |   ...
  | + jira.custom.field.1=Acceptance Criteria     <··· add to report output
  ```

 Now, when running the tests,  Serenity will query JIRA to determine
the epics and stories that you have defined and list them on the
Requirements page of the output report.

  ```
  ||Overall Test Result|   |Requirements|  |Releases|  ....
  |
  | Requirements Overview
  | Requirement Type  |   Total  | Pass   | Fail  | Pending   | Ignored | Untested
  | Epics                   7  ...
  | Stories                15  ...
  | Acceptance Criteria   100  ...  (tests)
  ```


### Two way integration with JIRA

* Simplest way:
  ```
  |  $ editor serenity.properties 
  |     ...
  |  +  serenity.public.url=https://.../serenity/report <·· tell Serenity where reports live
  |     ...                                                 Serenity will then insert a link
  |                                                         into the JIRA issue card
  |  +  serenity.jira.workflow.active=true
  |                                   └┬─┘
  |     (Optional) Update JIRA issue states (deactivated by default)
  |     default JIRA workflow: open or in progress issues associated with
  |     successful tests will be resolved, and closed or resolved issues
  |     associated with failing tests will be reopened.
  ```
  NOTE: to skip updates to JIRA (for example, testing in local -vs QA enviroment)
  `serenity.skip.jira.updates=true`

### Customized JIRA workflows (Groovy DSL)

   ```
   | + serenity.jira.workflow=my-workflow.groovy
   | ┌────────────────┬─·····─┴────────────────┘
   | my-workflow.groovy
   | when 'Open'       , {    'success' should: 'Resolve Issue'}
   | when 'Reopened'   , {    'success' should: 'Resolve Issue'}
   | when 'Resolved'   , {    'failure' should: 'Reopen Issue'}
   | when 'In Progress', {    'success' should: ['Stop Progress','Resolve Issue']}
   | when 'Closed'     , {    'failure' should: 'Reopen Issue'}
   ```

### RELEASE MANAGEMENT
* In JIRA, project releases are commonly organised into versions:
  ```
  | PROJECT XXXX
  |   Key: FH Lead: ...
  |   
  |   |Overview| |Administration|
  |    ^^^^^^^^
  |    Summary    ┌─────────────────────────────────────────────────────────────
  |    Issues     │ VERSIONS
  |    Agile      │ Name           Start Date     Release Date    Description
  |    Change Log │ ──────────────────────────────────────────────────────────
  |    Reports    │ Release 2.0
  |    Versions  ─┤ Iteration 1.3
  |    Calendar   │ ...
  |               │ Release 1.0
  |                 └─────┬──────┘
  |                - To JIRA they all are flat versions.
  |                - Serenity use a hierarchical structure based on naming convention:
  |                  "release"  : 1st level
  |                  "iteration": 2nd level
  |                  (or "sprint")
  |                 - Use next config. property to customize the behaviour. Ex:
  |                   serenity.release.types=milestone, release, version
  ```
[[}]]

## TODO

* <https://serenity-bdd.github.io/docs/reporting/the_serenity_reports>
  Serenity reports aim not only to report test results, but also
  to document how features are tested, and what the application does.
* <https://serenity-bdd.github.io/docs/reporting/living_documentation> !!!
  * BDD Tests as Living documentation describing the software
  <https://serenity-bdd.github.io/docs/reporting/filtering_reports>
  <https://serenity-bdd.github.io/docs/reporting/additional_reports>
  * e-mail reports!
  * Single page react app reports.

* <https://serenity-bdd.github.io/docs/reporting/reports_custom_info>
  Custom fields can be included in the reports, using values that are
  either taken from the environment variables or passed into the build
  via system properties. This can be useful if you want to include the
  product or build version, the environment the tests were run on, or
  the test run date.
* <https://serenity-bdd.github.io/docs/cloud/selenium-grid>
  execute WebDriver scripts on remote parallel machines (virtual or real)
  by routing commands sent by the client to remote browser instances.
* <https://serenity-bdd.github.io/docs/cloud/lambdatest>
  LambdaTest is a cloud platform for test execution and test
  orchestration. With LambdaTest, Serenity users can extend their
  automation test coverage of their web and mobile apps on 3000+ real
  devices, browsers, and operating systems.
* <https://serenity-bdd.github.io/docs/cloud/browserstack
  online platform that allows you to run cross-browser tests in parallel at scale.
* <https://serenity-bdd.github.io/docs/cloud/saucelabs>
  seamless integration with the SauceLabs online test automation platform.
  "Test on thousands of device, browser, and OS configurations – anywhere, any time"
* <https://serenity-bdd.github.io/docs/cloud/bitbar>
  seamless integration with the BitBar online test automation platform
  web, native, or hybrid, securely test your app across real environments
* <https://serenity-bdd.github.io/docs/mobile/appium>
  running tests on mobile devices/emulators
* <https://serenity-bdd.github.io/docs/reference/serenity-properties>
  Serenity configuration options.
[[qa.testing.bdd.serenity}]]

[[{async/reactive.testing,qa.testing.async/reactive,01_PM.TODO]]
# Awaitility(Async->Sync) Tests
@[https://github.com/awaitility/awaitility]
* Awaitility: DSL allowing to express async results (test expectations) easely.
  removing complexity of handling threads, timeouts, concurrency issues, ...
  that obscured test code.

* Ex 1:
  ```
  | @Test
  | public void updatesCustomerStatus() {
  |   // Publish a (async) message to a message broker:
  |   messageBroker.publishMessage(updateCustomerStatusMessage);
  |   await().atMost(5, SECONDS).until(customerStatusIsUpdated()) ;
  |   ...
  | }
  ```
[[}]]

[[{qa.testing.REST_API,persistence.json]]
# RESTAssured: REST API Full Journey testing

## Maven setup

  ```
  | <properties>
  |   <restassured.ver>5.2.0</restassured.ver>
  | </properties>
  | ...
  | <dependency>
  |     <groupId>io.rest-assured</groupId>
  |     <artifactId>json-schema-validator</artifactId>
  |     <version>${restassured.ver}</version>
  |     <scope>test</scope>
  | </dependency>
  | <dependency>
  |     <groupId>io.rest-assured</groupId>
  |     <artifactId>json-schema-validator</artifactId>
  |     <version>${restassured.ver}</version>
  | </dependency>
  ```

## REST Assured summary

  Gherkins standard BDD syntax "GIVEN > WHEN > THEN "<br/>
replaces RestAssured 1.0 syntax `given()...expect()... when()`
(still supported for compatibility)

  ```
  |given().param("x", "y")....
  | when().get("/lotto").
  | then().statusCode(400).
  |  and().body("lotto.lottoId", equalTo(6));
  |  └───┴─ syntactic sugar. Not really needed.
  ```

 Example:
 ```
 |import from io.restassured.RestAssured.*                   // Static imports, recomended
 |import from io.restassured.matcher.RestAssuredMatchers.*
 |import from org.hamcrest.Matchers.*                   // equalTo, hasItems
 |
 |import from io.restassured.module.jsv.JsonSchemaValidator.* // Json Schema validation Support !!!
 |                                                            // See original link to configure options
 |import from io.restassured.module.mockmvc.RestAssuredMockMvc.* // spring-mock-mvc unit test support
 |
 |
 |given()
 |  .param("key1", "val1")              // <·· set request params. REST Assured will
 |  .param("key2", "val2")                     automatically try  query|form format
 |  .param("key3")                      // <·· no value
 |  .param("list1", "val1", "val2")
 |  .param("list1", "val1", "val2")
 |  .cookie("favourite", "Red", "Green")// <·· Use new Cookie.Builder for details.
 |  .header("MyHeader", "Something") 
 |  .contentType("application/json")    // := ContentType.TEXT | 
 |                                      //    noContentType() (for no contentType at all)
 |                                      // 
 |
 |  .request().body("some body")        // <·· POST/PUT/DELETE requests
 |        //        └────┬────┘            request() is optional. It makes code more explicit
 |        //             └─···············    or new byte[]{42,1,..}
 |  .pathParam("pathKey1", "23")        // <·· GET /AAA/{pathKey1}
 |  // queryParam("queryParamName", "value2"). <·· explicit query or post
 |  // formParam("formParamName", "value1").
 |.when()
 |  .get("/AAA/{pathKey1}")
 |.then().
 |  .assertThat()                      // <·· Syntax Sugar. Not really needed.
 |  .body( 
 |     matchesJsonSchemaInClasspath(   // <·· Response matches JSON-schema
 |       "myschema.json")).
 |  .body(equalTo("{...}"))            // <·· Full body/content matching
 |  .body(                             // <·· key.valu path 
 |    "key1.%s[%d]",
 |    withArgs(key2, index2), equalTo(...))
 |  .and()                             // <·· and() not really needed. Improves reading
 |        .cookie("cookieName", "cookieValue" /*or containsString("cookieValue1")*/ )
 |  .and().statusCode(200)
 |  .and().statusLine("something" */)  // <·· alt 1 
 |  .and().statusLine(                 // <·· alt 2 
 |           containsString("something"))
 |  .and().contentType(ContentType.JSON)
 |  .and().header("headerName", "valueA")
 |  .and().header("Content-Length",
 |                 Integer::parseInt,  // <·· Use mapping function
 |                 lessThan(1000));
 |
 |   Ex: JSON Response like:           JSON assert:
 |   < {                               ...assertThat()....
 |   <   "lotto":{
 |   <    "lottoId":5,                      .body("lotto.lottoId", equalTo(5));
 |   <    "winning-numbers":[2,45,34],
 |   <    "winners":[{
 |   <      "winnerId":[23,54],        and().body("lotto.winners.winnerId", hasItems(23, 54));
 |   <      "numbers":[2,45,34]                                └── Groovy's GPath ───┘
 |   <    },{                                                      Not to be confused with Jayway's
 |   <      "winnerId":54,                                        JsonPath syntax
 |   <      "numbers":[52,3,12]
 |   <    }]
 |   <   }
 |   <   "price":12.12                 and().body("price", is(12.12f))
 |   < }                                                   └────┬───┘
 |                                                     or  is(new BigDecimal(12.12)
 |                                             NOTE: to convert to BigDecimal:
 |                                                given().config(
 |                                                  RestAssured.config().jsonConfig(
 |                                                   jsonConfig().numberReturnType(BIG_DECIMAL)))
 |                                             NOTE: is(12.12) fails (double, expected float)
 ```

## Recipes <!-- recipes { -->

### Validating JSON root documents with "$":  [[{]]
  ```
  |   tested body JSON:     RESTAssured test:
  |   [1, 2, 3]             body("$", hasItems(1, 2, 3));
  |
  |  > POST /greetXML                      given().parameters(
  |  > firstName=John                        "firstName", "John",
  |  > lastName=Doe                          "lastName", "Doe").when().post("/greetXML").
  |                                          then().
  |  < <greeting>                            assertThat().body(matchesXsd(xsd).
  |  <    <firstName>John</firstName>        body("greeting.firstName", equalTo("John")).
  |  <    <lastName>Doe</lastName>           body("greeting.lastName", equalTo("Doe"));
  |  < </greeting>                           └──────────────────┬────────────────────┘
  |                                 or  body(hasXPath("/greeting/lastName", containsString("Do"))
  |                                 or       hasXPath("/greeting/firstName[text()='John']"));
  ```
[[}]]

### Default values [[{]]

  ```
  |RestAssured.baseURI = "http://myhost.org";  // defaults to http://localhost
  |RestAssured.port = 80;                      // defaults to 8080
  |RestAssured.basePath = "/resource";         // get("/hello") => GET /resource/hello
  |RestAssured.authentication = basic(...);
  |RestAssured.rootPath = "x.y.z";             // body("x.y.z.keyX",..) => body("keyX",..)
  |
  |RestAssured.filters(..);               // List of default filters
  |RestAssured.requestSpecification = ..  // Default request specification
  |RestAssured.responseSpecification = .. // Default response specification
  |RestAssured.urlEncodingEnabled = ..    // should URL encode the parameters? def: true
  |RestAssured.defaultParser = ..         // default parser for response bodies
  |                                          if no registered parser can handle data
  |                                          of the response content-type
  |RestAssured.registerParser(..)         // Specify a parser for given content-type
  |RestAssured.unregisterParser(..)       // Unregister a parser for the given content-type
  |
  |RestAssured.reset();                   // Reset baseURI, basePath, port, root path, Auth.Scheme
  |                                          and url encoding to defaults
  |RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();
  ```
[[}]]

### Complex parsing and validation  [[{]]
(where REST Assured really starts to shine!)

  ```
  |    POST /shopping
  |
  |    <shopping>
  |  ··> <category type="grocery">
  |  ·     <item>Cream</item>
  |  ·     <item>Coffee</item>
  |  ·   </category>
  |  ·   <category type="supplies">
  |  ·     ...
  |  ·   </category>
  |  ·     ...
  |  · </shopping>
  |  ·
  |  · given().get(..).when().
  |  └ body(
  |    "shopping.category.find { it.@type == 'grocery' }.item", hasItems("Cream", "Coffee"));
  |     └──────┬────────┘
  |      Depth-first·> **.find
  |      shorcut in XML   └┬─┘ └────────────┬──────────┘
  |      document          ·      Groovy Closure
  |                        ·
  |    ┌─·················─┘
  |    find:    finds first item  matching a closure predicate
  |    findAll: finds all   items matching a closure predicate
  |    collect: collect the return value of calling a closure on each item in a collection
  |    sum:     Sum all the items in the collection
  |    max/min: returns the max/min values of the collection
  |
  |    Alternatively. Do not validate to Hamcrest. Keep processing manually
  |    String response = get("/shopping").asString(); // Get response body as String
  |    List<String> groceries = get("/shopping")
  |                             .path("shopping.category.find { it.@type == 'groceries' }.item");
  |
  |    POST /store                      when().get("/store").then()
  |    {
  |     "store":{                       .body(
  |      "book":[                          "store.book.findAll { it.price < 10 }.title",
  |         {"price":8.95, ... },          hasItems("title1", "title2"));
  |         {"price":8.99, ... },       Or ...
  |         ...                         final List<String> bookTitles =
  |                                     from(response).getList( // "from":JsonPath static import
  |      ]                               "store.book.findAll { it.price < 10 }.title");
  |     }
  |    }
  |
  |  when().get("/...").then().body(
  |   "store.book.author.collect { it.length() }.sum()", // Check: length sum of all-author-names > 50
  |   greaterThan(50));
  ```
  or ...
  ```
  |   body("store.book.author*.length().sum()", greaterThan(50))
  |                          ^ └──────^·····┐
  |    ┌─···················─┘              ·
  |   `*.`: Groovy spread operator, call function for
  |         each element in list returning new list with
  |         lengths results (sort of map)
  ```
  or:
  ```
  |  String response = get("/store").asString(); // get response as string
  |  int sumOfAllAuthorLengths = from(response)
  |      .getInt("store.book.author*.length().sum()");
  |  assertThat(sumOfAllAuthorLengths, is(53));
  ```
[[}]]

### Deserialization with Generics 3.3+ [[{]]

  ```
  |   [                                    final List<
  |     {                                   Map<String /* key: id, name, price, tags, ...*/, Object>
  |       "id": 2,                         > products = get("/products").as(new TypeRef<List<Map<String, Object>>>() {});
  |       "name": "An ice sculpture",
  |       "price": 12.50,                  assertThat(products, hasSize(2));
  |       "tags": ["cold", "ice"],         assertThat(products.get(0).get("id"   ), equalTo(2));
  |       "dimensions": { ... },           assertThat(products.get(0).get("name" ), equalTo("An ice sculpture"));
  |     },                                 assertThat(products.get(0).get("price"), equalTo(12.5));
  |     {
  |       "id": 3,                         assertThat(products.get(1).get("id"   ), equalTo(3));
  |       "name": "A blue mouse",          assertThat(products.get(1).get("name" ), equalTo("A blue mouse"));
  |       "price": 25.50,                  assertThat(products.get(1).get("price"), equalTo(25.5));
  |       ...
  |     }
  |   ]
  ```
[[}]]

### GETTING RESPONSE DATA [[{]]
  ```
  |  with (InputStream stream = get("/lotto").asInputStream()) { // Alt 1:
  |    ...
  |  }
  |  byte[] byteArray = get("/lotto").asByteArray(); // Alt 2
  |  String json = get("/lotto").asString(); // Alt 3
  ```
[[}]]

### Validate response, then extract data: [[{]]
  ```
  |  final String nextTitleLink =
  |    given().param("param_name", "param_value").  ┐
  |    when().get("/title").                        ├ validate response
  |    then().contentType(JSON).                    │
  |           body("title", equalTo("My Title")).   ┘
  |    extract().path("links.next.href");           ├ <· extract object from json tree
  |
  |    Alternatively, get all response:
  |    final Response fullRes = ...
  |       extract().response();
  |    final String
  |      s1 = fullRes.path("links.next.href"),
  |      s2 = fullRes.header("headerName");
  |    final Headers             allHeaders = response.getHeaders();
  |    final List<String>       sAllHeaders = response.getHeaders().getValues();
  |    final Map<String, String> allCookies = response.getCookies();
  |    final List<String>        sAllCokies = response.getCookies().getValues();
  |    final String              statusLine = response.getStatusLine();
  |    final int statusCode                 = response.getStatusCode();
  |    final ??? detailedCookie             = response.getDetailedCookie("cookie1"); // path, expiry date, ...
  ```
[[}]]

### Recipe: ReposnoseAware>Matcher [[{]]

  ```
  |  > GET /some-id
  |  < { "userId" : "some-id", "href" : ".../some-id" }
  |                  └─────┴─·· must be == ··┴─────┘
  |
  |  Test like:
  |  ....body("href", response -> equalTo(".../" + response.path("userId"));
  ```
[[}]]

### predefined matchers [[{]]

  ```
  |   get("/x").then().body("href", endsWithPath("userId"));
  |                   .body("href", and(                           // <·· composing ResponseAwareMatchers
  |                                  startsWith("..."),
  |                                  endsWithPath("userId")  ));
  ```
[[}]]
<!-- recipes } -->

## Measuring response time: (v 2.8+) <!-- { -->
* Added support to measure and test response time. Examples:
  ```
  | long timeInMs = get("/lotto").time()
  | long timeInSc = get("/lotto").timeIn(TimeUnit.SECONDS);
  | when().get("/lotto").then().time(lessThan(2000L)); // Milliseconds
  | when().get("/lotto").then().time(lessThan(2L), TimeUnit.SECONDS);
  | 
  |   WARN: time measurement should be performed when the JVM is hot!
  ```
<!-- } -->

## RESTAssured OAuth 1/2 Authentication [[{security.AAA,qa.testing]]

* Presetup (OAuth 1 and OAuth 2 when supplying token as query parameter):
  ```
  | $ editor pom.xml
  |   ...
  | + <dependency>
  | +   <groupId>com.github.scribejava</groupId>
  | +   <artifactId>scribejava-apis</artifactId>
  | +   <version>2.5.3</version>
  | +   <scope>test</scope>
  | + </dependency>
  ```

  ```
  |given().auth().oauth(..          )... // OAuth 1
  |given().auth().oauth2(accessToken)...            // OAuth 2. Put OAuth2 accessToken in a header.
  |given().auth().preemptive().oauth2(accessToken). // OAuth 2. explicit alternative
  |given().auth().oauth2(accessToken,               // OAuth 2. with token in query param (requirest Scribe)
  |                     OAuthSignature.QUERY_STRING).
  ```

## Other Authentication Schemas

  ```
  |  given().auth().form("John", "Doe").              // Form auth
  |  given().auth().digest("username", "password").   // Digest auth.
  |  given().auth().basic ("username", "password").   // Basic preemptive | Challenged Alt 1.
  |   when().get(...)....
  |  RestAssured.authentication =                     // Basic preemptive | Challenged Alt 2.
  |                 basic ("username", "password");
  ```
[[security.AAA,qa.testing}]]

[[{security.XSR]]
## Cross-site Request Forgery Support (CSRF)  

  Today it's common for the server to supply a CSRF token with
the response in order to avoid these kinds of attacks.

  REST Assured has support for automatically parsing and supplying the 
CSRF token to the server.  In order for this to work REST
Assured must make an additional request and parse (parts) of the website.

REST Assured supports two ways of providing CSRF tokens to the server:


1. submitting the CSRF token in a form
  ```
  |<form action="/users" method="POST">
  |  <input type="hidden" name="_csrf"                <·· CSRF token that "we" want to "forward"
  |    value="8adf2ea1-b246-40aa-8e13-a85fb7914341"/>     in new request
  |  ...
  |</form>
  ```

  ```
  |// RestAssuredConfig.config()
  |//    .csrfConfig(csrfConfig().with()
  |//       .csrfInputFieldName("_mycsrf"));  // <·· change default "_csrf" name
  |given(). csrf("/users/form", "_csrf")          // <·· Exec. GET request to /users, expecting
  |        formParam("firstName", "John")         //     as result a form as response with input field `_csrf`
  |        formParam("lastName", "Doe")
  | when().post("/users").
  | then().statusCode(200);
  ```

2. submitting the CSRF token as a header.

  ```
  | > GET /LOGIN

  | < <head>
  | <   <meta name="_csrf_header"
  | <      content="ab8722b1-1f23-4dcf-bf63-fb8b94be4107"/>
  | <   ...
  | < </head>
  ```

  ```
  |// RestAssuredConfig.config()
  |//    .csrfConfig(csrfConfig().with()
  |//       .csrfMetaTagName("_my_csrf_header") // <·· Change default "_csrf_header" name
  |//       .csrfHeaderName("MyHeader"));       // <·· Change default "X-CSRF-TOKEN" name
  |   RestAssuredConfig.config().
  | given().csrf("/login").  // fetch _csrf_header token to be included next as X-CSRF-TOKEN in POST
  |  when().post("/pageRequiringCSRF").
  |  then()....
  |
  | RestAssuredConfig.config()
  |   .csrfConfig(csrfConfig().with()
  ```
[[security.XSR}]]

## Object Mapping

* Jackson/2 for JSON, Gson, Johnzon for classpath and Jakarta EE or JAXB for XML
  (Refer to original doc)

## Specification Re-use

Use `RequestSpecBuilder` and/or `ResponseSpecBuilder`

  ```
  |  final RequestSpecBuilder builder = new RequestSpecBuilder();
  |  builder.addParam("parameter1", "parameterValue");
  |  builder.addHeader("header1", "headerValue");
  |  RequestSpecification requestSpec = builder.build();
  |  //          ┌────────┴─────────┘
  |  // Querying it later on
  |  // QueryableRequestSpecification queryable = SpecificationQuerier.query(requestSpec);
  |  // String headerValue = queryable.getHeaders().getValue("header");
  |  // String param = queryable.getFormParams().get("someparam");
  |
  |
  |  final ResponseSpecBuilder builder = new ResponseSpecBuilder();
  |  builder.expectStatusCode(200);
  |  builder.expectBody("x.y.size()", is(2));
  |  ResponseSpecification responseSpec = builder.build();
  |
  |  given().spec(requestSpec).                     // <·· RESUE REQUEST SPEC !!
  |          param("parameter2", "paramValue").     // <·· extend it
  |   when().get("/something").
  |   then().spec(responseSpec).                    // <·· REUSE RESPONSE SPEC !!
  |          body("x.y.z", equalTo("something"));   // <·· Extend it
  ```

## Filters: inspect&alter requests and responses.  [[{]]

* Filters can be used to implement custom authentication schemes,
session management, logging etc.

  ```
  |  import io.restassured.filter.Filter
  |  io.restassured.filter.OrderedFilter // v 3.0.2+
  |  given().filter(new MyFilter()). ..
  |  
  |  // NOTE: sometimes is useful to change the response. Do it like:
  |  final Response newResponse = new ResponseBuilder().
  |        clone(originalResponse).setBody("Something").build();
  ```

### ready to use filters
* `io.restassured.filter.log.RequestLoggingFilter`: print request spec details.
  ```
  | given().log().XXX().    // v1.5+
  |               └─┴─··· all │ params │ body │ headers │ cookies │ method │path
  |                       WARN: underlying HTTP Builder & HTTP Client can add extra
  |                       info (HEADERs, ...) not logged.
  |         log().ifValidationFails().
  |         get().
  |  then().log().XXX()                        // alt 1: log all responses
  |  then().log().ifError().                   // alt 2: log only on errors
  |  then().log().ifStatusCodeIsEqualTo(302).  // alt 3
  |  then().log().ifStatusCodeMatches(matcher).// alt 4
  |  then().log().ifValidationFails().
  |         onFailMessage("messageXXX").       // to be displayed on failure 4.5.0+
  |  ...
  |         └─┴─········· all | statusLine | headers | cookies
  ```


* `io.restassured.filter.log.ResponseLoggingFilter`:<br/>
   print response details if matching a given status code.
* `io.restassured.filter.log.ErrorLoggingFilter`   :
   print response body if error raised `[400... 599]`
[[}]]

## Session Support

  ```
  | given().sessionId("1234").            // Alt 1
  | given().cookie("JSESSIONID", "1234"). // Alt 2
  | RestAssured.sessionId = "1234";       // Alt 3
  | RequestSpecBuilder reqSpec =
  |    new RequestSpecBuilder()...        // Alt 4. Reusable spec
  |        setSessionId("value1").build();
  | SessionFilter sessionFilter =         // Alt 5. Session Filter v2.0.0+
  |              new SessionFilter();
  | given().filter(sessionFilter)....
  | 
  | RestAssured.config = RestAssured.config().
  |    sessionConfig(
  |     new SessionConfig()
  |       .sessionIdName("phpsessionid")); // Change JSESSIONID ··> phpsessionid
  | 
  | String sessionId = get("/").sessionId(); // Retrieve in response
  ```

### Session Filter (TODO)

## SSL for non-standard certificates or PKI setups.  [[{]]

* Relaxed verification setup:
  ```
  |  SSLPeerUnverifiedException
  |     given().relaxedHTTPSValidation()      // SSL
  |     given().relaxedHTTPSValidation("TLS") // TLS
  |    
  |  RestAssured.useRelaxedHTTPSValidation();
  ```
* Custom PKI (Certificate chains):
  ```
  |  given().keystore("/pathToJksInClassPath", pass). ..   // alt 1
  |  RestAssured.keystore("/pathToJksInClassPath", pass);  // alt 2
  |  RestAssured.trustStore(keystore);                           // alt 3. An keystore is already loaded
  ```
* SSL invalid hostname error "relaxing":
  ```
  |  RestAssured.config().sslConfig(sslConfig().allowAllHostnames());
  ```
[[}]]

## Disable URL Encoding
(Use case: URL already encoded)
  ```
  | String response = given().urlEncodingEnabled(false)
  |                    then().get("/v1/search?jql=project%20=%20BAM%20AND%20issuetype%20=%20Bug");
  ```

## Proxy Configuration
  ```
  |  given().proxy("localhost", 8888).  // Setup HTTP Proxy 2.3.2+
  |  given().proxy(host("localhost").withScheme("https")). // Setup HTTPs proxy 2.3.2+
  |  given().proxy(auth("username", "password")).when() .. // Setup HTTP proxy with preemptive basic auth.
  |
  |  RestAssured.proxy("localhost", 8888);     // Config HTTP proxy globally
  |  RequestSpecification reqSpec = new        // Config HTTP proxy in reusable request spec.
  |     RequestSpecBuilder().setProxy("localhost").build();
  ```

## Redirect DSL

  ```
  |  given().redirects().max(12).and()
  |    .redirects().follow(true).when(). ..
  ```

## Connection Config

  ```
  |  RestAssured.config = RestAssured.config().connectionConfig(
  |    connectionConfig().closeIdleConnectionsAfterEachResponse());
  ```

## FailureConfig 3.3.0+ (log, notify failures)

  It allows to get callbacks when validations fails.<br/>
  e.g.: get email in case of failure.


  ```
  | final ResponseValidationFailureListener emailOnFailure =
  |   (reqSpec, respSpec, resp) -> emailService.sendEmail(...);
  | given().
  |   config(RestAssured.config().failureConfig(
  |      failureConfig().with().failureListeners(emailOnFailure)))....
  ```

## FULL JOURNEY Example
  (WARN: Some code can be outdated)

  ```java
  |package com.mycompany.myproject.mymodule;

  |import static junit.framework.TestCase.assertTrue;
  |import static org.hamcrest.Matchers.*;

  |import static io.restassured.RestAssured.given;

  |import io.restassured.RestAssured;
  |import io.restassured.config.HttpClientConfig;
  |import io.restassured.path.json.JsonPath;
  |import io.restassured.response.Response;
  |import io.restassured.specification.RequestSpecification;
  |import junit.framework.TestCase;
  |import org.apache.http.client.HttpClient;
  |import org.apache.http.impl.client.SystemDefaultHttpClient;
  |import org.apache.http.params.HttpConnectionParams;
  |import org.apache.http.params.HttpParams;
  |import org.eclipse.jetty.http.HttpStatus;
  |import org.junit.Ignore;
  |import org.junit.Test;
  |import org.junit.BeforeClass;

  |import org.hamcrest.BaseMatcher;
  |import org.hamcrest.Description;

  |import java.util.Base64;
  |import java.util.Map;

  |public class FullJourneyTest {

  |  public static class RegexMatcher
  |  extends BaseMatcher<Object> {                        // <··· PRESETUP: CREATE CUSTOM REGEX MATCHER
  |    private final String regex;
  |    public RegexMatcher (String regex){
  |      this.regex = regex;
  |    }

  |    @Override
  |    public boolean matches (Object o){
  |      return ((String)o).matches(regex);
  |    }

  |    @Override
  |    public void describeTo(Description desc){
  |      desc.appendText("matches regex="+this.regex);
  |    }
  |  }

  |  public static classG Base64Matcher                     // <···· PRESETUP: CREATE CUSTOM Base64Matched
  |  extends BaseMatcher<Object> {

  |    public Base64Matcher(){}
  |    @Override
  |    public boolean matches (Object o){
  |      try {
  |        Base64.getDecoder().decode((String)o);
  |        return true;
  |      }catch (Exception e){
  |        return false;
  |      }
  |    }

  |    @Override
  |    public void describeTo (Description description){
  |      description.appendText("can be parsed as Base64");
  |    }
  |  }

  |  private static final String
  |    AUTH_HEADER_VALUE = "Bearer " + ServerConfig.apiKey;  // <·· PRESETUP: An API KEY is available for tests

  |  protected static
  |  RequestSpecification setupCommonHeaders() {             // <·· utility class. Setup headers.
  |    return given()
  |          .header("Authorization", AUTH_HEADER_VALUE)
  |          .header("Accept"       , "application/json")
  |          .header("content-type" , "application/json;charset=utf-8")
  |    .log().all();
  |  }

  |  private final String
  |    NAME="COMMUNITY_1", SYMBOL="SY1";

  |  private Response response;

  |  @BeforeClass
  |  public static void setup() {                           // <·· PRESETUP: Setup test URL... before each test
  |    RestAssured.port   = ServerConfig.serverPort;        //     Setup RestAssured config.
  |    RestAssured.basePath = "/";
  |    RestAssured.baseURI  = "http://localhost";

  |    HttpClientConfig clientConfig =
  |  RestAssured.config().getHttpClientConfig();
  |    clientConfig = clientConfig.
  |      httpClientFactory(
  |      new HttpClientConfig.HttpClientFactory() {
  |        @Override
  |        public HttpClient createHttpClient() {
  |          HttpClient rv =  new SystemDefaultHttpClient();
  |          HttpParams httpParams = rv.getParams();
  |          HttpConnectionParams                           // <·· Wait 5s max for a connection
  |  	.setConnectionTimeout(httpParams, 5 * 1000);
  |          HttpConnectionParams                           // <·· Set Default session Tiemout: 60s
  |              .setSoTimeout(httpParams, 60 * 1000);
  |          return rv;
  |        }
  |      });

  |    clientConfig = clientConfig                          // <·· This is necessary to ensure that client is reused
  |                   .reuseHttpClientInstance();
  |    RestAssured.config = RestAssured
  |                           .config()
  |                           .httpClient(clientConfig);
  |  }

  |  @Test
  |  public void A010_PutNewCommunityAndNewUserForPendingToMineCommunity() {
  |    String jsonBody1 = String.format("""
  |      {
  |        "name"  : "%s",
  |        "symbol": "%s",
  |      }
  |      """, NAME, SYMBOL) ;
  |    response = setupCommonHeaders().body(jsonBody1)
  |               .when().post("/Route/To/REST/API/01") ;
  |    System.out.println(response.body().prettyPrint());
  |    response.then()
  |      .statusCode(HttpStatus.ACCEPTED_202)
  |      .body("size()", is(5)                      )
  |      .body("id"    , not(isEmptyString())       )
  |      .body("pubkey", not(isEmptyString())       ) //  get sure it's not empty
  |      .body("pubkey", new RegexMatcher("^{65}$") ) // and get sure that it matches Regex
  |      .body("pubkey", new Base64Matcher()        ) // and get sure it is Bas64 encoded
  |      .body("name"  , equalTo(NAME)              )
  |      .body("symbol", equalTo(SYMBOL)            )
  |    ;
  |    String NEW_ID = response.getBody().jsonPath().get("id") ;

  |    // Next related test to execute synchronously after fetching NEW_ID
  |    final String jsonBody2 = String.format("""
  |      {
  |        "FK_ID": "%s",
  |       ...
  |      }""", NEW_ID);
  |    response = setupCommonHeaders().body(jsonBody2)
  |       .when(). post("/Route/To/REST/API/02") ;
  |    ...
  |  }
  |}
  ```

## What's new

* 5.2
  * Much improved Cross-site request forgery support. Example  [[{security]]
  ```
  |  given().csrf("/users").                // <·· make a GET request to /users
  |                                         //     to fetch page containing the  CSRF token.
  |                                         //     Rest Assured will then automatically try to
  |                                         //     find the input field that contains the CSRF token
  |          formParm("firstName", "John").
  |          when().post("/users").         // <·· and include it in the POST to /users.
  |          then().statusCode(200);
  ```

                                                               [[security}]]
* 5.0
  * Use Groovy 4.0 under the hood.
* 4.5
  * Introduced rest-assured bom project for maven.
  * Add onFailMessage to more easily  distinguish between failed tests
  ```
  |  when().get().then()
  |    .onFailMessage("Some specific message")
  |    .statusCode(200);
  ```
* 4.2
  * Allows to blacklist displaying headers in request|response log.
  ```
  | given().config(config().logConfig(logConfig().blacklistHeader("Accept"))). ..
  ```

* 4.0
  * Allows to specify multi-expectation body with arguments. Examples:
  ```
  | when().get("/jsonStore").
  | then()
  | .rootPath("store.book.find { it.author == '%s' }")
  | .body(
  |   "price", withArgs("Nigel Rees"  ), is(8.95f),
  |   "price", withArgs("Evelyn Waugh"), is(12.99f)
  | );
  ```
* 3.2
  * New Spring Web Test Client module to test Spring Reactive Web stack components.
    for example, Spring (Webflux) Controllers.
  * OSGi support.
* 3.1
  * Allow querying (extracting values out of) a request specification without
    using a filter by using `io.restassured.specification.SpecificationQuerier`. For example:
    ```
    | RequestSpecification spec = ...
    | QueryableRequestSpecification queryable = SpecificationQuerier.query(spec);
    | String headerValue = queryable.getHeaders().getValue("header");
    | String param = queryable.getFormParams().get("someparam");
    ```
  * Lot's of improvements to filters (FilterableRequestSpecification). Example:
    * FilterableRequestSpecification#path: change request-path from a filter
    * FilterableRequestSpecification#removeQueryParam to remove parameters.
    * Get undefined path parameter placeholders
    * ...
  * Automatically adds supports for spring rest docs path parameter documentation
    if spring-restdocs-mockmvc is in classpath.

* 3.1
  * Allow a mapping function when validating headers. Example:
  ```
  | when().get("/something").then()
  |   .header(
  |       "Content-Length",
  |       Integer::parseInt,  // <··· Map Header to Integer
  |       lessThan(1000) );   // <··· Then check that is is smaller than 1000
  ```

[[}]]

# TODO [[{PM.TODO]]
## Facebook Infer <https://fbinfer.com/> (Static analysis Java/C/...)
## Scrutinizer
## StopBugs
## Eclipse Static Code Analasys [[{]]
   ```
   | Eclipse → Properties → Java → Compiler → Errors/Warnings → Null analysis:
   | * Null pointer access
   | * Potential null pointer access
   | * Redundant null check:
   |     - Include 'assert' in null analysis
   |     - Enable annotation-based null analysis
   |     - Violation of null specification
   |     - Conflict between null annotations an null inference
   |     - Unchecked conversion from non-annotated type to @NonNull type
   |     - Problems detected by pessimistic analysis fro free type variables
   |     - Unsafe "@Nonnull" interpretation of the free type variable from library
   |     - Redundant null anotation:
   |     - "@NonNull" parametere not annotated in overriding method
   |     - Missing "@NonNullByDefault" annotation on package
   |       - Use default annotations for null specifications (configure)
   |       - Inherit null annotations
   |       - Enable syntatic null analisys for fields
   |     - Treat above errors like fatal compile erros
   |       (make compiled code not executable)
   ```
[[}]]

## SpotBug examples
@[https://spotbugs.readthedocs.io/en/latest/filter.html]

## Mockito [[{qa.testing.101,01_PM.TODO]]
* Top voted Java testing framework in StackOverflow
* Top 10 most-widely used Java amongt 30.000 inspected projects.
[[}]]

## JfrUnit [[{qa.testing,scalability.profiling,01_PM.TODO]]
@[https://github.com/moditect/jfrunit]
* JUnit extension for asserting JDK Flight Recorder events
  emitted by an application identifying performance regressions
  (e.g. increased latencies, reduced throughput).
* JfrUnit supports assertions not on metrics like latency/throughput
  themselves, but on indirect metrics which may impact those.
  * memory allocation,
  * database IO
  * number of executed SQL statements
  * ...

- JfrUnit provide means of identifying and analysizing such issues in
  a reliable, environment independent way in standard JUnit tests,
  before they manifest as performance regressions in production.
[[}]]

## Tablasco [[{qa.testing.data,architecture.batch,01_PM.low_code,01_PM.TODO]]
@[https://github.com/goldmansachs/tablasco]
* (By Goldman Sasch) JUnit rule that adds table verification to unit
  tests. For software products that produce large amounts of data, this
  tool can help to create automated tests that are both comprehensive
  and easy to maintain. Users only need to adapt their existing data to
  a table format that Tablasco understands. “Every test produces a
  color-coded HTML break report, which helps users quickly identify the
  issue,” said Barry, a vice president in the Technology Division.
  Furthermore, Tablasco features automated baseline management,
  allowing users to easily update the baseline file of a failing test.

* JUnit rule for comparing tables and Spark module for comparing large data sets.
[[}]]

[[PM.TODO}]]
