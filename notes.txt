●  Apropos:
- Visit next Web site for a great experience:
  https://earizon.github.io/txt_world_domination/viewer.html?payload=../JAVA/notes.txt

- If you want to contribute to great gistory of this
  document you can take the next flight to:
@[https://www.github.com/earizon/JAVA]
  Your commits and pull-request will be immortalized
  in the Pantheon of the Unicode Gods.
────────────────────────────────────────────────────────────────────────────────


This "cheat-sheet with steroids" presents an always-growing set of
"TOP Java recipes" well ordered&amp;classified extracted from
DZone/InfoQ/Redhat Developrs/Medium/bealdun/ articles, github code,
... as well as author's own experience in different projects.

[[{$div]]
[[{<02_doc_has.ext_resource]]
● External Links
-<a href="https://docs.oracle.com/javase/specs/">Lang&amp;VM specs</a>
-<a href="https://docs.oracle.com/javase/8/docs/api/index.html">API</a>
-<a href="https://adoptopenjdk.net/">Adpot OpenJDK prebuilt binaries</a>
https://hg.openjdk.java.net/jdk/jdk
-<a href="https://hg.openjdk.java.net/jdk/">OpenJDK@Mercurial</a>
- @[https://wiki.openjdk.java.net/]
- @[https://openjdk.java.net/]

-<a href="https://zeroturnaround.com/wp-content/uploads/2014/06/jtnt-mindmap.png">JAVA MIND-MAP</a>
-<a href="https://en.wikipedia.org/wiki/List_of_Java_virtual_machines">(Active) Java JVM List</a>
-<a href="https://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Ftasks%2Ftask-improve_code_quality.htm&cp=1_3_9">Eclipe Tools for [QA]</a>
-<a href="https://picodotdev.github.io/blog-bitix/tags/java/">Excellent Java Blog (spanish)</a>
-<a href="https://openjdk.java.net/jeps/0">JAVA Enhancements proposals</a>
-<a href="https://github.com/douglascraigschmidt/LiveLessons">Douglas Craigs Schmidt Java Lessons:</a>
-<a href="https://github.com/akullpp/awesome-java">Awesome Java</a>

-@[https://java-source.net/] Collections of Production-ready software developed with Java,
   from DDBBs, caches, servers, ...
──────────────────────────────────────────
● Bibliography
- Effective Java 3rd Edition, Joshua Bloch
  ISBN-10: 0134685997
  ISBN-13: 978-0134685991

-  Java Performance: The Definitive Guide, by Scott Oaks
   ISBN-10: 1449358454
   ISBN-13: 978-1449358457
[[}]]

[[{java_lang.101,<02_doc_has.ext_resource,scalability.101,qa.101,01_PM.WiP]]
#[java_donts]
● JAVA DONT's
• Avoid Nulls, prefer final:
  WRONG:
  ========================
  SomeClass instance = null;
  if (condition1) {   ← Initialization depends on runtime checks (condition1/2/...).
      instance = val1;   We can forget to add some condition wrongly leaving
  }                     instance to a false null. (Probably in a later
  if (condition2) {   ← interaction, weeks or months after first implementatio
      instance = val2;   when instance is not fresh in our memory)
  }
                      ← At this point we forgot to check for condition3, or maybe
                        condition3 didn't apply at code writing, but appear later on
                        after some unrelated change.
  ...
  serviceX.functionN(..., instance, ...) ← At this point instance can be undefined

  RIGHT:
  ========================
  final int instance;  ← "final" keywords force compiler to check every possible execution
  if (condition1) {     condition and fail to compile is some branch does not initiliaze
      instance = val1;   instance properly.
  }                     - Final values are safer (to and developer mistakes concurent code).
  if (condition2) {
      instance = val2;   - Final values makes JIT happier.
  }
  ...
  servX.funcN(instance) ← At this point compiler will abort if there is some
                          execution branch where instance rest un-initialized.

  See also:
  - Inmmutable Objects are faster (and safer)
  @[https://docs.oracle.com/javase/tutorial/essential/concurrency/immutable.html]
   (A final variable is the simplest example of an immutable object)

• Catch blocks must rethrow if the exception can not be fixed on the catch block.
  HINT: 99% of times it can NOT be fixed on the catch block.

  WRONG                        RIGHT
  ========================     ========================
  try { ...                    try { ...
  } catch (IOException e) {    } catch (IOException e) {
      e.printStackTrace();         throw new RuntimeException(e);
  }                            }

  The correct "right" code looks weaker, since the exception is propagated ... and that's
  a good thing, because the error has not been fixed, but some other piece of code (or maybe
  final user) will be notified. In the "wrong" code the code is just hidden.  This will
  trigger undefined behaviour, null pointers, nightmares and developer's non-paid extra hours.

• Avoid Strings as much as possible. You are converting an strongly typed
  language in a weak runtime one.
  If forced to use strings, try to protect them with (Checkers framework) @Fenum("country")
  @[#checker_framework_summary]

• Avoid huge interfaces. Prefer small, decoupled ones, with few exposed methods
  decoupled interfaces related to security from storage from cache from ...

• Avoid interfaces that will ever be implemented by a single class, specially if such
  class is a data-like one with all inmutable (final) fields. Data classes can be
  considered interfaces on themself since they indicate the contract for the data.

• Avoid checked exceptions. It was an error in the initial design of the Java language.
  Each time a checked exception is found convert to a runtime (subclass) exception.
  More info at: @[https://phauer.com/2015/checked-exceptions-are-evil/]

[[}]]

● Who-is-Who [[{]]
(Forcibly incomplete but still quite pertinent list of core developers and companies)
- James Arthur Gosling:  Founder and lead-designer of the Java Programming Language
  @[https://en.wikipedia.org/wiki/James_Gosling]

- Joshua J. Bloch:
  @[https://en.wikipedia.org/wiki/Joshua_Bloch]
  - Author of the book "Effective Java" (a must read)
    and co-author of two other books:
    - Java Puzzlers (2005)
    - Java Concurrency in Practice (2006)
  - Led the design and implementation of numerous
    Java platform features, including the
    Java Collections Framework, the java.math package,
    and the assert mechanism.

- Julien Viet:
 @[http://www.julienviet.com/]
  Core developer of VertX, crash (http://www.crashub.org/),
  and many other interesting Java software.
  @[https://github.com/vietj?utf8=%E2%9C%93&tab=repositories&q=&type=source]

- Ben Evans:
  - jClarity Co-founder.
  - Java Champion, author, speaker, consultant
  - voting member on Java’s governing
  - Author of 5 books
    - “The Well-Grounded Java Developer”,
    - new editions of “Java in a Nutshell”,
    - “Java: The Legend” and “Optimizing Java”.
    - Track lead for Java / JVM at InfoQ.
  @[https://www.jbcnconf.com/2019/infoTalk.html?id=5c64983638da16483151bb37]
  IMPLEMENTING A SIMPLE JVM IN JAVA AND RUST
  ... I will explain how we might start to implement a JVM from scratch.. then
   we will show how the Rust programming language provides a good alternative
   implementation language for our simple JVM. We will showcase some basic Rust
   language features and show how they can be used to provide a version of our
   JVM that is much cleaner and easier to understand, even if you've never
   seen Rust code before!"""

- Emmanuel Bernard: Distinguished Engineer and Chief Architect Data at
  Red Hat (middleware). His work is Open Source. He is most well known for his
  contributions and lead of the Hibernate projects as well as his contribution
  to Java standards. His most recent endeavour is Quarkus (A Kubernetes Native
  Java stack tailored for GraalVM and OpenJDK HotSpot, crafted from the best of
  breed Java libraries and standards).


- Chad Arimura, vice president of Java Developer Relations at Oracle.

- https://community.oracle.com/community/groundbreakers/java/java-champions
- https://blogs.oracle.com/java/new-java-champions-in-2017
[[}]]

● What's new [[{<02_doc_has.ext_resource,async/reactive,java_lang.debugging,01_PM.troubleshooting]]
● v.17 2021-09-14
- 1st long-term support (LTS) release after JDK 11 (2018).
- 14 JEPs includes:
  - 409: Sealed Classes
         package com.example.geometry;

         public abstract sealed class Shape           ← Syntax 1: Permitted classes in
             permits com.example.polar.Circle,                    different file
                     com.example.quad.Rectangle,
                     com.example.quad.simple.Square { ... }


         abstract sealed class Root { ...             ← Syntax 2: Permitted classed inside
             final class A extends Root { ... }                   parent class.
             final class B extends Root { ... }
             final class C extends Root { ... }
         }

  - 412: Foreign Function⅋ Memory API (Incubator)
         API by which Java programs can interoperate with code and
         data outside of the Java runtime. By efficiently invoking foreign
         functions (i.e., code outside the JVM), and by safely accessing
         foreign memory (i.e., memory not managed by the JVM), the API enables
         Java programs to call native libraries and process native data
         without the brittleness and danger of JNI.
         - Goals:
           - Ease of use, replacing JNI with better, pure-Java development model.
           - Performance: comparable or better than JNI and sun.misc.Unsafe.
           - Generality : operate on different kinds of foreign memory
                          (e.g., native memory, persistent memory, and managed
                          heap memory) and, over time, to accommodate other platforms
                          (e.g., 32-bit x86) and foreign functions written in languages
                          other than C (e.g., C++, Fortran).
           - Safety     :


  - 306: Restore Always-Strict Floating-Point Semantics
         Goals:
         - Ease development of numerically-sensitive libraries, including
           java.lang.Math and java.lang.StrictMath.

    Provide more regularity in a tricky aspect of the platform.

  - 356: Enhanced Pseudo-Random Number Generators            [[{security.cryptography}]]
  - 403: Strongly Encapsulate JDK Internals
         it will no longer be possible to bypass strong encapsulation
         via --illegal-access flag.
  - 406: Pattern Matching for switch (Preview)
  - 407: Remove RMI Activation
  - 410: Remove the Experimental AOT and JIT Compiler
  - 411: Deprecate the Security Manager for Removal
  - 414: Vector API (Second Incubator)
  - 415: Context-Specific Deserialization Filters

  - 382: New macOS Rendering Pipeline
  - 391: macOS/AArch64 Port
  - 398: Deprecate the Applet API for Removal
<hr/>
● v.15 2020-09-15
@[https://www.itprotoday.com/programming-languages/java-15-gains-garbage-collection-text-block-features]

-   RECORDS!!!: non-verbose inmutable classes.
    Ex.:
    Alt 1: short writing
    record Person (String name, int age) { }
    Alt 2: Validating constructor
    record Person (String name, int age) {
      Person {           ←  (optional) constructor can NOT compute state, only validate|throw
        if (age < 0)
          throw new IllegalArgumentException("Too young");
      }
    }

    var john = new Person ("john", 76);

    Records:
    - can NOT have any additional (internally computed) private or public instance fields.
    - can NOT extend classes.
    - are ALWAYS FINAL (cannot be extended),

- production ready ZGC low-latency garbage collector.
  "...Oracle expects ZGC to be quite impactful for a multitude of workloads,
   providing a strong garbage collection option for developers..."

- text block:(JEP 378): make it easy to express strings spanning several lines
  ("templates, ...")

- JEP 360: Sealed Classes (Preview)
  Avoid to extend class not designed to be extended.
  (control how class is used by third parties)

- JEP 383: Foreign Memory Access API: (Preview)
  - access "foreign"(outside Java HEAP) memory.
    Part of Project Panama, trying a better connection with native
    (C/Assembler) code.
<hr/>
● v.14 2020-03-??
https://www.infoq.com/news/2019/12/java14-feature-freeze/
 └ More container awareness...
   - NUMA container support added to hotspot (JDK-8198715)
   - Add Container MBean to JMX (JDK-8199944)

 └  Record-types in Java 14:
   https://www.infoq.com/articles/java-14-feature-spotlight/
   Records aim to enhance the language's ability to model
   "plain data" aggregates with less ceremony.

 └ Shenandoah GC
   Shenandoah GC in JDK 14, Part 1: Self-fixing barriers
   https://developers.redhat.com/blog/2020/03/04/shenandoah-gc-in-jdk-14-part-1-self-fixing-barriers/
   By Roman Kennke March 4, 2020
   The development of the Shenandoah Garbage Collector (GC) in the
   upcoming JDK 14 has seen significant improvements. The first one
   covered here (self-fixing barriers) aims to reduce local latencies
   that are spent in barrier mid- and slow paths. The second will cover
   concurrent root processing and concurrent class unloading.

   https://developers.redhat.com/blog/2020/03/09/shenandoah-gc-in-jdk-14-part-2-concurrent-roots-and-class-unloading/
   This article discusses concurrent roots processing and concurrent
   class unloading, both of which aim to reduce GC pause time by moving
   GC work from the pause to a concurrent phase.

<hr/>
● v 12,13
@[https://www.infoq.com/news/2019/06/java13-feature-freeze/]
@[https://developers.redhat.com/blog/2019/06/27/shenandoah-gc-in-jdk-13-part-1-load-reference-barriers/]
@[https://developers.redhat.com/blog/2019/06/28/shenandoah-gc-in-jdk-13-part-2-eliminating-the-forward-pointer-word/]
@[https://developers.redhat.com/blog/2019/07/01/shenandoah-gc-in-jdk-13-part-3-architectures-and-operating-systems/]
 └ More container awareness...
   - add container support to jhsdb command (JDK-8205992)
   - Flight Recorder impovements for containers (JDK-8203359)
   - Improve container support when Join Contollers option is used (JDK-8217766)
   - Impove systemd slice memory limit suppot (JDK-8217338)
   - JFR jdk.CPUInformation event epots incorrect info. when running in  [[{devops.containarization]]
     Docker container (JDK-8219999)
<hr/>
● v.11(LTS) 2018/09
@[https://www.journaldev.com/24601/java-11-features]
@[https://www.infoq.com/news/2018/09/java11-released]
- More container awaeness...                                             [[{devops.containarization]]
  - Remove -XX:+UnlockExperimentalVMOptions, -XX:+UseGroupMemoryLimitFoHeap (JDK-8194086)
  - jcmd -l and jps commands do not list JVMs in Docker containers (JDK-8193710)
  - Container Metrics (-XshowSettings:system) (JDK-8204107)
  - Update CPU count algorithm when both cpu shares and quotas are used (JDK-8197867)
    --XX:+PrefectContainerQuotaForCPUCount

New major features:
- Autocompilation(JEP 330). Next code will execute:
  $ java someFile.java

- New string methods:
  - isBlank(): true for Empty or only white spaces strings
  - lines()  : returns string[] that collects all substrings split by lines.
    System.out.println(
       "JD\nJD\nJD".str.lines().collect(Collectors.toList())
    );
  - strip()         : similar to trim() but unicode-aware
    stripLeading()
    stripTrailing()
  - repeat(int n)     : repeats string  n times.


- Local-Variable Syntax for Lambda Parameters (JEP 323)
  (var s1, var s2) -> s1 + s2
  - While it's possible to  just skip the type in the lambda
    it becomes a need when for annotations like @Nullable

- Nested Based Access Control
  (fix some issues when using (discouraged-)reflection.

- Dynamic Class-File Constants(JEP 309)
  - class-file format now extends support a new constant pool form:
    - CONSTANT_Dynamic , reduce the cost and disruption of developing
      new forms of materializable class-file constraints.

- Epsilon: A No-Op Garbage Collector(JEP 318):
  - Experimental
  - Unlike the JVM GC which is responsible for allocating memory
    and releasing it, Epsilon only allocates memory. Useful for:
    - Extremely short lived jobs
    - Performance testing
    - Memory pressure testing
    - VM interface testing
    - Last-drop latency improvements
    - Last-drop throughput improvements

- Remove the JavaEE and CORBA Modules(JEP 320):
  java.xml.ws, java.xml.bind, java.activation,
  java.xml.ws.annotation, java.corba, java.transaction,
  java.se.ee, jdk.xml.ws, jdk.xml.bind
   WARN : EE modules contain the support for JAXB and SOAP,
          still in relatively widespread use.
        - Check carefully whether build scripts need to
          be modified.

- Flight Recorder(JEP 328)
  - profiling tool gathering diagnostics and profiling data
  - negligible performance overhead (<1%):
    - Can be used in production

- HTTP Client (JEP 321)
  - HTTP/1.1, HTTP/2 and WebSockets
  - Designed to improve overall performance of
    sending requests by a client and receiving
    responses from the server.

- TLS 1.3

- Convenient Reading/Writing Strings to/from Files
  - readString()
  - writeString()
  Path path = Files .writeString (
    Files.createTempFile("test", ".txt"),
    "This was posted on JD");
  System.out.println(path);
  String s = Files .readString (path);
  System.out.println(s); //This was posted on JD

- ChaCha20,Poly1305 Crypto (JEP 329)            [[{security.cryptography]]
  - implemented in the SunJCE provider.

- Improve (string and array)Aarch64 processor Intrinsics(JEP 315)
  - implement also new intrinsics for
    (java.lang.Math) sin, cos, and log functions.

- ZGC:(JEP 333)
  - Scalable Low-Latency Garbage Collector
  - Experimental
  - low latency GC.
  - sub-10ms pause times, less than 15% perf.penalty.
- Deprecate Nashorn JS Engine(JEP 335)
<hr/>
● v.10 (2018/03)
- More container awareness...                                 [[{devops.containarization]]
  - Improve heap memory allocations (JDK-8196595):
    o --XX:InitialRAMPercentage, --X:MaxRAMPercentage and -XX:MinRAMPercentage
      --XX:InitialRAMFraction  , --X:MaxRAMFraction   and -XX:MinRAMFraction   deprecated
  - Total number of CPUs available to the Java Process calculated from
    --cpus, --cpu-shares, --cpu-quota (JDK-8146115)
    o Use --XX:-UseContainerSupport to return to the old behaviour
    o # processors that the HVM will use internally -XX:ActiveProcessorCount
  - Attach in linux became elative to /proc/pid/root and namespace aware (jcmd, jstack,...)

  - Read also: https://aboullaite.me/docker-java-10/
    JVMs before 10 had been implemented before cgroups, hence not
    optimized for executing inside a container.

- Application Data-Class Sharing (JEP ???)
  -  extends existing Class-Data Sharing ("CDS")
     for allowing application classes to be placed in
     the shared archive in order to improve startup
     and footprint.
- Parallel Full GC for G1
  - improves G1 worst-case latencies
- Garbage Collector Interface
  - improves source code isolation of different GCs.
- Consolidate JDK Forest into a Single Repository
- Local-Variable Type Inference
  - declarations of local variables with initializers
  - introduces var
- Remove Native-Header Generator Tool (javah)
  superseded by superior functionality in javac.
- Thread-Local Handshakes:
  - Allows to execute a callback on threads without
    performing a global VM safepoint. Makes it both
    possible and cheap to stop individual threads and
    not just all threads or none.
- Time-Based Release Versioning
- Root Certificates, providing a default set of root
  CAs in the JDK.
- Heap Allocation on Alternative Memory Devices:
  - enables the HotSpot VM to allocate the Java object
    heap on an alternative memory device, such as an
    NV-DIMM, specified by the user.
- Experimental Java-Based JIT Compiler Graal:
  - Linux/x64 platform only

- Additional Unicode Language-Tag Extensions

- Removed Features and Options:
<hr/>
● v.9(2017/09)                                                  [[{devops.containarization]]
  └ --XX:ParallerGCThreads and --XX:CICompilerCount are set based on
    Containers CPU limits (can be overriden)
    - Calculated from --cpuset-cpus

  └ Memory Configuration for containers
    -XX:+UnlockExperimentalVMOptions
    -XX:+UseGroupMemoryLimitFoHeap
    - set -XX:MaxRAMFraction to 2 (default is 4)


- Java Platform Module System:
  - based on Project Jigsaw
  - divides the JDK into a set of modules for
    combining at run, compile, or build time.
  - enabling understanding of dependencies across modules.
  - allows developers to more easily assemble and
    maintain sophisticated applications.
  - allows to scale down to smaller devices.
  - improves security and performance.
  - aspects include:
    - application packaging
    - JDK modularization
    - reorganizing source code into modules.
    - Build system is enhanced to compile modules
      and enforce module boundaries at build time.
  (Java 9 allows illegal reflective access to help migration)

- Reactive Streams:
(https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#specification)
  is a small spec, also adopted in Java 9, that defines the interaction
  between asynchronous components with back pressure. For example a
  data repository — acting as Publisher, can produce data that an
  HTTP server — acting as Subscriber, can then write to the
  response. The main purpose of Reactive Streams is to allow the
  subscriber to control how fast or how slow the publisher will produce
  data.

- ahead-of-time (AoT) compilation (experimental)
  - improve startup time, with limited impact on peak performance.
- REPL (read-eval-print loop)
  - jShell: interactively evaluates statements "a la script".
    - tab completion
    - automatic addition of needed terminal semicolons.
    - jShell API for IDE integration.

  - jShell: interactively evaluates statements "a la script".

- Streams API Enhancements
  - Java 8 Stream API allows processing data declaratively
    while leveraging multicore architectures.
  - Java 9 adds methods to conditionally take and drop items
    from Stream, iterate over Stream elements, and create a
    stream from a nullable value while expanding the set of
    Java SE APIs that can serve as Streams sources.

- Code cache can be divided in Java 9
  - code cache can now be divided into segments to
    improve performance and allow extensions such as
    fine-grained locking resulting in improved sweep
    times
- (Datagram Transport Layer Security) DTLS security API
  - prevent eavesdropping, tampering, and message forgery
    in client/server communications.

- Java 9 deprecates and removes:
  - Applet API and appletviewer (alternative: Java Web Start)
  - Concurrent Mark Sweep (CMS) GC.
  - JVM TI (Tool Interface) hprof (Heap Profiling) agent,
    superseded in the JVM.
  - jhat tool, obsoleted by superior heap visualizers and analyzers.
<hr/>
● JAVA 8                                              [[{devops.containarization]]
  └ 8u131  First version to support Containers
      WARN : Do not use any version below that.
  TODO:
  @[https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html]
  @[https://www.qwant.com/?q=what+new+java+8]

  - TLS enh. Backported to 1.8 (HTTP2)
  @[https://www.infoq.com/news/2020/04/tls-alpn-java8/]
[[}]]


[[$div}]]
<div groupv >
● JVM internals
[[{monitoring.101,jvm,monitoring.jvm,devops.containarization,01_PM.troubleshooting,01_PM.TODO]]
● JVM Troubleshooting and Monitoring
- Flight Recoder:

- Built-in tools in JDK:           - Docker commands:
  - jstat                            - stats
  - jcmd                             - inspect
  - jmap (Not recomended)            - top
  @[https://github.com/tldr-pages/tldr/blob/master/pages/common/jmap.md]
  - jhat ...
  - jstack
  @[https://github.com/tldr-pages/tldr/blob/master/pages/common/jstack.md]

                                   - Container aware tools
- Expose JMX port                    - ctop
  - VisualVM                         - dstat
  - jConsole
                                   - CAdvisor
- Micrometer@[#micrometer_summary] - Prometheus
- Others: New Relic, Stackiy,      - Docker EE, Datadog, Sysdig,...
  AppDynamics, Dynatrace, ...

[[}]]

[[{JVM,java_lang.profiling,architecture.real-time]] #[JVM_safepoints]
● JVM Safepoints
- @[http://psy-lob-saw.blogspot.com/2015/12/safepoints.html]    [TODO]
   - Definition: Mutator threads: threads which manipulate the JVM heap.
     all Java Threads are mutators, Non-Java (native?) threads may also be
     regarded as mutators when they call into JVM APIs which interact with the heap.
   - Safepoint:
     - range of execution where the state of the executing thread
       is well described since thread is NOT interacting with the heap:
     - used to put mutator threads on hold while the JVM 'fixes stuff up'
     - particularly useful to let JVM examine|change the heap (GC, ...)
       (no objects still alive and referenced from the stack)
   - thread is at safepoints when:
     - thread de-scheduling events: thread blocked on lock/synch.lock, waiting on a monitor, parked,
       or blocked on blocking-IO.
     - thread is executing JNI code.
   - thread is NOT at safepoints when:
     - executing bytecode (maybe, but not for sure).
     - thread interrupted (by the OS) while not at a safepoint.
   - JVM cannot force any thread into a safepoint state but ...
     JVM can stop threads from leaving a safepoint state.
     Q: How then bring ALL threads into a safepoint:
     A: Java threads poll a 'safepoint flag' (global or thread level) at 'reasonable' intervals
        and transition into a safepoint state (thread is blocked at a safepoint) when active.
        Q: how to avoid waste time checking if C1/C2 (client/server) JIT compilers need to stop?
           how to keep safepoint polls to a minimum.
        A: considerations combined lead to the following locations for safepoint polls:
           - Between any 2 bytecodes while running in the interpreter (effectively)
           - On 'non-counted' loop back edge in C1/C2 compiled code
           - Method entry (Zing,...) or exit (OpenJDK,...) in C1/C2 compiled code.
    Ex:
    public class WhenWillItExit {
      public static void main(String[] argc)
        throws InterruptedException {
        const UP = Integer.MAX_VALUE;
        final Thread t = new Thread(() -> {
          long l = 0;
          for (int i = 0; i < UP ; i++) {     ┐  Result:
            for (int j = 0; j < UP ; j++) {   │
              if ((j ⅋ 1) == 1) l++;          ├ long-type loops: 'uncounted' code.    safepoints injected at each loop.
            }                                 │  int-type loops:   'counted' code. No safepoints injected.
          }                                   ┘                  -   (Much) Better performance   BUT ...
          System.out.println("How Odd:" + l);                        other threads forced to suspend at their
        });                                                          next safepoint operation.
        t.setDaemon(true);                    ┐
        t.start();                            ├  Expected: exit in ~5 seconds.
        Thread.sleep(5000);                   ┘  Result  : no safepoints means threads, JMX connections, ...
      }                                                    will have to expect to daemon thread to exits to
    }                                                      be able to reach a global safepoint. Use -Xint to
                                                           disable C1/C2 compilation or replace int → long
                                                           in loop index to respect the 5 second behaviour.

    (See original source for many interesing details on safepoint tunning)

    SUMMARY:
     - Safepoint polls are dispersed at fairly arbitrary points and depending
       on execution mode, mostly at uncounted loop back edge or method return/entry.
     - Bringing the JVM to   GLOBAL safepoint is high cost
   ☞ - For real-time applications,  it's critical to know about safepoints
       avoiding 'counted' code.
     -XX:+PrintApplicationStoppedTime will log contained safepoint pauses.

  Problems with (most) Sampling Profilers :
- @[http://psy-lob-saw.blogspot.com/2016/02/why-most-sampling-java-profilers-are.html]
  - A large number of samples needed to get statistically significant results.
  - profiler should sample all points in a program run with equal probability
  - Generic profilers rely on the JVMTI spec:
    - JVMTI offers   only safepoint sampling stack trace collection options :
      -   only the safepoint polls in the running code are visible  skipping optimized
          (counted-code) for-loops!!!
      -   samples are biased towards the next available safepoint poll location
      - A sample profiler can blame a "cheap method" 9 levels down the stack when the
        real culprit is the topmost method loop.
[[}]]


[[{jvm.monitoring.micrometer,architecture.distributed,monitoring.distributed,01_PM.troubleshooting,01_PM.low_code,01_PM.WiP]] #[micrometer_summary]
● Micrometer <!-- @ma -->
- simple facade to instrumentation clients for
- instrument JVM-based apps without vendor lock-in.
  (Think SLF4J, but for application metrics! supporting AppOptics,
   Atlas, Datadog, Dynatrace, Elastic, Ganglia, Graphite,
   Influx,Instana, JMX (hierarchical mapping), KairosDB, New Relic,
   Prometheus, SignalFx, Stackdriver, StatsD, Wavefront,)

- Recorded metrics are intended to be used to
  observe/alert/react to current/recent operational state.

  out-of-the-box instrumentation provided by Micrometer
  - JVM Metrics on classloaders, memory, garbage collection,
    threads, etc.
  - Spring Boot 2.0.0.M5+: Micrometer used as instrumentation library powering
    the delivery of application metrics from Spring.
  @[https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready-metrics]
    2 simple steps setup: [low_code]
    - Declare maven dependency.
    - Add config. to application.yml

  @[https://micrometer.io/docs/ref/spring/1.5] (legacy support)
drop─down support for Spring Boot 1.5.x.
  - Cache instrumentation for most popular caching frameworks.
  - OkHttpClient Instrumentation

Guides: [TODO]
-@[https://micrometer.io/docs/guide/consoleReporter]
-@[https://micrometer.io/docs/guide/httpSenderResilience4jRetry]
-@[https://micrometer.io/docs/guide/customMeterRegistry]
[[}]]


[[{jvm.101,01_PM.WiP]]
● Inside the JVM
- @[https://www.artima.com/insidejvm/ed2/index.html]

- JVM anatomy Park:
  @[https://shipilev.net/jvm-anatomy-park/]
  @[https://shipilev.net/jvm-anatomy-park/22-safepoint-polls/]

      ┌────────────────────┐
      │ JVM StartUp thread │
      └─────────┬──────────┘
       ┌────────┼───────────┐
       v        v           v
       GC      Compiler   JAVA
     Threads   Thread    Threads
     ┌┐┌┐┌┐┌┐    ┌┐      ┌┐┌┐┌┐┌┐┌┐┌┐┌┐...
     ││││││││    ││      ││││││││││││││
     ││││││││    ││      ││││││││││││││
     ││││││││    ││      ││││││││││││││
     ││││││││    ││      ││││││││││││││
     ││││││││    ││      ││││││││││││││
     ········    ··      ··············

  JIT compiler optimization levels:
  - cold
  - warm
  - hot
  - very hot (with profiling)
  - scorching.
    ^^^^^^^^
  The hotter the optimization level, the better the
  expected performance, but the higher the cost in terms of
  CPU and memory.  See also @[#jvm_app_checkpoint]
[[}]]

[[{jvm,01_PM.WiP]]
● JVM Implementations
@[https://blog.joda.org/2018/09/time-to-look-beyond-oracles-jdk.html]

In practical terms, there is only one set of source code for the JDK.

- Anyone can take that source code,build and publish it.
- The certification process ensures that the build is valid.
- Certification run by the Java Community Process, which provides a
  Technology Compatibility Kit (TCK, sometimes referred to as the JCK).
  If build passes the TCK then it is described as "Java SE compatible".
  Note: Built can NOT be referred to as "Java SE" without paying a commercial
        license from Oracle.
        Ex: AdoptOpenJDK passing TCK are "Java SE compatible" (vs "Java SE").
  -  WARN : certification is currently on a trust-basis: results are
            not submitted to the JCP/Oracle for checking, neither can
            be made public.

- Existing builds include:
  - Oracle Java
  - OpenJ9      (Eclipse "IBM")
    └ https://en.wikipedia.org/wiki/OpenJ9
    └ Pre-built binaries available at AdoptOpenJDK
    └ Compared to Oracle's HotSpot VM, i touts higher
      start-up performance and lower memory consumption
      at a similar overall throughput.
    └ JIT with all optimization levels.
  - OpenJDK
  - GraalVM
  - Bellsoft Liberica:
    - $free TCK verified OpenJDK distribution for x86, ARM32 and ARM64.
  - Azul Systems
  - Sap Machine
    JDK for Java 10 and later under the GPL+CE license.
    They also have a commercial closed-source JVM
  - Amazon Corretto:
    zero-cost build of OpenJDK with long-term support that passes the
    TCK. It is under the standard GPL+CE license of all OpenJDK builds.
    Amazon will be adding their own patches and running Corretto on AWS
[[}]]
[[{jvm.linux]]
● sysctl/ulimit+JAVA
• Reference (non-mandatory) Linux OS setup for JVM server tasks extracted from:
@[https://docs.sonarqube.org/latest/requirements/requirements/]

  ...  If you're running on Linux, you must ensure that:

  $ $ sysctl vm.max_map_count     ← Ensure it's greater than or equal to 524288
  $ $ sysctl fs.file-max          ← Ensure it's greater than or equal to 131072
  $ $ ulimit -n                   ← Ensure at least 131072 file descriptors
  $ $ ulimit -u                   ← Ensure at least 8192 threads
    └──────────┬────────────────┘
     Tune current values like:
                                            Modify Kernel limits (permanently)
  + sysctl -w vm.max_map_count=524288     ← by adding those lines to  /etc/sysctl.conf
  + sysctl -w fs.file-max=131072            (or /etc/sysctl.d/99-sonarqube.conf )

  $ $ ulimit -n 131072                    ← Modify user-limits (temporally)
  $ $ ulimit -u 8192                        (changes lost at system restart)

                                            Modify user limits (permanently):
                                            ===================================
                                            Add next lines to:
  + sonarqube   -   nofile   131072       ← Alt 1:  /etc/security/limits.conf  (non SystemD)
  + sonarqube   -   nproc    8192

    [Service]                             ← Alt 2: SystemD unit definition     (SystemD)
    ...
  + LimitNOFILE=131072                      .
  + LimitNPROC=8192
    ...
[[}]]


● Memory
[[{jvm.101,scalability.jvm,monitoring.jvm]]
  ● JVM MEMORY
(<a href="https://dzone.com/articles/java-memory-management">REF</a>)
JAVA MEMORY MODEL:

         │    STACK ("SMALL")          │ HEAP  ("HUGE")
         │ private to each Thread      │ Shared by Threads
─────────┼─────────────────────────────┼──────────────────
Contain  │ - references to heap objects│ - objects
         │ - value types               │ - instance fields
         │ - formal method params      │ - static fields
         │ - exception handler params  │ - array elements

* 1: Ref(erence) types on the stack point to real object in HEAP memory.

Reference Types regarding how the object on the heap is eligible for garbage collection
┌─────────┬───────────────────────────────────────────────────────────────────────────
│ STRONG  │ - Most popular.
│         │ - The object on the heap it is not garbage collected
│         │   while there is a strong reference pointing to it, or if it is
│         │   strongly reachable through a chain of strong references.
├─────────┼───────────────────────────────────────────────────────────────────────────
│ WEAK    │ - most likely to not survive after the next garbage collection process.
│         │ - Is created like
│         │    WeakReference<StringBuilder> reference =
│         │     = new WeakReference<>(new StringBuilder());
│         │ -  Ex.use case: caching:
│         │   We let the GC remove the object pointed to by the weak reference,
│         │   after which a null will be returned
│         │   See JDK implementation at
│         │   @[https://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html]
├─────────┼───────────────────────────────────────────────────────────────────────────
│ SOFT    │ - used for more memory-sensitive scenarios
│         │ - Will be garbage collected only when the application is running low on memory.
│         │ -  Java guarantees that all soft referenced objects
│         │   are cleaned up before throwing OutOfMemoryError
│         │ - is created as follows:
│         │   SoftReference<StringBuilder> reference = new SoftReference<>(new StringBuilder());
├─────────┼───────────────────────────────────────────────────────────────────────────
│ PHANTOM │ - Used to schedule post-mortem cleanup actions, since we know for
│         │   sure that objects are no longer alive.
│         │ - Used only with a reference queue, since the .get() method of
│         │   such references will always return null.
│         │ -  These types of references are considered preferable to finalizers
└─────────┴───────────────────────────────────────────────────────────────────────────
[[}]]

[[{jvm.memory,scalability.jvm,java_lang.strings]]
● Force string pool reuse
- Strings are immutable.
- Stored on the heap
- Java manages a string pool in memory,
  reusing strings whenever possible.

String string01 = "297",                                string01 == string02 : true
       string02 = "297",                                string01 == string03 :   false
       string03 = new Integer(297).toString(),          string01 == string04 : true
       string04 = new Integer(297).toString()           string05 == string01 :   false
                  .intern() ;
       string05 = new String("297")

 1:   Pool reuse does not work for dynamically created strings
*2: If we consider that the computed String will be used quite often,
    we can force the JVM to add it to the string pool by adding the
    .intern() method at the end of computed string.
[[}]]

[[{jvm.memory,scalability.cache,scalability.jvm]]
● "MARK&amp;SWEEP"
JVM analyzes the variables from the stack and "marks" all the objects that need to be kept alive.
Then, all the unused objects are cleaned up.

The more garbage there is, and the fewer that objects are marked alive, the faster the process is.

To optimize even more heap memory actually consists of multiple parts (Java 8+):

  ┌──────────┼─────────────────────────────────────
  │ HEAP     │
  │ SPACES   │
  ├──────────┼─────────────────────────────────────
  │ Eden     │ * object are place here upon creation.
  │          │ * "small" ─→ gets full quite fast.
  │          │ * GC runs on the Eden space and marks objects as alive
  ├──────────┼─────────────────────────────────────
  │ S0       │ * Eden Objects surviving 1st GC are moved here
  │          │
  ├──────────┼─────────────────────────────────────
  │ S1       │ * Eden Objects surviving 2nd GC are moved here
  │          │ * S0   Objects surviving     GC are moved here
  ├──────────┼─────────────────────────────────────
  │ Old      │ * Object survives for "N" rounds of GC (N depends on
  │          │   implementation), most likely that it will survive
  │          │   forever, and get moved here
  │          │ * Bigger than Eden and S0,S1. GC doesn`t run so often
  ├──────────┼─────────────────────────────────────
  │ Metaspace│ * metadata about loaded classes
  │          │   (PermGen Before Java 8)
  ├──────────┼─────────────────────────────────────
  │ String   │
  │   pool   │
  └──────────┴─────────────────────────────────────
[[}]]
[[{jvm.memory]]
● GC Types
- default GC type is based on the underlying hardware
- programmer can choose which one should be used


   GC TYPE     | Description  / Use-Cases
+--------------+-----------------------------------------------------------------------------
|Serial GC     | - Single thread collector.
|              | -  Halt all app threads while executing
|              | - Mostly applies to  small apps with small data usage
|              | - Can be enabled through :   -XX:+UseSerialGC
+--------------+-----------------------------------------------------------------------------
|Parallel GC   | - Multiple threads used for GC
|              | -  Halt all app threads while executing
|              | - Also known as throughput collector
|              | - Can be enabled through :   -XX:+UseParallelGC
+--------------+-----------------------------------------------------------------------------
|Mostly        | - works concurrent to the application, "mostly" not halting threads
|Concurrent GC | - "mostly": There is a period of time for which the threads are paused.
|              |    Still, the pause is kept as short as possible to achieve the best GC performance.
|              | - 2 types of mostly concurrent GCs:
|              |   * Garbage First - high throughput with a reasonable application pause time.
|              |                   - Enabled with the option:   -XX:+UseG1GC
|              |     Concurrent Mark Sweep: app pause is kept to minimum.  Deprecated as Java9+*
|              |                   - Enabled with the option:   -XX:+UseConcMarkSweepGC
+--------------+-----------------------------------------------------------------------------

See also:
@[https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html]
[[}]]

[[{jvm.101,java_lang.101,01_PM.troubleshooting]]
● Optimization Tips
- To minimize the memory footprint, limit the scope of the variables as much as possible.

- Explicitly refer to null obsolete references making them eligible for GC.

- Avoid finalizers. They slow down the process and they do not guarantee anything.
  Prefer phantom references for cleanup work.

- Do not use strong references where weak or soft references apply.
  The most common memory pitfalls are caching scenarios,when data
  is held in memory even if it might not be needed.

- Explicitly specify heap size for the JVM when running the application:
  -  allocate a reasonable initial and maximum amount of memory for the heap.
     Initial heap size -Xms512m   – set initial heap     size to  512 megabytes
     Maximum heap size -Xmx1024m  – set maximum heap     size to 1024 megabytes
     Thread stack size -Xss128m   – set thread stack     size to  128 megabytes
     Young genera.size -Xmn256m   – set young generation size to  256 megabytes

REF: @[https://dzone.com/articles/heap-memory-in-java-performance-testing?utm_source=www.oficina24x7.com]
    - Initial Heap Size: -Xms: >= 1/64th of physical memory || reasonable minimum.
    - Maximum Heap Size: -XmX: <= 1/4 th of physical memory || 1GB.
                         ^^^^^
                  - Set -Xms equal to -Xmx to prevent pauses caused by heap expansion
                  ☞  Setting Xms/Xmx increase GC predictability .

    JVM settings are recommended for:
    PRODUCTION TIER       REPLICA SERVERS           STANDALONE
    -server               -server                   -server
    -Xms24G -Xmx24G        -Xms4G -Xmx4G            -Xms32G -Xmx32G
    └───────────────────────────┬─────────────────────────────────┘
                      PRODUCTION/REPLICA/STANDALONE:

                      -XX:PermSize=512m
                      -XX:+UseG1GC
                      -XX:MaxGCPauseMillis=200     ← soft goal (JVM) best effort
                      -XX:ParallelGCThreads=20     ← value depends on hosting hardware
                      -XX:ConcGCThreads=5          ← value depends on hosting hardware
                      -XX:InitiatingHeapOccupancyPercent=70 ← Use 0 to force constant
                                                              GC cycles

       WARN, WARN, WARN:
       There are 600+ arguments that you can pass to JVM to fine-tune GC and memory
       If you include other aspects, the number of JVM arguments will easily cross
       1000+.
       (Or why Data Scientist end up using Python)


- If app OutOfMemoryError-crashes, extra info about memory leak can be obtained through
    –XX:HeapDumpOnOutOfMemory , creating a heap dump file

- Use   -verbose:gc  to get the garbage collection output.

- Eclipse Memory Analyzer Manual:
@[https://help.eclipse.org/2019-06/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fwelcome.html&cp=62]

<hr/>
  Commom Memory Leaks pitfalls :
@[http://java.jiderhamn.se/2012/02/26/classloader-leaks-v-common-mistakes-and-known-offenders/]
- Logging frameworks (Apache Commons Logging/log4j/java.util.logging/...)
  trigger classloader leaks if   logging framework is supplied outside of
  the web application, such as within the Application Server.
  -  Add next cleanup code to ServletContextListener :
    org.apache.commons.logging.LogFactory.                    // Alt.1
      release(Thread.currentThread().getContextClassLoader());

    org.apache.commons.logging.LogFactory.release(            // Alt.2
        this.getClass().getClassLoader()  );
[[}]]

[[{jvm.101,qa.101,01_PM.troubleshooting]]
● <<AutoClosable>> (1.7+)
- The java garbage collector can not automatically clean any
  other resource appart from memory. All resources related to
  I/O (virtual/physical devices) must be closed programatically,
  for example sockets, http connections, database connections, ...
  since neither the compiler, not the runtime can not take control of
  external (non-controlled) devices/resources.

  Java 1.7+ includes the interface java.lang.AutoClosable to simplify
  the resource cleaning.

  When a class representing an external resource implement this
  interface and is used inside a try-with-resources , its close
  method will be invoqued automatically (the compiler will add
  the required code).

  Most core java I/O classes  already implemente this interface.

  Ex:
  public class MyClassWithExternalResources
  implements  java.lang.AutoCloseable , ... {
        private final MyExternalEventListener listener;
        private final MyIODevice device;
        private final MyHTTPConnection connection;
        ...
        public void close() {
            listener  .close();
            device    .close();
            connection.close();
        }
        ...
    }

    public class SomeLongRunningClass {
      ...
      void useManyResourcesManyTimes(String path)  {

        for (int repeat=0; repeat<100; repeat++) {
          try (MyClassWithExternalResources i =
                new MyClassWithExternalResources(...))  {
                ...
          } catch( ... ) {
            //
          }

          // At this point all resouces have been closed.
          // If a runtime exception exits the function the
          // resource is also closed.
        }
    }
[[$div}]]

[[$div}]]

[[{$div]]
● Java lang. 101 [[{01_PM.TODO]]
● Jabba JDK Vers. Mng
@[https://github.com/shyiko/jabba]
• pain-free JDK installing on Linux x86/x86_64/ARMv7+, macOS, Windows x86_64.
• Support for:
  · Oracle JDK (latest-version only)
  · Oracle Server JRE (latest-version only),
  · Adopt OpenJDK (jabba >=0.8.0 is required)
        Hotspot
        Eclipse OpenJ9
  · Zulu OpenJDK (jabba >=0.3.0 is required)
  · IBM SDK, Java Technology Edition (jabba >=0.6.0 is required)
  · GraalVM CE
  · OpenJDK
  · OpenJDK Reference Implementation
  · OpenJDK with Shenandoah GC (jabba >=0.10.0 is required)
  · Liberica JDK
  · Amazon Corretto

• INSTALL/UPGRADE:
$ $ curl -sL https://github.com/shyiko/jabba/raw/master/install.sh | bash
$ $. ~/.jabba/jabba.sh

   Use $ ... | bash --skip-rc   to avoid modifying common rc files.
   In that case add next lines to .bashrc / ...
 + export JABBA_VERSION=...
 + [ -s "$JABBA_HOME/jabba.sh" ] && source "$JABBA_HOME/jabba.sh"

• USAGE
$ $ jabba ls-remote                   ←  list available JDK's
$ $ jabba ls-remote zulu@~1.8.60      ← Narrow results
$ $ jabba ls-remote --latest=minor\   ← semver allowed
$        "*@>=1.6.45 <1.9"

$ $ jabba ls                          ← list all installed JDK's
$ $ jabba use adopt@1.8
$ $ jabba use zulu@~1.6.97
$ $ echo "1.8" > .jabbarc             ← switch to JDK in .jabbarc
                                        It must be a valid YAML file.
                                        'jdk: 1.8' or simply '1.8' are valid
$ $ jabba alias default 1.8           ← set def.java ver. on shell (since 0.2.0)
                                        automatically used on new terminals

$ $ jabba install 1.15.0                      ← install Oracle JDK
$ $ jabba install sjre@1.8                    ← install Oracle Server JRE
$ $ jabba install adopt@1.8-0                 ← install Adopt OpenJDK (Hotspot)
$ $ jabba install adopt-openj9@1.9-0          ← install Adopt OpenJDK (Eclipse OpenJ9)
$ $ jabba install zulu@1.8                    ← install Zulu OpenJDK
$ $ jabba install ibm@1.8                     ← install IBM SDK, Java Technology Edition
$ $ jabba install graalvm@1.0-0               ← install GraalVM CE
$ $ jabba install openjdk@1.10-0              ← install OpenJDK
$ $ jabba install openjdk-shenandoah@1.10-0   ← install OpenJDK with Shenandoah GC
          └──┬──┘
   everything is installed under ~/.jabba. Removing this directory clean install
$ $ jabba uninstall zulu@1.6.77               ← uninstall JDK
$ $ jabba link system@1.8.72 \                ← link system JDK
$   /usr/lib/jvm/jdk1.8.0_72.jdk

• To modify JDK system-wide:
$ $ sudo update-alternatives --install /usr/bin/java java ${JAVA_HOME%*/}/bin/java 20000
$ $ sudo update-alternatives --install /usr/bin/javac javac ${JAVA_HOME%*/}/bin/javac 20000
• To swith among GLOBAL JDK system-wide:
$ $ sudo update-alternatives --config java


[[}]]

[[{java_lang.strings,java_lang.101,01_PM.WiP]]
● Strings
  final String
     output1 = String .format ("%s = %d", "joe", 35), ← Format string
     output2 = String .format ("%4d",100);            ←
  See also notes about "Format String Checker"

  final String[] args = ...
  final String s1 = String.join(List.of(args),"'" )); // ← alt 1: String array to CSV
  final String s1 = String.join(","          ,args)); // ← alt 2: String array to CSV

  java.util.StringJoiner  (1.8+) Concatenate Strings
  https://docs.oracle.com/javase/8/docs/api/java/util/StringJoiner.html
- Ex:
  "[George:Sally:Fred]" may be constructed as follows:
  final StringJoiner sj = new StringJoiner(
                             ":" /* Delimiter */,
                             "[" /* prefix */,
                             "]" /* sufix */);
  sj.add("George").add("Sally").add("Fred");
  String desiredString = sj.toString();

  Collectors.joining(CharSequence):

  List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
  String commaSeparatedNumbers = numbers.stream()
      .map(i -> i.toString())
      .collect( Collectors.joining(", ") );

● StringBuffer/StringBuilder
• Concatenating strings is very slow when compared to StringBuffer/StringBuilder.
  - StringBuffer   is thread-safe.
  - StringBuilder  is faster. (when thread-safety is not needed)
@[https://stackoverflow.com/questions/355089/difference-between-stringbuilder-and-stringbuffer]
    for (int i = 0; i < 0 ; i++) { sbuffer.append(""); } // ← 2241 millisec
    for (int i = 0; i < 0 ; i++) { sbuildr.append(""); } // ←  753 millisec  ~3.0x faster!!!
[[}]]

[[{java_lang.101,persistence.FS]]
● Reading file
  Reading as lines of text
  final File input = new File("input.txt");
  final String result =
        Files.toString(input, Charsets.UTF_8);   // ← Alt 1.(Guava) Read to String
                                                       WARN: Only for small sizes

  final File input = new File("input.txt");
  final List<String> result =
       Files.readLines(input, Charsets.UTF_8);   // ← Alt 2.(Guava) Read to List
             ^^^^^^^^^                                WARN: Only for small sizes
             readFirstLine() can be useful sometimes

  final File input = new File("input.txt");
  final CharSource source =
      Files.asCharSource(input, Charsets.UTF_8); // ← Alt 3.(Guava) Use CharSource
  final String result = source.read();           // ←   WARN: Only for small sizes

  final File input1 = new File("input1.txt"),
             input2 = new File("input1.txt");
  final CharSource
      source1 = Files.asCharSource(input1, Charsets.UTF_8),
      source2 = Files.asCharSource(input2, Charsets.UTF_8),
      source  =
         CharSource.concat(source1, source2);   // ← Alt 3.2(Guava) Concat CharSources
  final String result = source.read();

  final FileReader reader = new FileReader("input.txt");
  final String result =
        CharStreams.toString(reader);          // ← Alt 4. (Big Files) CharStreams
  reader.close();                              // ←   WARN:  Don't forget to close

  Read file as bytes
  final File file = new File("input.raw");
  final ByteSource source                      // ← Alt 1: (Guava) Use ByteSource
        = Files.asByteSource(file).
          .slice(20 /* initial offset */, 100 /* len */);
  final byte[] result = source.read();

  FileInputStream reader =
     new FileInputStream("input.raw");        // ←   Using FileInputStream
  byte[] result =
     ByteStreams.toByteArray(reader);         // ← + ByteStreams
  reader.close();

  final URL url =
       Resources.getResource("test.txt");     // ← Read Resource in classpath
  final String resource =
       Resources.toString(url, Charsets.UTF_8);
<hr/>
● Reading big files
     try (
  final FileInputStream inputStream = new FileInputStream(path);
  final Scanner sc =                        ← Use Scanner to read line-by-line
            new Scanner(inputStream, "UTF-8");
     ) {
  while (sc.hasNextLine()) {
      final String line = sc.nextLine();
      // ... do any process ...
      if (sc.ioException() != null) {    ← // scanner captures ioExceptions
          // handle error                  // It's good to have a look
      }
  }
     } finally {
  ...
     }

final LineIterator it =                       ← Alt 2. From  Apache Commons IO
   FileUtils.lineIterator(theFile, "UTF-8");
   try {
while (it.hasNext()) {
   String line = it.nextLine();               ← Read line-by-line
   // ...
}
   } finally {
LineIterator.closeQuietly(it);                ← Close resources
   }
<hr/>
● Unix4j
@[https://github.com/tools4j/unix4j]
"""...Working in the finance industry in Melbourne, the authors of
  Unix4j spent a lot of time writing complex text processing
  applications in bash. Frustrated with the inherent limitations of the
  bash language; lack of language support, IDEs, test frameworks etc,
  the authors decided to try and bring the convenience of some of the
  Unix commands into the Java language.
  You may notice that the implemented commands are more bent towards
  text processing rather than OS and file manipulation. This is
  intended as we see text processing to be the real benefit of Unix4j.
  Not to say that this will always be the case.
"""
  Allows for things like:
  - Unix4j.cat("test.txt").grep("Tuesday").sed("s/kilogram/kg/g").sort();


- java.nio.file.Files.writeString/readString (Java 11+ "utility" classes)
  java.nio.file.Path fileName = Path.of("demo.txt");
  String content  = "hello world !!";
  java.nio.file.Files.writeString(fileName, content);        ← String    to text-file

  String actual = java.nio.file.Files.readString(fileName);  ← text-file to String
  System.out.println(actual);

- java.nio.files.Files.lines: (Java 8+)
    private static String readLineByLine(String filePath)
    {
        final StringBuilder contentBuilder = new StringBuilder();
        try (
          final java.util.stream.Stream<String> stream =   ← stream resource must be closed
              java.nio.file.Files.lines(                      (with a try-with in this example)
                  java.nio.file.Paths.get(filePath),
                  java.nio.charset.StandardCharsets.UTF_8)
         ) {
            stream.forEach(
                s -> contentBuilder.append(s).append("\n")
            );
        } catch(java.io.IOException e) { ...  }
        return contentBuilder.toString();
    }
[[}]]

[[{java_lang.101,concurrency]]
● java.time
java.time.*
- JDK 1.8+
- "deprecates" java.util.(Date|Calendar|TimeZome)
- All the classes are IMMUTABLE and THREAD-SAFE
  import java.time.Instant;
  import java.time.ZonedDateTime;
  import java.time.ZoneId;
  import java.util.concurrent.TimeUnit;
...
  Instant   timestamp  =   Instant .now();              // Create from system clock
            timestamp .plus(Duration.ofSeconds(10));    // Add 10 seconds

  │  Instant  to String                 │   Instant  from String
  │(format with time-zone)              │ (parse string)
  ├─────────────────────────────────────┼───────────────────────────────────────────────────
  │  ZonedDateTime  zdt1 =              │
  │       ZonedDateTime .of             │ String sExpiresAt="2013-05-30T23:38:23.085Z";
  │       (                             │   ZonedDateTime zdt2 =   ZonedDateTime .parse(sExpiresAt);
  │         2017, 6, 30           ,     │
  │         1, 2, 3               ,     │   Instant i1 =   Instant .from(zdt1),
  │         (int) TimeUnit.             │           i2 =   Instant .from(zdt2);
  │               MILLISECONDS.         │
  │               toNanos(100),         │
  │         ZoneId.of("Europe/Paris")   │
  │       );          ^^^               │
  │     Ex: "Z","-02:00","Asia/Tokyo",..│
  │String s1 = zdt1.toString();         │
          ^^
  2017-06-30T01:02:03.100+02:00[Europe/Madrid]

java.text.DateFormat:
date  (none)           DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())
      short            DateFormat.getDateInstance(DateFormat.SHORT, getLocale())
      medium           DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())
      long             DateFormat.getDateInstance(DateFormat.LONG, getLocale())
      full             DateFormat.getDateInstance(DateFormat.FULL, getLocale())
      SubformatPattern new SimpleDateFormat(subformatPattern, getLocale())

time  (none)           DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())
      short            DateFormat.getTimeInstance(DateFormat.SHORT, getLocale())
      medium           DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())
      long             DateFormat.getTimeInstance(DateFormat.LONG, getLocale())
      full             DateFormat.getTimeInstance(DateFormat.FULL, getLocale())
      SubformatPattern new SimpleDateFormat(subformatPattern, getLocale())

 Compatibility with Java <=1.
- (java.util.) Date, Calendar and TimeZone
  "buggy" classes/subclasses were used.
  ^^^^^^^
  - Calendar class was NOT type safe
  - Mutable non-threadsafe classes
  - Favored programming errors
    (unusual numbering of months,..)

- Next compatibility conversion methods were added in 1.8:
  - Calendar.toInstant()
  - GregorianCalendar.toZonedDateTime()
  - GregorianCalendar.from(ZonedDateTime) (Using default local)
  - Date.from(Instant)
  - Date.toInstant()
  - TimeZone.toZoneId()

 java.time. Package summary
                   Description
-----------------------------------------------------------------------------------
Clock              A clock providing access to the current instant, date and
                   time using a time-zone.
-----------------------------------------------------------------------------------
Duration           A time-based amount of time, such as '34.5 seconds'.
-----------------------------------------------------------------------------------
Instant            An instantaneous point on the time-line.
-----------------------------------------------------------------------------------
LocalDate          A date without a time-zone in the ISO-8601 calendar system,
                   such as 2007-12-03.
-----------------------------------------------------------------------------------
LocalDateTime      A date-time without a time-zone in the ISO-8601 calendar
                   system, such as 2007-12-03T10:15:30.
-----------------------------------------------------------------------------------
LocalTime          A time without a time-zone in the ISO-8601 calendar system,
                   such as 10:15:30.
-----------------------------------------------------------------------------------
MonthDay           A month-day in the ISO-8601 calendar system, such as --12-03.
-----------------------------------------------------------------------------------
OffsetDateTime     A date-time with an offset from UTC/Greenwich in the ISO-8601
                   calendar system, such as 2007-12-03T10:15:30+01:00.
-----------------------------------------------------------------------------------
OffsetTime         A time with an offset from UTC/Greenwich in the ISO-8601
                   calendar system, such as 10:15:30+01:00.
-----------------------------------------------------------------------------------
Period             A date-based amount of time in the ISO-8601 calendar system,
                    such as '2 years, 3 months and 4 days'.
-----------------------------------------------------------------------------------
Year               A year in the ISO-8601 calendar system, such as 2007.
-----------------------------------------------------------------------------------
YearMonth          A year-month in the ISO-8601 calendar system, such as 2007-12
-----------------------------------------------------------------------------------
ZonedDateTime      A date-time with a time-zone in the ISO-8601 calendar system,
                   such as 2007-12-03T10:15:30+01:00 Europe/Paris.
-----------------------------------------------------------------------------------
ZoneId             A time-zone ID, such as Europe/Paris.
-----------------------------------------------------------------------------------
ZoneOffset         A time-zone offset from Greenwich/UTC, such as +02:00.
-----------------------------------------------------------------------------------


Enum               Description
-----------------------------------------------------------------------------------
DayOfWeek          A day-of-week, such as 'Tuesday'.
-----------------------------------------------------------------------------------
Month              A month-of-year, such as 'July'.
-----------------------------------------------------------------------------------

Exception          Description
-----------------------------------------------------------------------------------
DateTimeException  Exception used to indicate a problem while calculating a date-time.

<a xsmall href='https://www.infoq.com/news/2017/02/java9-cldr-ldml'>Java 9</a>
- A number of parsing and formatting changes have been incorporated in Java 9 to
bring the functionality closer to Unicode Locale Data Markup Language (LDML).
These changes have been supervised by Stephen Colebourne, creator of the popular
 date-time library JodaTime, precursor of the new java.time component in Java 8.
Abiding by the Unicode standard will provide better interoperability with other
non-Java systems.

- LDML is the language used by the Unicode Common Locale Data Repository (CLDR),
  a project of the Unicode Consortium to gather and store locale data from
  different parts of the world, enabling application developers to better adapt
  their programs to different cultures. Among other things, LDML deals with dates,
  times, and timezones, and more particularly with date formatting and parsing.
  The following is an extract of new features coming in Java 9 that bring java.time
  closer to the LDML specification:

  - JDK-8148947, DateTimeFormatter pattern letter ‘g’: the letter ‘g’, as
    specified in LDML, indicates a “Modified Julian day”; this is different from a
    normal Julian day in the sense that a) it depends on local time, rather than GMT,
    and b) it demarcates days at midnight, as opposed to noon.
  - JDK-8155823, Add date-time patterns 'v' and 'vvvv’: ‘v’ and ‘vvvv’ are LDML
    formats to indicate “generic non-location format”, e.g. “Pacific Time”, as
    opposed to the “generic location format” with specifies a city, like
    “Los Angeles Time”.
  - JDK-8148949, DateTimeFormatter pattern letters ‘A’, ’n’, ’N’: although LDML
    doesn’t specify formats ’n’ and ’N’, it does specify ‘A’, but the current
    behaviour in Java doesn’t match that of the spec. ‘A’ is meant to represent the
    total number of milliseconds elapsed in the day, with variable width, but
    currently Java treats this as fixed with: if ‘AA’ is specified as a pattern, it
    will fail to parse any value that is further than 99 milliseconds in the day.
    ’n’ and ’N’ are just Java extensions to the standard to represent nanoseconds
    within the second, and nanoseconds within the day, respectively.
  - JDK-8079628, java.time DateTimeFormatter containing "DD" fails on three-digit
    day-of-year value: similar to the previous problem, but with ‘D’ representing
    days within a year. If one specifies “DD” as a pattern, it will fail to parse
    “123” as the 123th day of the year.
- As previously mentioned, a better alignment with the LDML will ease
  interoperability across systems, since there are multiple technologies that
  have adopted the LDML to some degree. Microsoft .NET uses LDML for general
  interexchange of locale data, and there are packages available for Node.js
  and Ruby, just to mention a few.
● TimeUnit
@[https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TimeUnit.html]
- JDK 1.5+
- Represents time durations at a given unit of granularity and
  provides utility methods to convert across units, and to perform
  timing and delay operations in these units.
Enums: DAYS HOURS MICROSECONDS MILLISECONDS MINUTES NANOSECONDS SECONDS

  void      sleep(long timeout)
  void  timedJoin(Thread thread, long timeout)
  void   timedWait(Object obj, long timeout)
  ...
[[}]]


<pre zoom  labels="java_lang.101,qa" >
<a xsmall href="http://docs.oracle.com/javase/tutorial/java/annotations/">ANNOTATIONS</a>
 predefined annotation types in java.lang:
- @Deprecated
- @Override
- @SuppressWarnings
- @SafeVarargs (SDK 1.? +) applied to a method/constructor,
                           asserts that the code does not perform
                           potentially unsafe operations
                           on its varargs parameter.
                           removing  related warnings

 Annotation types are a form of interface
DECLARATION(interface is preceded by the @ sign) │ USAGE
  @Documented                                    │
  @interface ClassPreamble {                     │   @ClassPreamble (
     String   author        ()              ;    │      author         = "John Doe"      ,
     String   date          ()              ;    │      date           = "3/17/2002"     ,
     int      currentRev    () default 1    ;    │      currentRev     = 6               ,
     String   lastModified  () default "N/A";    │      lastModified   = "4/12/2004"     ,
     String   lastModifiedBy() default "N/A";    │      lastModifiedBy = "Jane Doe"      ,
     String[] reviewers     ()              ;    │      reviewers      = {"Alice", "Bob"}
  }                                              │   )
                                                 │ public class Generation3List extends Generation2List {
                                                 │     // ...
                                                 │ }
● EXAMPLES
new @Interned MyObject();              ← Class instance creation expression

myString = (@NonNull String) str;      ← Type cast (1.8+)

class UnmodifiableList<T> implements   ← implements clause
      @Readonly List<@Readonly T>
      { ... }

void monitorTemperature() throws       ← throws exception declaration
@Critical TemperatureException { ... }

@SuppressWarnings(value = "unchecked") ← Predefined standard annotations
void myMethod() { ... }
@SuppressWarnings({"unchecked", "deprecation"})
void myMethod() { ... }
[[}]]

[[{java_lang.101,qa]]
● META-ANNOTATTONS
(Annotations applying to other annotations)

 @Retention
RetentionPolicy.SOURCE: retained only in source (ignored by the compiler)
RetentionPolicy.CLASS : retained by compiler    (ignored by the JVM)
RetentionPolicy.RUNTIME:retained by JVM, can be queried at Runtime

 @Documented                       @Repeatable
- indicates that whenever the     - (1.8+)
  specified annotation is used    - targeted annotation can be applied
  those elements should be          more than once to the same
  documented using the Javadoc      declaration or type use.
  tool. (By default, annotations    Ex:
  are not included in Javadoc.)     @Author(name = "Jane Doe")
                                    @Author(name = "John Smith")
                                    class MyClass { ... }


 @Target                            @Inherited
 (field,type,class..)              - targeted annotation type can be inherited
- restrict targeted java-language    from the super class. (false by default.)
  elements where the annotation      When the user queries the annotation type
  can be applied:                    and the class has no annotation for this
  - ElementType.ANNOTATION_TYPE      type, the class'superclass is queried for
  - ElementType.CONSTRUCTOR          the annotation type.
  - ElementType.FIELD
  - ElementType.LOCAL_VARIABLE
  - ElementType.METHOD
  - ElementType.PACKAGE
  - ElementType.PARAMETER
  - ElementType.TYPE (1.8+)
[[}]]

[[{monitoring.logging,01_PM.troubleshooting]] #[slf4j_summary]
● SLF4j Logging: https://www.slf4j.org/
Simple Log Facade or abstraction for various logging frameworks
(e.g. java.util.logging, logback, log4j) allowing the end user
to plug in the desired logging framework at deployment time.

  (.../src/main/resources/)logback.xml
  <?xml version="1.0" encoding="UTF-8"?>
  <configuration>
    <root level="ALL">                                  ← Apply to all packages/levels
      <!-- <jmxConfigurator /> -->
      <appender   name="APPENDER_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
          <file>log</file>
          <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
              <!-- daily rollover -->
              <fileNamePattern>%d{yyyy-MM-dd}.log.zip</fileNamePattern>
              <maxFileSize>1MB</maxFileSize>
              <!-- keep 2 days' worth of history capped at 1MB total size -->
              <maxHistory>2</maxHistory>
              <totalSizeCap>2MB</totalSizeCap>
          </rollingPolicy>
          <encoder>
            ..(see encoder for APPENDER_STDOUT ..)
          </encoder>
      </appender>

      <appender   name="APPENDER_STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
          <pattern>%d{HH:mm:ss.SSS} | %-5level | %thread | %logger{1} |
    %m%n%rEx{full,                                      ←☞ filter "Noise" in stack trace.  REF
              java.lang.reflect.Method,                 ← remove Java reflection
              sun.reflect,
              org.apache.catalina,                      ← remove catalina engine
              org.springframework.aop,                  ← remove "almost" whole Spring framework
              org.springframework.security,             ←
              org.springframework.transaction,          ←
              org.springframework.web,                  ←
              net.sf.cglib,                             ← remove CGLIB classes.
              ByCGLIB                                   ←
            }
            </pattern>
        </encoder>
      </appender>
    </root>

    <root level="WARN">                                 ← Aply to all packages/WARN+ logs
        <appender-ref   ref="APPENDER_FILE"   />
        <appender-ref   ref="APPENDER_STDOUT" />
    </root>

    <logger name="my.company."          level="INFO" /> ← Detail level for packages
    <logger name="my.company.package01" level="DEBUG"/>
    <logger name="org.eclipse.jetty"    level="WARN" />

  </configuration>
   REF   : @[https://www.nurkiewicz.com/2011/09/logging-exceptions-root-cause-first.html]
           @[http://logback.qos.ch/manual/layouts.html]

</configuration>

  pom.xml
  <dependency>*
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.21</version>
  </dependency>
  ...
  <dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>            ← add   logback  facade
    <version>1.1.7</version>
    <exclusions>
      <exclusion>
        <groupId>org.slf4j</groupId>                    ←  Avoid error next start-up:
        <artifactId>slf4j-jdk14</artifactId>               "SLF4J: Class path contains multiple SLF4J bindings."
      </exclusion>                                         "   slf4j-jdk14-1.7.21.jar!...StaticLoggerBinder.class"
    </exclusions>                                          "logback-classic-1.1.7.jar!...StaticLoggerBinder.class"
  </dependency>

  Example Ussage
  import org.slf4j.Logger;
  import org.slf4j.LoggerFactory;
  ...
    class MyClass {
      private static final Logger log =
         LoggerFactory.getLogger(AbstractRequestHandler.class);
      ...
      if (log.isDebugEnabled()) {  ←······················· composed string "Lorem ipsum..."is built
          log.debug("Lorem ipsum... @{} {}",  ←············ before calling log.debug.
             "param1", "param2");                           "wrapper" if(log.isDebugEnabled())  avoid
      }                                                     unnecesary string processing (saving can
      ...                                                   be "huge" if log.debug is inside a loop.
[[}]]

[[{monitoring.logging,qa,devops,01_PM.troubleshooting]] #[mdc_summary]
● MDC: "Better Way of Logging"
@[https://dzone.com/articles/mdc-better-way-of-logging-1]
  PROBLEM : How do we related logs together originating
            from a (single user, single data-flow)
            that are processed by different threads, HTTP
            requests (think of Single Page Apps),
            or component?
  SOLUTION : Use mapped diagnostic context (MDC).

  Mapped Diagnostic Context :
  - Built into the logging framework,
  - supported by log4j, log4j2, and SL4J/logback.
  - MDC allows to capture custom  key/value  diagnostic data,
    accessible to the appender when the log message is actually
    written.
  - MDC structure is internally attached to the executing thread
    in the same way a ThreadLocal variable would be.

  MDC How To:
  - At the start of the thread, fill MDC with custom information
    (MDC API also allows to remove info later on if it doesn't apply)
  - Log the message
  - MDC Summarized API :
    public class MDC {
      public static void   put   (String key, String val); // ← Add to  current Thread
      public static String get   (String key);                          Context Map
      public static void   remove(String key);
      public static void clear(); // ← Clear all entries
    }
    NOTE: child threads does not automatically inherit a copy of
           the current diagnostic context.

  - Best pattern for microservices:
    - Ex:
      // STEP 1: Override   interceptor layer
                            ^^^^^^^^^^^^^^^^^
      //                """single place where call
      //                   execution passes through""".
      public class ServiceInterceptor
        extendsQ HandlerInterceptorAdapter {

          private final static Logger LOGGER =
                  Logger.getLogger(ServiceInterceptor.class);

          @Override
          public boolean preHandle(
                   HttpServletRequest request,
                   HttpServletResponse response,
                   Object object) throws Exception {
             MDC.put("userId"    , request.getHeader("UserId"   ));
             MDC.put("sessionId ", request.getHeader("SessionId"));
             MDC.put("requestId" , request.getHeader("RequestId"));
      }

      // STEP 2: Change log appender pattern to retrieve variables
      //         stored in the MDC.
      <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
      <layout>
      <Pattern>%X{userId} %X{sessionId} %X{requestId} - %m%n</Pattern>
      </layout>
      </appender>

      Log output will look some like:
      17:53:25,496 http─8080─20 INFO Service1.execute(77)  U1001 ┌ sessId01    ┌ reqId_1_1   req service 1
      17:53:25,497 http─8080─26 INFO Service1.execute(77)  U1002 │ sessId02 ┐  │ reqId_2_1┐  req service 1
      17:53:25,550 http─8080─26 INFO Service1.execute(112) U1002 │ sessId02 ┤  │ reqId_2_1┤  Req data
      17:53:25,555 http─8080─20 INFO Service1.execute(112) U1001 ├ sessId01 │  ├ reqId_1_1│  Req data
      17:53:25,617 http─8080─27 INFO Service2.execute(50)  U1001 ├ sessId01 │ ┌│ reqId_1_2│  req service 2
      17:53:25,615 http─8080─27 INFO Service2.execute(89)  U1001 ├ sessId01 │ │├ reqId_1_1│  req data
      17:53:25,637 http─8080─29 INFO Service2.execute(50)  U1002 │ sessId02 ┤ ││ reqId_2_2│┐ req service 2
      17:53:25,665 http─8080─29 INFO Service2.execute(89)  U1002 │ sessId02 ┤ ││ reqId_2_1┤│ req data
      17:53:25,568 http─8080─20 INFO Service1.execute(120) U1001 ├ sessId01 │ └│ reqId_1_2││ req OK
      17:53:25,584 http─8080─26 INFO Service1.execute(120) U1002 │ sessId02 ┤  │ reqId_2_1┘│ req OK
      17:53:25,701 http─8080─27 INFO Service2.execute(113) U1001 ├ sessId01 │  └ reqId_1_1 │ req OK
      ...          ...          ...  ...                   ...   : ...      :    ...       : ...
      17:53:25,710 http─8080─29 INFO Service2.execute(113) U1002   sessId02 ┘    reqId_2_2 ┘ req OK
      ...
[[}]]

[[{security.101,01_PM.low_code,spring,security.jvm]] #[security_101]
● Security 101
@[https://snyk.io/blog/10-java-security-best-practices/]
1. Make code immutable:
   · Tag variables as 'final' by default.
     (a final variable is not variable but constant)
   · Try to initialize all classes in constructors. and centralize
     all input checks in the constructor. Raise a runtime exception
     if the constructor is not happy with input data.
     (vs using getters and setters).
      Doing so warrants that a class is properly instantiated and
     safe upon constructor exit.
      This also warrants fail-fast applications. If something is
     undefined at startup time constructors will not be able to
     initialize and the application will fail to start: This is
     life-saving for DevOps and normal deployments.

2. Parameterize SQL:
   query = "SELECT ... WHERE lastname = "  + parameter ;  // ← Incorrect:
   Statement         stm01 = con.createStatement();

   query = "SELECT ... WHERE lastname = ?";               // ← Correct
   PreparedStatement stm01 = con.prepareStatement(query);
   statementB .setString(1, parameter);

   ...  stm01.executeQuery(query);

3. Use OpenID Connect with 2FA:
   OpenID summary: OAuth 2.0 extension providing user information.
   · It adds an ID token in addition to an access token plus
     a /userinfo endpoint to retrieve additional information
     plus endpoint discovery and dynamic client registration.

   low-code OpenID in Spring:
   STEP 1: Addd next dependencies:
     org.springframework.boot:spring-boot-starter-oauth2-client
     org.springframework.boot:spring-boot-starter-security

   STEP 2: Spring Configuration
   │ spring:
   │  ...
   │  security:
   │    oauth2:
   │      client:
   │        registration:
   │          github:
   │            client─id: ...
   │            client─secret: ....
   │          okta:
   │            client─id: ...
   │            client─secret: ...
   │            client─name: ...
   │          google:
   │            ...
   │        provider:
   │          okta:
   │            issuer─uri: https://.....okta.com/oauth2/default

4. Scan dependencies for known vulnerabilities
   Ej.: Use a service like  @[https://snyk.io/test/] !!!

5. Handle sensitive data with care
   - Use secrets on-demand and remove from memory as soon as possible.
     Ideally manage secrets through HSM. Secrets (signature keys, password,
     ...) must never leave the HSM.
   - If using Lombok generated toString(), mark with @ToString.Exclude
     sensitive fields.

6. Sanitize all input.
   Example 1, sanitizing HTML
   · Add next dependency:
     org.owasp.encoder:encoder:vX.Y.Z
   · final String
      untrustedInput = "<script> alert(1); </script>",
        trustedInput = StEncode.forHtml(untrustedInput));

7.  Configure your XML-parsers to disable XXE (eXternal Entity)
    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
      <!DOCTYPE bar [
           <!ENTITY xxe SYSTEM   "file:///etc/passwd" >] >      ← attack
           <song>
              <artist>  ⅋xxe; </artist>
              ...
           </song>


    e.g. In xerces 1/2 disable external entities and doctypes like:
         ...
         factory   = SAXParserFactory.newInstance();
         saxParser = factory.newSAXParser();
         factory.setFeature(
           "https://xml.org/sax/features/external-general-entities", false );
         saxParser.getXMLReader().setFeature(
           "https://xml.org/sax/features/external-general-entities", false );
         factory.setFeature(
           "https://apache.org/xml/features/disallow-doctype-decl" , true );
         ...

8. Avoid Java serialization as much as possible
   • Java serialization is also called   “the gift that keeps on giving” .
     Oracle is planning to eventually remove Java serialization as part
     of Project Amber.

     If you really need to implement serializable on your domain entities,
     implement its own readObject().

     private final void
     readObject(ObjectInputStream in) throws java.io.IOException {
       // check 1
       // check 2
       ...
       throw new java.io.IOException("Deserialized not allowed");
     }

     If you need to Deserialize an inputstream yourself, you should use an
     ObjectsInputStream with restrictions.
     e.j Apache Commons IO ValidatingObjectInputStream, that checks whether
         the object being deserialized is allowed or not.

         final FileInputStream fileInput = new FileInputStream(fileName);
         ValidatingObjectInputStream in = new ValidatingObjectInputStream(fileInput);
         in.accept(Foo.class);
         Foo foo_ = (Foo) in.readObject();

     Object deserialization can also apply to JSON, XML, ...
     (@[https://snyk.io/blog/jackson-deserialization-vulnerability/])

9. Use strong encryption and hashing algorithms.                   [[{security.cryptography}]]
   TIP: Prefer Google Tink  (vs Low Level Java crypto libraries)

10. Enable the Java Security Manager                               [[{security.jvm]]
   · By default, JVM imposes no restrictions to running apps.
     (file system, network, ..)
     · Ex. By default the Attach API is active allowing to easely
       change bytecode of running apps. (from inside the machine).

   · Activate it like:
   $ $ java ... -Djava.security.manager            ← Use default policy
   $ $ java ... -Djava.security.manager \          ← Use custom  policy
   $   -Djava.security.policy==.../custom.policy     ← == replace default.
                                                       =  expand  default.
   More info at
 @[https://docs.oracle.com/en/java/javase/11/security/permissions-jdk1.html]
   java.awt.AWTPermission                        java.sql.SQLPermission
   java.io.FilePermission                        java.util.logging.LoggingPermission
   java.io.SerializablePermission                java.util.PropertyPermission
   java.lang.RuntimePermission                   javax.management.MBeanPermission
   java.lang.management.ManagementPermission     javax.management.MBeanServerPermission
   java.lang.reflect.ReflectPermission           javax.management.MBeanTrustPermission
   java.net.NetPermission                        javax.management.remote.SubjectDelegationPermission
   java.net.URLPermission                        javax.net.ssl.SSLPermission
   java.net.SocketPermission                     javax.security.auth.AuthPermission
   java.nio.file.LinkPermission                  javax.security.auth.PrivateCredentialPermission
   java.security.AllPermission                   javax.security.auth.kerberos.DelegationPermission
   java.security.SecurityPermission              javax.security.auth.kerberos.ServicePermission
   java.security.UnresolvedPermission            javax.sound.sampled.AudioPermission [[}]]

11. Centralize logging and monitoring
[[}]]

● Functional
[[{java_lang.101,java_lang.functional,01_PM.WiP]]
● Lambdas
Sytnax:
(parameters) -> expression
(parameters) ->  { statements; }

// takes a Long, returns a String
Function<Long, String> f = (l) -> l.toString();

// takes nothing, gives you Thread
Supplier<Thread> s = Thread::currentThread;

//  takes a string as the parameter
Consumer<String> c = System.out::println;

// use lambdas in streams
new ArrayList<String>().stream()....

// peek: Debug streams without changes
peek ( e -> System.out.println(e)). ...

// map: Convert every element into something
map ( e -> e.hashCode())...

// filter (hc -> (hc % 2) == 0) ...

// collect all values from the stream
collect(Collectors.toCollection(TreeSet::new))

• TODO: github.com/jOOQ/jOOL, functional extensions to Java 8.
  • Context: Pains with checked exceptions and lambdas:
    http://stackoverflow.com/q/18198176/521799
    http://stackoverflow.com/q/19757300/521799
    http://stackoverflow.com/q/14039995/521799
  • Solution: org.jooq.lambda.Unchecked

    Standard Java 8:                 | Using jooq labmda wrapper:     | Even simpler:
    ================                 | ==========================     | ===================
    Arrays                           | Arrays                         | Arrays
    .stream(dir.listFiles())         | .stream(dir.listFiles())       | .stream(dir.listFiles())
    .forEach(file -> {               | .forEach(                      | .map(Unchecked.function(
          try {                      |   Unchecked.consumer(file -> { |      File::getCanonicalPath))
      System.out.println(            |     System.out.println(        | .forEach(System.out::println);
           file.getCanonicalPath()); |       file.getCanonicalPath());
          } catch (IOException e) {  |   })
      throw new RuntimeException(e); | );
          }
    });
[[}]]

[[{java_lang.functional,qa,async/reactive.*,01_PM.WiP]]
● java.utility.function
@[https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html]
@[https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html]
- JDK 1.8+
- Incomplete but good enough to cover the "shape" of many lambda expressions and
 method references representing abstract concepts like functions, actions, or predicates
- The @FunctionalInterface is used to capture design intent (not needed by compiler).
- In documenting functional interfaces, or referring to variables typed as
  functional interfaces, it is common to refer directly to those abstract concepts,
  for example using "this function" instead of "the function represented by this object".
- Each functional interface has a single abstract method, called the functional method for that
  functional interface, to which the lambda expression's parameter and return types are matched or adapted.
- Functional interfaces can provide a target type in multiple contexts, such as assignment context, method invocation,
  or cast context:
  |Predicate<String> p = String::isEmpty;           // Assignment context
  |stream.filter(e -> e.getSize() > 10)...          // Method invocation context
  |stream.map((ToIntFunction) e -> e.getSize())...  // Cast context

● Defined functions in 1.8
────────────────────────────────────────────┬────────────────────────────────────────────────────────────────────────────────
           Interface Summary                │           Interface Description
────────────────────────────────────────────┼────────────────────────────────────────────────────────────────────────────────
                  BiConsumer‹T,U›           │opt. accepting two input arguments and returns no result
  (|Double|Int|Long)Consumer‹T›             │opt. accepting a single (Object|double|int|long)input argument and returns no result
Obj(Double|Int|Long)Consumer‹T›             │opt. accepting an object-valued and a (double|int|long)-valued argument, and returns no result
────────────────────────────────────────────│────────────────────────────────────────────────────────────────────────────────
        (|Double|Long|Int)Function‹(T,)R›   │func. that accepts an (T|double,long,int) argument and produces a result
       (|Double|Long)ToIntFunction          │func. that accepts a (T|double|long)argument and produces an int-valued result
(ToDouble|ToLong|ToInt|)BiFunction‹(T,)U,R› │func. that accepts two arguments and produces an (T,double,long,int) result.
           To(Double|Long)Function‹T›       │func. that produces a (double|long)-valued result
(Int|Long|Double)To(Int|Long|Double)Function│func. that accepts a (int|long|double) argument and produces a (int|long|double) result
────────────────────────────────────────────│────────────────────────────────────────────────────────────────────────────────
 (|Int|Long|Double)UnaryOperator‹T›         │op. on a single (T|int|long|double) operand that produces a result of the same type
(Double|Long|Int|)BinaryOperator‹T›         │op. upon two (T|int|long|double) operands and producing a result of the same type
────────────────────────────────────────────│────────────────────────────────────────────────────────────────────────────────
                BiPredicate‹T,U›            │predicate (boolean-valued function) of two arguments
(|Int|Long|Double)Predicate‹T›              │predicate (boolean-valued function) of one (T|int|long|double) argument
────────────────────────────────────────────│────────────────────────────────────────────────────────────────────────────────
(|Boolean|Int|Long|Double)Supplier(‹T›)     │supplier of (T|Boolean|Int|long|double) results
────────────────────────────────────────────┴────────────────────────────────────────────────────────────────────────────────
[[}]]
[[$div}]]

[[{$div]]
● Collections
[[{]]java_lang.101,data_structures.101,data_structures.graphs,scalability.101,<02_doc_has.diagram,qa.data,java_lang.guava," >
<span xsmall bgorange>Collection Decission Tree
                                  ┌──────────┐
                                  │  Allows  │
                    ┌─── YES ─────┤Duplicates├──  NO  ───────┐
                    │   List to   └──────────┘  Set to       │
                    │  be selected              be selected  │
                    │                                        v
                    v                                    ┌───────────┐☜ order established at
        ┌─────────────────────┐                          │ Maintains │  write time
        │  Unknown number     │                          │ INSERTION │
   ┌─NO─┤of elements will be  ├YES─┐           ┌───YES───┤   ORDER ? ├──NO──┐  order requested
   │    │added and/or index   │    │           │         └───────────┘      │  at read time
   │    │based search will not│    │           v                            ↓  ☟
   │    │be frequent?         │    │       LinkedHashSet            ┌────────────┐
   │    └─────────────────────┘    │                                │ Mantains   │
   v                               v                           ┌─NO─┤ READ ORDER ├YES┐
  ArrayList              LinkedList                            │    │(alpha,...)?│   │
                                                               │    └────────────┘   │
                                                               │                     │
                                                               v                     v
                                                            HashSet              TreeSet

   ● Comparative
Standard   non-concurrent  SDK:
       ┌──────────────────────────────────────────────────────────────────────────────────────────
       │                                IMPLEMENTATIONS
       ├──────────────────────────────────────────────────────────────────────────────────────────
       │ Hash Table        │ Resizable Array   │Balanced Tree │ Linked List │ HashTable+LinkedList
       │                   │                   │              │             │
┌──────┼───────────────────┼───────────────────┼──────────────┼─────────────┼─────────────────────
│<Set> │ HashSet           │                   │  TreeSet     │             │ LinkedHashSet
│      │                   │                   │              │             │
├──────┼───────────────────┼───────────────────┼──────────────┼─────────────┼─────────────────────
│<List>│                   │ ArrayList         │              │ LinkedList  │
│      │                   │ Vector            │              │ LinkedList  │
├──────┼───────────────────┼───────────────────┼──────────────┼─────────────┼─────────────────────
│<Map> │ HashMap,Hashtable │                   │  TreeMap     │             │ LinkedHashMap
└──────┴───────────────────┴───────────────────┴──────────────┴─────────────┴─────────────────────

  WARN : There is a huge performance difference LinkedList and ArrayList.
         - when there is a large number of add/remove operations LinkedList is much faster.
         - When there is a lot of random access operations ArrayList is much faster.

 INTERFACES
@[http://download.oracle.com/javase/6/docs/api/java/util/HashSet.html]
@[http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html]
@[http://download.oracle.com/javase/6/docs/api/java/util/LinkedHashSet.html]
@[http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html]
@[http://download.oracle.com/javase/6/docs/api/java/util/LinkedList.html]
@[http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html]
@[http://download.oracle.com/javase/6/docs/api/index.html]
@[http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html]
@[http://download.oracle.com/javase/6/docs/api/java/util/LinkedHashMap.html]


<a href="http://files.zeroturnaround.com/pdf/zt_java_collections_cheat_sheet.pdf">ref</a>
┌─────────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────────┐
│Collection       │ Thread-safe                ┃          YOUR DATA              ┃           OPERATIONS    ALLOWED       │
│                 │ alternative                ┃─────────────────────────────────┃───────────────────────────────────────┤
│class            │                            ┃Individu│Key-val.│Duplica│Primite┃ Iteration Order │Fast │ Random Access │
│                 │                            ┃elements│  pairs │element│support┃FIFO │Sorted│LIFO│'has'│By  │By   │By  │
│                 │                            ┃        │        │support│       ┃     │      │    │check│Key │Val  │Idx │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│HashMap          │ ConcurrentHashMap          ┃        │YES     │       │       ┃     │      │    │YES  │ YES│     │    │
│                 │                            ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│SortedMap        │ ?                          ┃        │YES     │       │       ┃     │      │    │?    │ YES│     │    │
│                 │                            ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│NavigableMap @1  │ ?                          ┃        │YES     │       │       ┃     │      │    │?    │ YES│     │    │
│                 │                            ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│HashBiMap(Guava) │ Maps.syncrhonizedBiMap     ┃        │YES     │       │       ┃     │      │    │YES  │ YES│YES  │    │
│                 │ (new HashBiMap())          ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│ArrayListMultimap│ Maps.synchronizedMultiMap  ┃        │YES     │YES    │       ┃     │      │    │YES  │ YES│     │    │
│   (Guava)       │ (new ArrayListMultimap())  ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│LinkedHashMap    │ Collections.syncrhonizedMap┃        │YES     │       │       ┃YES  │      │    │YES  │ YES│     │    │
│                 │ (new LinkedHashMap())      ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│TreeMap          │ ConcurrentSkipListMap      ┃        │YES     │       │       ┃     │YES   │    │YES  │ YES│     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│Int2IntMap       │                            ┃        │YES     │       │YES    ┃     │      │    │YES  │ YES│     │YES │
│(Fastutil)       │                            ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│ArrayList        │ CopyOnWriteArrayList       ┃YES     │        │YES    │       ┃YES  │      │YES │     │    │     │YES │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│HashSet          │ Collections.newSetFromMap  ┃YES     │        │       │       ┃     │      │    │YES  │    │YES  │    │
│                 │ (new ConcurrentHashMap())  ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│IntArrayList     │                            ┃YES     │        │YES    │YES    ┃YES  │      │YES │     │    │     │YES │
│(Fastutil)       │                            ┃        │        │       │       ┃     │      │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│PriorityQueue    │ PriorityBlockingQueue      ┃YES     │        │YES    │       ┃     │YES   │    │     │    │     │    │
┼─────────────────┼────────────────────────────┃────────┼────────┼───────┼───────┃─────┼──────┼────┼─────┼────┼─────┼────┤
│ArrayDeque       │ ArrayBlockingQueue         ┃YES     │        │YES    │       ┃YES  │      │YES │     │    │     │    │
└─────────────────┴────────────────────────────┃────────┴────────┴───────┴───────┃─────┴──────┴────┴─────┴────┴─────┴────┘

 Collection class │  Random access by idx/key │ Search/Contains │ Instert
 ─────────────────┼───────────────────────────┼─────────────────┼───────────
 ArrayList        │  O(1)                     │ O(n)            │ O(n)
 HashSet          │  O(1)                     │ O(1)            │ O(1)
 HashMap          │  O(1)                     │ O(1)            │ O(1)
 TreeMap          │  O(log(n))                │ O(log(n))       │ O(log(n))

@1 NavigableMap: SortedMap with additional methods for finding entries
                 by their ordered position in the key set.
                 So potentially this can remove the need for iterating
                 in the first place - you might be able to find the
                 specific entry you are after using the higherEntry,
                 lowerEntry, ceilingEntry, or floorEntry methods. The
                 descendingMap method even gives you an explicit method
                 of reversing the traversal order.

● Graph Structures
https://guava.dev/releases/20.0/api/docs/com/google/common/graph/package-summary.html

Interface               Description
Graph<N>                An interface for graph-structured data, whose edges are
                        anonymous entities with no identity or information of their own.
MutableGraph<N>         A subinterface of Graph which adds mutation methods.
MutableNetwork<N,E>     A subinterface of Network which adds mutation methods.
MutableValueGraph<N,V>  A subinterface of ValueGraph which adds mutation methods.
Network<N,E>            An interface for graph-structured data, whose edges are unique objects.
ValueGraph<N,V>         An interface for graph- structured data, whose edges have associated
                        non-unique values.
[[}]]


[[}]]

[[{data_structures.101,qa]] #[data_structures_101_summary]
● Lists
 INITIALIZING A LIST
final List<String> myList =                  ← final forbid re-asigning the list,
      Arrays.asList("one", "two", "three");     but its content is still mutable
      myList.add("four");

final List<String> myInmmutableList =        ← inmutable version (thread safe)
      Collections.unmodifiableList(myList);


String[] array01 = ...;
final      List<String> readOnlyList  ← Inmutable ArrayList (static class inside Arrays),
       = Arrays.asList(arr);            lacks set(), get(), contains() or "adding" methods
                                        providing for a read-only view.

final ArrayList<String> mutableList   ← Mutable list.
       = new ArrayList<String>(
         Arrays.asList(arr));

● Collection (Lists/Set/...) "Walk-over"
 for ( int idx = 0; idx < collection   .length ; idx++) { ← Alt 1: Java 1.0 for-walk over collection index.
   type array_element = collection   .get(idx);           ←   WARN:  Very slow for LinkedLists
 }                                                                   (Faster for other List implementations)

 for ( Iterator iterator = collection   .iterator() ;     ← Alt 2: for-walk over iterator. Preferred:
        iterator.hasNext(); ) {                                    safer when removing/modifying the collection
   type type = (type)   iterator.next() ;                          while iterating over it.
 }

 for ( iterable_type iterable_element   :collection ) {   ← Alt 3: Best option when NOT remov./modify. elements
   ...
 }

 collection .forEach ((element) -> {                      ← Alt 4: STREAMS (Java 8+): UNIX pipe like iteration.
   System.out::println(element)                             Functional approach. In this case we can "shortcut" to:
 });                                                        collection.forEach(System.out::println);

<hr/>

● Maps ("Dictionaries")
  ######################
  # INITIALIZING A MAP #
  ######################
final Map<String,String> myMap =                          ← Mutable map (WARN: even if 'final' used)
      new HashMap<String,String>();
  myMap.put("k1", "k2");
  ...
  final Map<String,String> myInmutableMap =               ← Inmutable version of map
        Collections.unmodifiableMap(temp);

  final HashMap<String,String> data =  HashMapBuilder     ← Java 7+ must have even number of elements
        .build( "k1","v1", "k2","v2", ...);

  final Map<String, String> inumtableMap01 =              ← Java 9+ must have even number of elements
        Map.of("k1", "v1", "k2", "v2");

  final Map<String, String> inmutableMap02 =              ← Java 9+ (Safer syntax)
        Map.ofEntries( entry("k1", "k2"),...);

  final Map<String, String> test =                        ← Guava ImmutableMap
        ImmutableMap.of("k1","v1", ...);                    works only with up to 5 key/value pairs

  final Map<String, String> test =                        ← Guava ImmutableMap alternative
        ImmutableMap.<String, String>builder()
        .put("k1", "v1").put("k2", "v2")
        ...
        .build();

  ###########################
  # WALK-OVER/ITERATE A MAP #
  ###########################

 Map<String, String> map = ...
 for ( Map.pair<String, String>   pair  :
       map .pairSet() ) {                                 ← Alt 1: pairSet (Java 5+)
  ... pair.getKey() ... pair.getValue() ...
 }

 Iterator<Map.Entry<String, String>> it =                 ← Alt 2: (Java 7?) using iterators
       map.entrySet .iterator() ;
 while (it.hasNext()) {
   const Map.Entry<Integer, Integer> pair =  it.next();
  ... pair.getKey() ... pair.getValue() ...
 }

 for ( Map.Entry<Integer, Integer> pair :                 ← Alt 3: USING "for : entrySet"
          myMap .entrySet() ) {
  ... pair.getKey() ... pair.getValue() ...
 }

 map.forEach((k, v) -> {                                  ← forEach (java 8+)
  ... pair.getKey() ... pair.getValue() ...


  map.entrySet().stream().forEach( (pair) -> {            ← Stream API (1.8+)
  ... pair.getKey() ... pair.getValue() ...                 "Functional" Unix Pipe like style
  } );

  map.entrySet().stream().                                ← Stream API parallel (1.8+)
  .parallel().forEach( pair -> {                            "Functional" Unix Pipe like style
  ... pair.getKey() ... pair.getValue() ...
  ) );

  ##############
  # UPDATE MAP #
  ##############

Map<String, Double> map01 = new HashMap<>();
  map01.put("key1", 1);
  map01.put("key2", 2);
  map01.put("key3", 3);                    ← Update (Before Java 8). Alt 1: Do not check for key existence.
  if (map01.containsKey("key3")) {
    map01.put("key3", 3);                  ← Update (Before Java 8). Alt 2:        check for key existence.
  }

  Integer oldValue = map01                 ← Java 8+ . Returns nulls if key1 didn't exists
         .replace("key1", 10);
  boolean isOK = map01.replace("key1",     ← Java 8+. Safer variant. Update fails if old value
           1 /*old value*/,                  is null or changed. Most probably false will throw
          10 /* new value */ );              a RuntimeError.

  map01.getOrDefault("key4", 0));          ← Return default for non-existing key (vs null)    [qa]

  map01.putIfAbsent ("key4", 4));          ← Update only if absent or value null.             [qa]


  const BiFunction<Integer, Integer, Integer>
      sumFun = (x1, x2) -> x1 + x2;

  map01.compute("key1",                         ← Use bifunction to update. NullPointerException
    (key, currentValue)                           if key doesn't exit.
        -> sumFun.apply(currentValue, 2));        (alternatively computeIfAbsent / computeIfPresent )

  map01.merge("key1", defaultValue,             ← Update with BiFunction if key exists.
    (key, currentValue)                           or add defValue to key otherwise.
        -> sumFun.apply(v, 2));


<hr/>
● java.util.Collections
(@[https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html] )
- Utility class with static methods that operate on or return collections


  Collections.EMPTY_SET  ( == Collections.emptySet()         ) See also Collections.singleton(T o)
  Collections.EMPTY_LIST ( == Collections.emptyList()        ) See also Collections.singletonList(T o)
  Collections.EMPTY_MAP  ( == Collections.emptyMap()         ) See also Collections.singletonMap(K key, V value)
                              Collections.emptyEnumeration()
                              Collections.emptyIterator()
                              Collections.emptyListIterator()

  boolean      Collections.addAll(Collection c, T... elements)           Adds all elements to collection 'c'
  Queue        Collections.asLifoQueue(Deque deque)                      deque to Last-In/First-Out "LIFO" Queue view
  int          Collections.binarySearch(List list, T key)                Searches key in list using binary search.
  int          Collections.binarySearch(List list, T key, Comparator c)  Searches key in list using binary search + comparator.

  Collection   Collections.checkedCollection(Collection c, Class type)   Returns a dynamically typesafe view of input collection/list/...
  List         Collections.checkedList(List list, Class type)
  Map          Collections.checkedMap
                           (Map m, Class keyType, Class valueType)
  Set          Collections.checkedSet(Set s, Class type)
  SortedMap    Collections.checkedSortedMap
                           (SortedMap m, Class keyType, Class valueType)


  SortedSet    Collections.checkedSortedSet(SortedSet s, Class type)
  void         Collections.copy(List dest, List src)                     Copies src list elements to dest list
  boolean      Collections.disjoint(Collection c1, Collection c2)        true if c1/c2 have no elements in common.

  Enumeration  Collections.enumeration(Collection c)                     Returns an enumeration over the specified collection.

  void         Collections.fill(List list, T obj)                        Replaces all of the elements of the specified list with the specified element.
  int          Collections.frequency(Collection c, Object o)             Returns the number of elements in the specified collection equal to the specified object.
  int          Collections.indexOfSubList(List list, List sublist)       -1 if not found.
  int          Collections.lastIndexOfSubList(List list, List sublist)   -1 if not found.
  ArrayList    Collections.list(Enumeration e)                           Enum to array list in the order they are returned by input enum.
  T            Collections.max/min(Collection coll (, Comparator comp))  max/min element of collection, according to comparator order.(Def to natural ordering)
  List         Collections.nCopies(int nCopies, T inputObject)
  Set          Collections.newSetFromMap(Map map)
  boolean      Collections.replaceAll(List list, T oldVal, T newVal)     ← NOTE: Replaces in list
  void         Collections.reverse(List list)
  Comparator   Collections.reverseOrder()                                Return <<Comparable>> Comparator imposing reverse natural ordering.
  Comparator   Collections.reverseOrder(Comparator cmp)                  Returns               comparator imposing reverse ordering of input comparator.
  void         Collections.rotate(List list, int distance)               Rotates elements in list.
  void         Collections.shuffle(List list (, Random rnd) )            Randomly permutes elements using source of randomness (or def. src of randomness).
  void         Collections.sort(List list (, Comparator c))              Sorts in comparator (def. to natural) order.
  void         Collections.swap(List list, int pos1, int pos2)           Swap elemnts in pos 1 and 2.
  Collection   Collections.synchronizedCollection(Collection c)          Returns thread-safe collection       [qa]
  List         Collections.synchronizedList(List list)                   Returns thread-safe list             [qa]
  Map          Collections.synchronizedMap(Map m)                        Returns thread-safe map              [qa]
  Set          Collections.synchronizedSet(Set s)                        Returns thread-safe set              [qa]
  SortedMap    Collections.synchronizedSortedMap(SortedMap m)            Returns thread-safe sorted map       [qa]
  SortedSet    Collections.synchronizedSortedSet(SortedSet s)            Returns thread-safe sorted set       [qa]
  Collection   Collections.unmodifiableCollection(Collection c)          Returns inmutable view               [qa]
  List         Collections.unmodifiableList(List list)                   Returns inmutable view               [qa]
  Map          Collections.unmodifiableMap(Map m)                        Returns inmutable view               [qa]
  Set          Collections.unmodifiableSet(Set s)                        Returns inmutable view               [qa]
  SortedMap    Collections.unmodifiableSortedMap(SortedMap m)            Returns inmutable view               [qa]
  SortedSet    Collections.unmodifiableSortedSet(SortedSet s)            Returns inmutable view               [qa]


[[{data_structures,01_PM.backlog]]
<a xsmall href="http://fastutil.di.unimi.it/">Fastutil</a>
- Fast and compact type-specific collections for Java
  Great default choice for collections of primitive types,
  like int or long. Also handles big collections with more than 2
  31 elements well.

<a xsmall href="https://www.eclipse.org/collections/">Eclipse Collections</a>
(Originated from Goldman Sachs gs-collection:
 @[https://github.com/goldmansachs/gs-collections])
- Features you want with the collections you need
  Previously known as gs-collections, this library
  includes almost any collection you might
  need: primitive type collections, multimaps,
  bidirectional maps and so on.
[[}]]

[[{data_structures.101]]
● <<Enumeration>>(1.0) vs <<Iterator>>(1.7)
@[https://stackoverflow.com/questions/948194/difference-between-java-enumeration-and-iterator]

- both interfaces will give successive elements

- Iterators allow the caller to remove elements from
  the underlying collection during the iteration with
  well-defined semantics.
  (additional remove method)
- Iterators Method names have been improved.

- Iterators are fail-fast:
  - If thread A changes the collection, while
       thread B is traversing it, the iterator implementation
       will try to throw a ConcurrentModificationException
       (best effort since it can not always be guaranteed)
  - The fail-fast behavior of iterators can be used only to
    detect bugs sin the best effort doesn't warrant its trigger.
  - newer 'concurrent' collections will never throw it.
    Reading thread B will traverse the collection "snapshot" at
    the start of read.



- Iterator should be preferred over Enumeration
  taking the place of Enumeration in collections framework


  Enumeration     │ Iterator
  ────────────────┼────────────
  hasMoreElement()│ hasNext()
  nextElement()   │ next()
                  │ remove() ← optional: not implemented in many classes
[[}]]
[[$div}]]
[[{$div]]
[[{$div]]
● NIO [[{async/reactive.io]]
<a xsmall href="http://tutorials.jenkov.com/java-nio/buffers.html">NIO (1.4+)</a>
- Replaced OLD blocking IO based on [ byte/char, read-or-write streams ]
┌──────────┐     ┌──────────────┐
│ CORE NIO │     │ NON─BLOCKING │
├──────────┴───┐ ├──────────────┴────────────────────────────────┐
│ ─  CHANNELS  │ │· a thread requests a channel the intention    │
│  ─ read/write│ │  to read/write data into a buffer:            │
│ ─  BUFFERS   │ │  · While the channel moves data into/from     │
│ ─  SELECTORS │ │   the buffer, the thread continues another job│
└──────────────┘ │  · When data is ready, the thread is notified │
                 └───────────────────────────────────────────────┘
Channel  : File,Datagram/UDP,Socket/TCP,ServerSocket,...
Buffer of: Byte|Char|Double|Float|Int|Long|Short|MappedByte)Buffer


┌───────────────┐
│  NON─CORE NIO │
├───────────────┴─────────────────────────────────────────────────────┐
│ ─ components like Pipe and FileLock can be considered               │
│   "utility classes" supporting the first three ones.                │
│                                                                     │
│ ─ "SELECTORS" objects monitor one+ channels for events              │
│   (connection opened, data arrived, ..):                            │
│   ─ Thus, a single thread can monitor multiple channels for data.   │
│     (Very handy if app has many connections/Channels/clients open   │
│     but with low traffic on each connection.                        │
│   ─ To use selectors:                                               │
│     ─ Instantiate the selector                                      │
│     ─ Register one+ channels with it                                │
└─────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ BUFFER                                                                                           │
│  ATTRIBUTES                                              METHODS                                 │
│          ┌─────────────────┬───────────────────────────┐ ┌─────────────┬───────────────────────┐ │
│          │ write mode      │  read mode                │ │rewind()     │                       │ │
│ ┌────────┼─────────────────┴───────────────────────────┤ │             │                       │ │
│ │capacity│ fixed size of memory block implementing     │ ├─────────────┼───────────────────────│ │
│ │        │ the buffer                                  │ │clear()      │                       │ │
│ ├────────┼─────────────────┬───────────────────────────┤ │compact()    │                       │ │
│ │position│ starts at 0,    │ starts at 0 (after "flip")│ ├─────────────┼───────────────────────│ │
│ │        │ increase at each│ increase at each          │ │mark()       │"bookmark position"    │ │
│ ├────────┼─────────────────┼───────────────────────────┤ │reset()      │ and return "bookmark" │ │
│ │   limit│ element written │ element read              │ ├─────────────┼───────────────────────│ │
│ │        │ == capacity     │ == last written position  │ │equals()     │using only the         │ │
│ └────────┴─────────────────┴───────────────────────────┘ │compareTo()  │remaining-to-read bytes│ │
│                                                          │             │for the computation    │ │
│                                                          └─────────────┴───────────────────────┘ │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────────────────────────
│ SEQUENCE TO READ/WRITE DATA                   ┌───────┐
│try (  /* try-with 1.7+ */                     │SUMMARY│
│  RandomAccessFile   aFile  =                  ├───────┴──────────────────────────
│    new RandomAccessFile("nio-data.txt", "rw") │-1 ) Write data into the Buffer
│) throws IOException {                         │-2 ) Call buffer. flip()
│  FileChannel   inChannel  =                   │     switch writing/reading mode
│      aFile .getChannel();                     │-3 ) Read data out of the Buffer
│                                               │-4a) buffer.clear();  ← alt1: clear all buffer
│  ByteBuffer   buf =                           │-4b) buffer.compact() ← alt2: clear only data read
│      ByteBuffer.allocate(48 /*capacity*/);    ├────────────────────────────────────
│                                               │ channelIn → (data) → buffer
│                                               │ buffer    → (data) → channelOut
│  int  bytesRead =                             └────────────────────────────────────
│         inChannel .read(  buf );  // ←   buf  now
│                                          in write mode
│  while  ( bytesRead  != -1)
│  {
│      buf . flip ();               // ←   buf  now
│    while(  buf .hasRemaining()){         in read mode
│        System.out.print(
│           (char)   buf .get()     // ← alt.1: read 1 byte
│        );                                     at a time
│        // channel2.write(  buf )  // ← alt.2: read data
│    }                                         in channel2
│      buf .clear();                // ← make buffer
│                                        ready-for-writing
│     bytesRead  =   inChannel      // ←   buf  now
│                    .read(  buf );        in write mode
│  }
│}
└──────────────────────────────────────────────────────────────────────────────────────────────────

┌────────────────┐
│ SCATTER-GATHER │
├────────────────┴─────────────────────────────────┬──────────────────────────────────────────────────┐
│  scattering channel read                         │ scattering-write to channel                      │
│ - channel → read to → buffer1, buffer2, ....     │ - buffer1, buffer2, ...→ write to → channel      │
│ - Ex:                                            │ - ex:                                            │
│   ByteBuffer header = ByteBuffer.allocate(128);  │   ByteBuffer header = ByteBuffer.allocate(128);  │
│   ByteBuffer body   = ByteBuffer.allocate(1024); │   ByteBuffer body   = ByteBuffer.allocate(1024); │
│   ByteBuffer[]   bufferArray  = { header, body };│   ByteBuffer[]   bufferArray  = { header, body };│
│   channel .read(  bufferArray );                 │   channel .write(  bufferArray );                │
│            ^^^^                                  │                                                  │
│ fill up one buffer before moving on to the next  │                                                  │
│ (not suited for undefined size messages)         │                                                  │
└──────────────────────────────────────────────────┴──────────────────────────────────────────────────┘

  CHANNEL-TO-CHANNEL
 - If one the the channels is FileChannel :
   - FileChannel transferTo()/transferFrom()  can be used to move data between channels
     WARN: Some SocketChannel implementations may transfer only the data the SocketChannel
     has ready in its internal buffer here and now
   ┌─────────┐
   │Examples.│
   ├─────────┴───────────────────────────────────┬─────────────────────────────────────────────┐
   │  FileChannelG fromChannel =                 │  FileChannelG fromChannel =                 │
   │     (new RandomAccessFile("from.txt", "rw"))│     (new RandomAccessFile("from.txt", "rw"))│
   │     .getChannel(),                          │     .getChannel(),                          │
   │  FileChannel   toChannel =                  │  FileChannel   toChannel =                  │
   │     (new RandomAccessFile(  "to.txt", "rw"))│     (new RandomAccessFile(  "to.txt", "rw"))│
   │     .getChannel();                          │     .getChannel();                          │
   │  long count    =  fromChannel .size();      │  long count    = ;                          │
   │  toChannel  .transferFrom (                 │  fromChannel  .transferTo (                 │
   │       fromChannel ,                         │      0 /*position*/,                        │
   │       0       , // posit.in dest-file to    │      fromChannel .size() /*count*/,         │
   │                 // start writing from       │      toChannel );                           │
   │       maxCount  /* max-bytes to transfer*/  │                                             │
   │  );                ^^^^^^^^^                │                                             │
   │                    constrained by data      │                                             │
   │                    in source                │                                             │
   └─────────────────────────────────────────────┴─────────────────────────────────────────────┘
[[}]]

● API tree [[{async/reactive.io.network,persistence.fs]]
JDK 8
./java/nio/
           Bits ByteOrder CharBufferSpliterator
           ByteBufferAs(Char|Double|Float|...)Buffer(B|L|...
           (|Float|Double|StringChar)Buffer
           HeapByteBuffer Heap(Byte|Char|...)Buffer(R) HeapCharBuffer
           (Int|Long|...)Buffer
           (Mapped|Direct)ByteBuffer(R)
           Direct(Byte|Char|Double|...)Buffer

./java/nio/channels/
                    Channel Channels CompletionHandler FileLock MembershipKey Pipe Selector SelectionKey
                    Asynchronous(|Byte)Channel
                    AsynchronousChannelGroup
                    AsynchronousFileChannel
                    AsynchronousServerSocketChannel
                    AsynchronousSocketChannel
                    (Byte|Datagram|File|GatheringByte|Interruptible|Multicast|
                     Network|ReadableByte|ScatteringByte|SeekableByte|Selectable|
                     ServerSocket|Socket|WritableByte)Channel
                   /spi/Abstract(Interruptible|Selectable)Channel
                        Abstract(SelectionKey|Selector)
                        (AsynchronousChannel|Selector)Provider

./java/nio/charset/
                   Charset(|Decoder|Encoder) StandardCharsets
                   CoderResult CodingErrorAction
                  /spi/CharsetProvider

./java/nio/file/attribute/AclEntry(|Flag|Permission|Type)
                          (|AclFile|BasicFile|DosFile|File|
                            FileOwner|FileStore|PosixFile|
                            UserDefinedFile)AttributeView
                          (BasicFile|DosFile|PosixFile)Attributes
                          FileAttribute FileTime
                          GroupPrincipal

                          UserPrincipal(LookupService)
./java/nio/file/
                AccessMode CopyMoveHelper CopyOption DirectoryStream Files
                LinkOption LinkPermission Path        PathMatcher        Paths
                SecureDirectoryStream
                File(Store|System|Systems|TreeIterator|TreeWalker|VisitOption|Visitor|VisitResult)
                SimpleFileVisitor
                OpenOption    Standard(Copy|Open)Option
                StandardWatchEventKinds
                StandardWatchEventKinds$StdWatchEventKind
                TempFileHelper
                Watchable      Watch(Event|Key|Service)
                spi/FileSystemProvider
                    FileTypeDetector
[[}]]

[[{]]async/reactive.io.network" >
● SELECTORS
@[https://docs.oracle.com/javase/7/docs/api/java/nio/channels/Selector.html]

- A Selector allows a single thread to manage multiple channels
  (network connections), by examining which ones are ready for
  connect,accept,read,write

- A channel that "fires an event" is also said to be "ready" for that event.

 REGISTERING A SELECTOR                               │ USING SELECTORS
 AND ASSIGNING CHANNELS                               │
    │  Selector   selectoR  = Selector.open();        │  STEP
    │  channel.configureBlocking(false);              │  call one of the select() methods
    │          ^^^^^^^^^^^^^^^^^^^^^^^^               │  (upon registering 1+ channels)
    │   //     non-blocking-mode required             │  int select(long mSecTimeout) ← block until channel/s ready
    │   //   WARN:  FileChannel can NOT be switched   │             └────(optional)┘
    │   //   into NON-blocking mode and so            │  int selectNow()              ← Don't block even if none read
    │   //   they can NOT be used with selectors.     │  └┬┘
┌───→  SelectionKey key  = channel.register(          │  indicates how many channels became ready since last select() call.
│   │      selector ,                                 │
│   │    SelectionKey.OP_READ |                       │  STEP
│   │    SelectionKey.OP_WRITE);                      │  examine ready channels returned by select like:
│   │                 ^^^^^^^                         │  Set<SelectionKey> selectedKeys =
│   │                 Or-set of interest:             │                      selectoR .  selectedKeys() ;
│   │                 OP_CONNECT / OP_ACCEPT          │  Iterator<SelectionKey> keyIterator =
│   │                 OP_READ    / OP_WRITE           │                    selectedKeys.iterator();
│   │  ^^^^^^^^^^^^^^^^                               │  while(keyIterator.hasNext()) {
│   │                                                 │      SelectionKey key = keyIterator.next();
│ ┌─→  key .attach(extraInfoObject);                  │      //  "cast to proper channel"
│ │ │  Object attachedObj =                           │             if (  key .isAcceptable ()) {
│ │ │     selectionKey.attachment();                  │        ... connection accepted by ServerSocketChannel
│ │ │                                                 │      } else if (  key .isConnectable()) {
│ │ │                                                 │        ... connection established with remote server
│ │ │ // After selection                              │      } else if (  key .isReadable   ()) {
│ │ │ // ^^^^^^^^^^^^^^^                              │        ... channel ready for reading
│ │ │ // explained later                              │      } else if (  key .isWritable   ()) {
│ │ │                                                 │        ... channel ready for writing
│ │ │ // Alternative 1:                               │      }
│ │ │ int   readySet =   key .readyOps();             │      keyIterator.remove();
│ │ │ boolean isAcceptable  =                         │  }
│ │ │           readySet  ⅋ SelectionKey.OP_ACCEPT;   │  STEP
│ │ │ ...                                             │  selector .close()
│ │ │ // Alternative 2:                               │            ^^^^^
│ │ │   key .isAcceptable();                          │   must be called after finishing ussage,
│ │                                                   │   invalidating all SelectionKey instances
│ └─── (optional) user attached object,               │   registered with this Selector.
│      handy way to recognize a given                 │   The channels themselves are not closed.
│      channel, provide extra info
│      (buffer/s,...)
│
└───   key  can be queried like:
       intO interestSet  =   key .interestOps()*;
       boolean isInterestedInAccept
           =   interestSet  ⅋ SelectionKey.OP_ACCEPT;

  NOTE:
  - A thread blocked by a call to select() can be forced to leave the select() method,
     even if no channels are yet ready by having a different thread call
     the   selectoR . wakeup()  method on the Selector which the first thread has
     called select() on:
     - The thread waiting inside select() will then return immediately.
     - If a different thread calls wakeup() and no thread is currently
       blocked inside select(), the next thread that calls select()
       will "wake up" immediately.
[[}]]

[[{]]async/reactive.io,persistence.FS," >
● FileChannel
- Java NIO FileChannel: channel connected to a file allowing to
      read data from  and write data to a file.
- A FileChannel canNOT be set into non-blocking mode:
  It always runs in blocking mode

- Reading from FileChannel (Writting to buffer):
  |/* You cannot open a FileChannel directly,
  | * first you obtain a FileChannel via an (Input|Output)Stream or a RandomAccessFile
  | */
  |RandomAccessFile   aFile      = new RandomAccessFile("data/nio-data.txt", "rw");
  |// Reading from channel
  |try (  /* try-with 1.7+ */
  |  RandomAccessFile   aFile  = new RandomAccessFile("data/nio-data.txt", "rw")
  |) throws IOException {
  |  FileChannel   inChannel  =   aFile .getChannel();
  |
  |  ByteBuffer   buf  = ByteBuffer.allocate(48 /* capacity*/);
  |
  |  int  bytesRead  =   inChannel .read(  buf ); //   buf  now in write mode
  |  while ( bytesRead  != -1) {
  |      buf .flip();                            //   buf  now in read mode
  |    while(  buf .hasRemaining()){
  |        // alt. read data directly, 1 byte at a time
  |        System.out.print((char)   buf .get());
  |        // alt. read data in channel
  |        // anotherChannel.write(  buf )
  |    }
  |
  |      buf .clear(); //make buffer ready for writing
  |     bytesRead  =   inChannel .read(  buf ); //   buf  now in write mode
  |  }

- Writing to a FileChannel (reading from buffer)
  | String newData = "......" + System.currentTimeMillis();
  | ByteBuffer   buf  = ByteBuffer.allocate(48);
  |   buf .clear();
  |   buf .put(newData.getBytes());
  |   buf .flip(); // change buffer from write to read
  |  while(  buf .hasRemaining()) {  channelO .write (  buf );  }
  | channel.close();


- FileChannel Position
  | long pos = fileChannel.position(); // obtain current position
  | fileChannel.position(pos +123); // change position

   - If you set the position after the end of the file,
     and try to read from the channel, you will get -1
   - If you set the position after the end of the file,
     and write to the channel, the file will be expanded
     to fit the position and written data. This may result
     in a "file hole", where the physical file on
     the disk has gaps in the written data.

- FileChannel Size
  | long fileSize = fileChannel.size();
                                ^^^^^^
                            size of the file
                            connected to channel

- FileChannel (file) Truncate
  | fileChannel.truncate(1024 /*length*/);

- FileChannel Force:
  flushes all unwritten data from the channel and OS cache to the disk
  | channel.force(true /* flush also file meta-data like permissions....*/);
[[}]]

[[{async/reactive.io,java_lang.functional]]
● Pipe
- Pipe: one-way data connection between two threads
  └"=="  source channel   ← One threads writes to sink
        +  sink channel   ← One threads reads from source
  Ex:
    ByteBuffer   buf  = ByteBuffer.allocate(48);
      buf .clear();
      buf .put(newData.getBytes());

    // WRITING TO PIPE
    Pipe pipe = Pipe.open();
    Pipe.SinkChannel sinkChannel = pipe.sink();
    String newData = "..." + System.currentTimeMillis();
      buf .flip();
    while(  buf .hasRemaining()) { sinkChannel.write(  buf ); }

    // READING FROM A PIPE
    To read from a Pipe you need to access the source channel. Here is how that is done:
    Pipe.SourceChannel sourceChannel = pipe.source();
    int  bytesRead  =   inChannel .read(buf2);
[[}]]

● SocketChannel [[{async/reactive.io.network]]
  There are two ways a SocketChannel can be created:

  // Opening a SocketChannel
  SocketChannel socketChannel = SocketChannel.open();
  socketChannel.connect(new InetSocketAddress("http://jenkov.com", 80));

  // Reading (writing to buffer)
  ByteBuffer   buf  = ByteBuffer.allocate(48);
  int  bytesRead  = socketChannel.read(  buf ); // If -1 is returned, the end-of-stream is reached (connection is closed)

  // Writing to a SocketChannel
  String newData = "..." + System.currentTimeMillis();
  ByteBuffer   buf  = ByteBuffer.allocate(48);
    buf .clear();
    buf .put(newData.getBytes());
    buf .flip();
  while(  buf .hasRemaining()) { channel.write(  buf ); }

  socketChannel.close();
[[}]]
[[$div}]]
[[{$div]]
[[{async/reactive.io.network]]
● Non-blocking Mode
- socketChannel .configureBlocking(false) ;
- Calls to connect(), read() and write() will not block
- In non-blocking mode connect() calls may return before
  the connection is established:
  - To determine whether the connection is established
    use finishConnect() like this:

  | socketChannel.configureBlocking(false);
  | socketChannel.connect(
  |   new InetSocketAddress("http://jenkov.com", 80));
  |
  | while(! socketChannel.finishConnect() ){
  |     //wait, or do something else...
  | }

NOTE: non-blocking works much better with Selector's
[[}]]

● ServerSocketChannel [[{async/reactive.io.network]]
ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

serverSocketChannel.socket().bind(new InetSocketAddress(9999));
serverSocketChannel.configureBlocking(false);

while(true){
    SocketChannel socketChannel =
            serverSocketChannel.accept(); // in blocking mode waits until incoming connection arrives
    if(socketChannel != null /* always false in blocking mode */){
        //do something with socketChannel...
    }

    //do something with socketChannel...
}

serverSocketChannel.close()
[[}]]

● Datagram Channel [[{async/reactive.io.network]]
- Since UDP is a connection-less network protocol, you cannot just
  by default read and write to a DatagramChannel like you do from
  other channels. Instead you send and receive packets of data

  | DatagramChannel channel = DatagramChannel.open();
  | channel.socket().bind(new InetSocketAddress(9999));
  |
  | ByteBuffer   buf  = ByteBuffer.allocate(48);
  |   buf .clear();
  | // WARN: if read data is bigger than buffer size remaining data is discarded silently
  | channel.receive(  buf );
  |
  | // Write to channel
  | String newData = "..." + System.currentTimeMillis();
  |   buf .clear();
  |   buf .put(newData.getBytes());
  |   buf .flip();
  |
  |
  | // WARN:  No notice is received about packet delivery (UDP does not make any guarantees)
  | int bytesSent = channel.send(  buf , new InetSocketAddress("jenkov.com", 80));
  |
  | // Alternatively you can "Connect" to a Specific Address. Since UDP is connection-less,
  | // connecting to a remote address just means that the DatagramChannel can only send/receive
  | // data packets from a given specific address.
  | channel.connect(new InetSocketAddress("jenkov.com", 80));
  | int  bytesRead  = channel.read(  buf );
  | int bytesSent = channel.write(  buf );
[[}]]

[[{async/reactive.io.network]]
● NonBlocking Server
REF:
- @[http://tutorials.jenkov.com/java-nio/non-blocking-server.html]
- @[https://github.com/jjenkov/java-nio-server]
- Non-blocking IO Pipelines:
read-write pipeline:  channelIn  → selector → component → ... → componentN →  channelOut
read-only  pipeline:  channelIn  → selector → component → ... → componentN
write-only pipeline:                        component → ... → componentN →  channelOut
Note: It is the component that initiates reading of data from the Channel via the Selector
read-pipeline read from stream/channelIn and split data into messages like:

Data   → Message → Message
Stream   Reader    Stream

- A blocking Message Reader/Writer is simpler, since it
  has never to handle situations where no data was read
  from the stream, or where only a partial message was
  read from the stream and message parsing needs to be
  resumed later.
- The drawback of blocking is the requirement of separate
  threads for each parallel stream, which is a problem if the
  server has thousands of concurrent connections
- Each thread will take between 320K (32 bit JVM) and
  1024K (64 bit JVM) memory for its stack
- Queue messages can be used to reduce the problem. However,
  this design requires that the inbound client  streams
  send data reasonably often and input is processed fast.
   If the inbound client stream may be inactive for longer periods
  attached to hidden clients, a high number of inactive
  connections may actually block all the threads in the thread
  pool.
  That means that the server becomes slow to respond or even
  unresponsive.
- A non-blocking IO pipeline can use a single thread to
  read messages from multiple non-blocking streams.
    When in non-blocking mode, a stream may return 0 or more
  bytes when you attempt to read data from it.
  When you call select() or selectNow() on the Selector it
  gives you only the SelectableChannel instances ("connected
  clients") that actually has data to read.

  Component ──→ STEP 1: select() ──→ Selector ←──┬─→ Channel1
      ↑                                │         ┼─→ Channel2
      └───← STEP 2: ready channels ←───┘         └─→ Channel3


- Reading Partial Messages: Data sent by "ready" channels can
  contain fractions/incomplete messages:
  - The Message Reader looks needs to check if the data block
    contains at least one full message, adn storing partial ones.
    (maybe using one Message Reader per Channel to avoid mixing messages)
  - To store Partial Messages two design should be considered:
    - copy data as little as possible for better performance
    - We want full messages to be stored in consecutive byte to
      make parsing messages easier
  - Some protocol message formats are encoded using a TLV format
    (Type, Length, Value).
    Memory management is much easier since we known immediately
    how much memory to allocate for the message. No memory is
    wasted at the end of a buffer that is only partially used.
  - The fact that TLV encodings makes memory management easier is
    one of the reasons why HTTP 1.1 is such a terrible protocol.
    That is one of the problems trying to be fixed in HTTP 2.0 where
    data is transported in LTV encoded frames.
  - Writing Partial Messages: channelOut.write(ByteBuffer) in
    non-blocking mode gives no guarantee about how many of the
    bytes in the ByteBuffer is being written. The method returns
    how many bytes were written, so it is possible to keep track
    of the number of written bytes.
  - Just like with the Message Reader, a Message Writer is used
    per channel to handle all the details.
   (partial writes, message queues, resizable buffers, protocol aware tricks,...)

- All in all a non-blocking server ends up with three "pipelines" it
  needs to execute regularly:
  - The read pipeline which checks for new incoming data from
    the open connections.
  - The process pipeline which processes any full messages received.
  - The write pipeline which checks if it can write any outgoing
    messages to any of the open connections
[[}]]

● Path (1.7+) [[{java_lang.101,persistence.FS]]
- Represents a file/directory path in the FS
- Similar to java.io.File but with some minor differences.
// Ussage
import java.nio.file.Path;
import java.nio.file.Paths;

Path path = Paths.get("/var/lib/myAppData/myfile.txt");
System.out.println("Current dir:"+Paths.get(".").toAbsolutePath());
[[}]]

[[{]]persistence.FS,async/reactive,java_lang.101" >
● Files
- java.nio.file.Files provides several methods for manipulating FS files/directories:
- uses Path instances:

boolean pathExists =  Files.exists (pathInstance,
            new LinkOption[]{ LinkOption.NOFOLLOW_LINKS});

Path newDir =  Files.createDirectory (path);

 Files.copy (sourcePath, destinationPath);
 Files.copy (sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);

 Files.move (sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);

 Files.delete (path);

Files.walkFileTree(Paths.get("data"), new FileVisitor<Path>() {
  @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
    // ...  return FileVisitResult.CONTINUE; // CONTINUE TERMINATE SKIP_SIBLINGS SKIP_SUBTREE
  }

  @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
    // ...  return FileVisitResult.CONTINUE; // CONTINUE TERMINATE SKIP_SIBLINGS SKIP_SUBTREE
  }

  @Override public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
    // ...  return FileVisitResult.CONTINUE; // CONTINUE TERMINATE SKIP_SIBLINGS SKIP_SUBTREE
  }

  @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
    // ...  return FileVisitResult.CONTINUE; // CONTINUE TERMINATE SKIP_SIBLINGS SKIP_SUBTREE
  }
});
[[}]]

[[{persistence.fs,async/reactive.io]]
● Asyncrhonous FileChannel 1.7+
read/write data from/to files asynchronously

Path path = Paths.get("data/test.xml");
AsynchronousFileChannel fileChannel =
    AsynchronousFileChannel.open(path, StandardOpenOption.READ);

// Reading Data, Alt 1: Via a Future
  Future<Integer> operation = fileChannel.read(/*ByteBuffeR*/buffer, 0 /* start position to read from */);
  while(!operation.isDone());  // WARN: not a very efficient use of the CPU
  buffer.flip();
  byte[] data = new byte[buffer.limit()];
  buffer.get(data);
  System.out.println(new String(data));
  buffer.clear();

// Reading Data Alt 2: Via a CompletionHandler
fileChannel.read(buffer, position, buffer, new CompletionHandler<Integer, ByteBuffer>() {
    @Override
    public void completed(Integer numBytesRead, ByteBuffer attachment) {
        // NOTE: attachment is a reference to the third parameter passed to .read read()
        System.out.println("numBytesRead = " + numBytesRead);
        attachment.flip();
        byte[] data = new byte[attachment.limit()];
        attachment.get(data);
        System.out.println(new String(data));
        attachment.clear();
    }

    @Override
    public void failed(Throwable exc, ByteBuffer attachment) { ...  }
});

// Writing data:
AsynchronousFileChannel fileChannel =
    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);

// Writing Data: Alt 1: Via a Future
  ...
  Future<Integer> operation = fileChannel.write(buffer, position);
  buffer.clear();
  while(!operation.isDone());

// Writing Data: Alt 2: Via CompletionHandler
...
  fileChannel.write(buffer, position, buffer, new CompletionHandler<Integer, ByteBuffer>() {

      @Override public void completed(Integer result, ByteBuffer attachment) { /* ... */ }
      @Override public void failed   (Throwable exc , ByteBuffer attachment) { /* ... */ }
  });
[[}]]

● java.net.http.HTTPClient [[{io.net.http,async/reactive.io.network,01_PM.low_code,<02_doc_has.comparative,qa]]
API REF: @[https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/package-summary.html]
JEP: @[https://openjdk.java.net/jeps/321]

TODO: HTTPClient Quick intro:
    @[https://openjdk.java.net/groups/net/httpclient/intro.html]

- Example JShell script for GET request:
  import java.io.PrintWriter;
  import java.net.http.HttpClient
  import java.net.http.HttpRequest
  import java.net.http.HttpResponse
  import java.net.http.HttpResponse.BodyHandlers
  HttpClient client = HttpClient.newHttpClient();
  var BASE_URL="https://earizon.github.io/"
  var URL01=BASE_URL + "/txt_world_domination/index.html"
  HttpRequest request = HttpRequest.newBuilder(
    URI.create(URL01)).GET().build()
  HttpResponse<String> response =
    client.send(request, BodyHandlers.ofString());
  System.out.println(response.body())
  /exit



● OkHTTP
-   OkHTTP vs java.net.http.HTTPClient
From @[https://stackoverflow.com/questions/42392778/okhttp-or-httpclient-which-offers-better-functionality-and-more-efficiency]
   OkHTTP PROs over                     OkHTTP CONs over
   java.net.http.HTTPClient             java.net.http.HTTPClient
 - built-in response cache.           - timeout like configuration can not be
 - web sockets.                         modified after singleton connection.
 - Simpler API.                       - Requires (small) extra non-JDK dependencies
 - Better defaults                      (okIO and okHTTP itself) in non-Android
 - easier to use efficiently.           deployments
 - Better URL model.
 - Android support. (  HTTPClient
   supported in Android? )
 - Better cookie model.
 - Better headers model.
 - Better call model.
 - canceling calls is easy.
 - Carefully managed TLS defaults
   secure and widely compatible.
 - Retrofit compatibility
   (Brilliant API for REST).
 - eorks with okIO great library
   for data streams.
 - less code to learn
 - 1+ billion Android devices
   using it interlally
 - Standard in Android 5.0+ (API level 21+).

@[https://square.github.io/okhttp/]

  DAILY USSAGE  @[https://square.github.io/okhttp/recipes/]

  import java.io.IOException;
  import okhttp3.OkHttpClient;
  import okhttp3.Request;
  import okhttp3.Response;
  import okhttp3.MediaType;                         // ← For POST
  import okhttp3.RequestBody;                       // ← For POST
  ...
  OkHttpClient client = new OkHttpClient();
  Request request = new Request.Builder()
      .url("http://bla.ble.com/a/b?key=param")
      .build();
  try (
    Response res =
       client.newCall(request).execute()            // ← Exec. (GET) Request
  ) {
    System.out.println(res.body().string());
  }


  final String MediaType =  "application/json; charset=utf-8";
  final String jsonBody = "{...}";
  RequestBody body = RequestBody.create(jsonBody,   //  ← POST: prepare body rquest
           MediaType.get(MediaType));
  Request request = new Request.Builder()
      .url("http://bla.ble.com/")
      .post(body)                                   //  ← POST: prepare body rquest
      .build();
  try (
    Response res =
       client.newCall(request).execute()
  ) {
    return res.body().string();
  }

- "efficient by default".

- HTTP/2 support allows all requests to the same host to share a socket.
- Connection pooling reduces request latency (if HTTP/2 isn't available).
- Transparent GZIP shrinks download sizes.
- Response caching avoids the network completely for repeat requests.

- OkHttp perseveres when the network is troublesome: it will silently recover
  from common connection problems.
  If target service has multiple IP addresses OkHttp will attempt alternate
  addresses if the first connect fails .
  This is necessary for IPv4+IPv6 and for services hosted in redundant data centers .

   OkHttp supports modern TLS features (TLS 1.3, ALPN, certificate pinning). It
  can be configured to fall back for broad connectivity.

- request/response API is designed with  fluent builders and immutability
-.synch/sync+callback API.

- Ex: Balancing connections with OKHttp:
  https://medium.com/wandera-engineering/kubernetes-network-load-balancing-using-okhttp-client-54a2db8fc668

- Recipes: https://square.github.io/okhttp/recipes/
[[}]]

● okIO [[{async/reactive.io.network,qa]]
● complements java.nio
@[https://github.com/square/okio]
- makes it much easier to access, store, and process your data.
- It started as a component of OkHttp, the capable HTTP client
  included in Android. It's well-exercised and ready to solve new problems.
[[}]]
[[$div}]]
[[$div}]]

[[{$div]]
● Debug&amp;Profile [[{java_lang.debugging,devops.containarization,jvm.monitoring,monitoring.jvm]]
● Debug remote (container) JVM
• STEP 1: inject next ENV.VAR into app JVM:
  JAVA_TOOL_OPTIONS=""
  JAVA_TOOL_OPTIONS="${JAVA_TOOL_OPTIONS}-agentlib:jdwp=transport=dt_socket"
  JAVA_TOOL_OPTIONS="${JAVA_TOOL_OPTIONS},server=y"
  JAVA_TOOL_OPTIONS="${JAVA_TOOL_OPTIONS},suspend=n"
  JAVA_TOOL_OPTIONS="${JAVA_TOOL_OPTIONS},address=*:8001"
                                      ┌──┬──────────┴──┘
• STEP 2: Export debuggin port (e.g.: 8001)

• STEP 3: In JAVA IDE configure debugger to attach to remote machine
  (e.g., in IntelliJ , add remote debugger in Run/Debug Configurations)
[[}]]


● 'man 1 jcmd' Summary: [[{101,JVM.monitoring.101,java_lang.debugging]]
                        [[java_lang.profiling,01_PM.troubleshooting,monitoring.flight_recorder]]
- 'jcmd' must run on same machine+user+group on which the JVM is running.

  $ jcmd [-l]                              <- Print list of running Java PIDs.

  $ jcmd $pid Thread.print -l              <- Prints all threads with stacktraces. [[01_PM.troubleshooting]]
                                              -l: dump java.util.concurrent locks  [[concurrency.lock]]
  Ex. Output:
  | 2022-09-29 06:38:08
  | Full thread dump OpenJDK 64-Bit Server VM (11.0.14.1+1 mixed mode):
  |
  | Threads class SMR info:
  | _java_thread_list=0x00007fa9e4002e70, length=44, elements={
  | 0x00007faa2c1f8000, 0x00007faa2c1fa800, 0x00007faa2c218000, 0x00007faa2c21a000,
  | 0x00007faa2c21c000, 0x00007faa2c21e000, 0x00007faa2c220000, 0x00007faa2c2d7800,
  | 0x00007faa2d2ab000, 0x00007faa2d44a800, 0x00007faa2d4b1800, 0x00007faa2d556000,
  | 0x00007fa9b0004000, 0x00007faa2c02a000, 0x00007fa9a80e7000, 0x00007fa9a80ee000,
  | 0x00007fa9a8111800, 0x00007fa9a8113800, 0x00007fa9a8118000, 0x00007fa9a80f0000,
  | 0x00007fa9a8115000, 0x00007fa99005d000, 0x00007fa9a409a000, 0x00007fa9a0011800,
  | 0x00007fa99c03d000, 0x00007fa998095800, 0x0000556d44845800, 0x00007fa99405d800,
  | 0x00007fa990083000, 0x00007fa9a8143000, 0x00007fa9a8121800, 0x00007fa9a8123000,
  | 0x00007fa9a814b800, 0x00007fa9a814d000, 0x00007fa9a814f000, 0x00007fa9a815d000,
  | 0x00007fa9a8160800, 0x00007fa9a8148000, 0x00007fa9a8149800, 0x00007fa9a8165800,
  | 0x00007fa9a8167000, 0x00007fa9a8169000, 0x00007fa9f0026000, 0x00007fa9e4002000
  | }
  |
  | "Reference Handler" #2 daemon prio=10 os_prio=0 cpu=3.35ms elapsed=256333.77s
  |                     tid=0x00007faa2c1f8000 nid=0x1e waiting on condition [0x00007faa18866000]
  |    java.lang.Thread.State: RUNNABLE   <- := RUNNABLE, TIMED_WAITING (on object monitor),
  |                                             WAITING (on object monitor|parking), ...
  | 	at java.lang.ref.Reference.waitForReferencePendingList(java.base@11.0.14.1/Native Method)
  | 	at java.lang.ref.Reference.processPendingReferences(java.base@11.0.14.1/Unknown Source)
  | 	at java.lang.ref.Reference$ReferenceHandler.run(java.base@11.0.14.1/Unknown Source)
  |
  |    Locked ownable synchronizers:
  | 	- None
  |
  | "Signal Dispatcher" ...
  | "Service Thread"     ...
  | "C2 CompilerThread0" ...
  | "C1 CompilerThread0" ...
  | "Sweeper thread" ...
  |
  | "Common-Cleaner" ...
  | "vert.x-eventloop-thread-0" ...
  | "vert.x-acceptor-thread-0" ...
  | vert.x-eventloop-thread-2" ...
  | "vert.x-eventloop-thread-4" ...
  | "vert.x-eventloop-thread-0|" ...  [0...19]
  |   Locked ownable synchronizers:
  | 	- None
  | ...
  | "VM Thread"   os_prio=0 cpu=28658.34ms elapsed=256333.80s tid=0x00007faa2c1ef000 nid=0x1d runnable
  | "GC Thread#0" os_prio=0 cpu=6640.67ms  elapsed=256333.90s tid=0x00007faa2c041800 nid=0x18 runnable
  | "GC Thread#1" os_prio=0 cpu=6667.69ms  elapsed=256332.51s tid=0x00007fa9f8001000 nid=0x27 runnable
  | "GC Thread#2" os_prio=0 cpu=6647.53ms  elapsed=256332.51s tid=0x00007fa9f8002800 nid=0x28 runnable
  | "GC Thread#3" os_prio=0 cpu=6655.38ms  elapsed=256332.51s tid=0x00007fa9f8004000 nid=0x29 runnable
  | "G1 Main Marker" os_prio=0 cpu=4.05ms  elapsed=256333.90s tid=0x00007faa2c09f000 nid=0x19 runnable
  | "G1 Conc#0" os_prio=0 cpu=51.33ms elapsed=256333.90s tid=0x00007faa2c0a1000 nid=0x1a runnable
  | "G1 Refine#0" os_prio=0 cpu=4.17ms elapsed=256333.89s tid=0x00007faa2c190000 nid=0x1b runnable
  | "G1 Young RemSet Sampling" os_prio=0 cpu=92484.58ms elapsed=256333.89s tid=0x00007faa2c192000 nid=0x1c runnable
  | "VM Periodic Task Thread" os_prio=0 cpu=378619.90ms elapsed=256333.58s tid=0x00007faa2c2db800 nid=0x26 waiting on condition


  $ jcmd pid|main-class PerfCounter.print  ← Send diagnostic command PerfCounter.print to PID JVM
                                             $ jcmd help to see the list of available diagnostic command

  $ jcmd pid|main-class -f filename        ←  file from which to read diagnostic commands to send to JVM

  $ jcmd pid|main-class command[ arguments]

 Ex:
 $ $ jcmd $PID
  → The following commands are available:
  → Compiler.CodeHeap_Analytics  → GC.class_histogram    → ManagementAgent.start
  → Compiler.codecache           → GC.class_stats        → ManagementAgent.start_local
  → Compiler.codelist            → GC.finalizer_info     → ManagementAgent.status
  → Compiler.directives_add      → GC.heap_dump          → ManagementAgent.stop
  → Compiler.directives_clear    → GC.heap_info
  → Compiler.directives_print    → GC.run                → Thread.print
  → Compiler.directives_remove   → GC.run_finalization
  → Compiler.queue

  → VM.class_hierarchy    → VM.print_touched_methods    → JFR.check
  → VM.classloader_stats  → VM.set_flag                 → JFR.configure
  → VM.classloaders       → VM.stringtable              → JFR.dump
  → VM.command_line       → VM.symboltable              → JFR.start
  → VM.dynlibs            → VM.system_properties        → JFR.stop
  → VM.flags              → VM.systemdictionary
  → VM.info               → VM.uptime                   → JVMTI.agent_load
  → VM.log                → VM.version                  → JVMTI.data_dump
  → VM.metaspace          → help
  → VM.native_memory
[[}]]


● Flight Recorder [[{monitoring.101,monitoring.flight_recorder,java_lang.profiling,01_PM.troubleshooting,<02_doc_has.comparative]]
@[https://www.youtube.com/watch?v=azshjd5Vsv0]
- Free of use starting with Java 11+ and backported to OpenJDK 8u272+
  @[https://www.infoq.com/news/2019/11/jfr-openjdk-8/]
- (JEP 328)
- created originally in 1998 by students from the Royal
  Institute of Technology in Stockhoml as part of the JRockit JVM
  distribution by Appeal Virtual Machines.
- built directly into the JDK, it   can monitor performance accurately .
  with about only   2% overhead(production friendly) .
- accurate metrics to avoid mislead readers via safe points or sampling.
  avoiding common problems (@[#JVM_safepoints]) with sampling profilers.      [comparative]
  ┌────────────────┐
  │ JRE ┌────────┐ │
  │     │ JFR    ←--- Output profiling to 'myRecording.jfr'
  │     │ engine │ │  - compact log of   JVM events : ~100.000 events with many stack traces: ~2-4MB
  │     └────────┘ │  - Use Java Mission Control (JMC)  to read events.
  └─^──────────────┘
  ┌─┴───────────────────────────────────────
  $ java ...   -XX:StartFlightRecording  ... ← Alternatively launch JFR from JMC Visual IDE

  - JFR default metrics focus in JVM's  raw operations:
    (vs high-level metrics like request/response times)
    - advanced garbage collection analysis :
      Include garbage collection statistics, etails on what garbage
      was collected and who threw it away.
      allows developers to improve performance by:                   [performance]
       - identifying what to improve
       - realize when tunning GC is the wrong solution.

  Java Mission Control (JMC):
- @[http://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html]
- UI to analyze data collected by Flight Recorder and head dumps  built on top of Eclipse IDE.
- overview of all locally running Java processes, statistics,
  heap dumps, flame view ( show the aggregate of stack traces for the selected events ),

  WHAT'S NEW
- JMC 8+ RoadMap:
  - New allocation event (introduced in JDK 16).
  - Improve Flame Graph and Graph Views for memory ussage (vs CPU ussage).

- JMC 8: (2021-04)
@[https://www.infoq.com/news/2021/04/jdk-mission-control-8-released/]
  - new graphs and heap dump analysis by default.
  - Can also be used as a library for parsing/processing .jfr files.
  -
  - JMX Console can be used to continuously monitor an environment,
    interact with MBeans, invoke jcmd diagnostics commands remotely,...

  - Flight Recording used to create a recording
  - Dump Heap        used to create a heap dump

  - low overhead in production environments:
  - JOverflow: plugin with advanced analysis of heap dumps, included by default.
               converted to the Standard Widget Toolkit (SWT).
               It also offers insights and optimizing hints to developers.
               like Hierarchical Treemaps, may be used to improve the heap usage of the application.
               - Ussage:
                 create and open a heap dump in the JMC application.

  - New Graph View: directed graph where each node contains an individual method.
    NOTE: WebKit required ($ # apt install libwebkit2gtk-4.0-dev ), doesn't work (yet) on Windows.

  - first release of  JMC Agent :
    - Allows JFR events to be added declaratively to any codebase.
    - Events can be used to capture (fields, parameter,...) values.

  - Rules API 2.0: Allow to use intermediate results from other rules.

  - JFR Writer is introduced as a new core module.

[[}]]

● CRaSH shell [[{monitoring.101,java_lang.debugging,01_PM.troubleshooting,01_PM.low_code,01_PM.TODO]]
• Features:
  ✓ Connect to any JVM running CRaSH through SSH, telnet or web.
  ✓ Monitor and/or use virtual machine resources:
    JMX, database access, threads, memory usage, ...
  ✓ Embed CRaSH and expose services via a command line interface.
  ✓ Hot reload provides rapid development.
  ✓ Officially embedded as Spring Boot remote shell.

[[}]]

● Eclipse Mem.Analizer [[{java_lang.profiling,01_PM.troubleshooting,01_PM.TODO]]
@[https://www.eclipse.org/mat/]
"""he Eclipse Memory Analyzer is a fast and feature-rich Java heap
  analyzer that helps you find memory leaks and reduce memory consumption.

  Use the Memory Analyzer to analyze productive heap dumps with hundreds of
  millions of objects, quickly calculate the retained sizes of objects, see
  who is preventing the Garbage Collector from collecting objects, run a
  report to automatically extract leak suspects.
"""

It can provide reports and warnings similar to:
  (REF: @[https://www.youtube.com/watch?v=5joejuE2rEM])
  The classloader/component "sum.misc.Launcher$AppClassLoader@0x123412"
  occupies 607,654,123(38,27%) bytes.
  The memory is accumulated in one instance  of
  java.util.LinkedList$Entry loaded by 'system class loader'
[[}]]

● SystemTap+Java [[{jvm.dynamic_instrumentation,java_lang.profiling,01_PM.troubleshooting,01_PM.TODO]]
@[https://laurent-leturgez.com/2017/12/22/profiling-java-application-with-systemtap/]
[root@spark ~]# yum install systemtap systemtap-runtime-java

JAVA                                              SystemTap Profiling script
package com.premiseo;                             #!/usr/bin/env stap

import java.lang.*;                               global counter,timespent,t
import java.io.BufferedReader;
import java.io.InputStreamReader;                 probe begin {
import java.io.IOException;                         printf("Press Ctrl+C to stop profiling\n")
                                                    counter=0
class Example {                                     timespent=0
   public static void                             }
     loop_and_wait(int n)
         throws InterruptedException{             probe java("com.premiseo.Example").class("Example").method("loop_and_wait")
         System.out.println(                      {
            "Waiting "+n+"ms... Tick");             counter++
         Thread.sleep(n);                           t=gettimeofday_ms()
     }                                            }

   public static void main(String[] args) {       probe java("com.premiseo.Example").class("Example").method("loop_and_wait").return
      System.out.println("PID = "+                {
          java.lang.management.                     timespent+=gettimeofday_ms()-t
              ManagementFactory.                  }
                  getRuntimeMXBean().
                     getName().split("@")[0]);    probe end {
      System.out.println(                            printf("Number of calls for loop_and_wait method: %ld \n",    counter)
              "Press key when ready ...");           printf("Time Spent in method loop_and_wait: %ld msecs \n", timespent)
                                                  }
      try {                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        BufferedReader in =                       profiling loop_and_wait:
           new BufferedReader(                    counts number of times the
              new InputStreamReader(System.in));  loop_and_wait method has been called,
        String next = in.readLine();              and the time spent in this method execution.
      } catch (IOException ioe) {
        ioe.printStackTrace();
      }

      try {
        for (int i=0;i<10;i++) {
           loop_and_wait(1000);
        }
      } catch (InterruptedException ie) {
        ie.printStackTrace();
      }
   }
}
[[}]]

● Fast Thread [[{java_lang.debugging,jvm.monitoring.threads,01_PM.troubleshooting,01_PM.radar]]
@[https://fastthread.io/]
• Features:
  ✓ Java Thread Dump Analyzer
  ✓ Troubleshoot JVM crashes, slowdowns, memory leaks, freezes, CPU Spikes
  ✓ Instant RCA (don`t wait for Vendors)
  ✓ Machine Learning
  ✓ Trusted by 4000+ enterprises
  ✓ Free Service
[[}]]

[[{jvm.memory,01_PM.troubleshooting,jvm.gc,java_lang.debugging,qa,01_PM.low_code,01_PM.TODO]]
● gceasy.io
@[https://gceasy.io/]
• Features:
  ✓ machine learning guided Garbage collection log analysis tool.
    GCeasy has in-built intelligence to auto-detect problems in the JVM ⅋ Android
    GC logs and recommend solutions to it.
  ✓ Solve Memory ⅋ GC problems in seconds
  ✓ Get JVM Heap settings recommendations
  ✓ Machine Learning Algorithms
  ✓ Trusted by 4,000+ enterprises
  ✓ Free
  ✓ A perfect DevOps tool!
  ✓ Made by the developers, for the developers
[[}]]

● libperfagent (perf agent) [[{java_lang.profiling,concurrency.lock,monitoring.distributed,01_PM.TODO]]
Extracted from:
  "Apache Spark @Scale: A  production use case"
@[https://engineering.fb.com/core-data/apache-spark-scale-a-60-tb-production-use-case/]
  ...  Tools we used to find performance bottleneck
  - Spark Linux Perf/Flame Graph support: Although the two tools
    above are very handy, they do not provide an aggregated view of CPU
    profiling for the job running across hundreds of machines at the same
    time. On a per-job basis,   we added support for enabling Perf
    profiling (via libperfagent for Java symbols) and can customize the
    duration/frequency of sampling. The profiling samples are aggregated
    and displayed as a Flame Graph across the executors using our
    internal metrics collection framework.
[[}]]

● Uber JVM Profiler: Tracing at scale [[{architecture.distributed,monitoring.distributed,java_lang.profiling,01_PM.TODO]]
@[https://eng.uber.com/jvm-profiler/]
Our JVM Profiler supports a variety of use cases, most notably making
it possible to instrument arbitrary Java code. Using a simple
configuration change, the JVM Profiler can attach to each executor in
a Spark application and collect Java method runtime metrics. Below,
we touch on some of these use cases:
- Right-size executor: We use memory metrics from the JVM Profiler
  to track actual memory usage for each executor so we can set the
  proper value for the Spark “executor-memory” argument.
- Monitor HDFS NameNode RPC latency: We profile methods on the
  class org.apache.hadoop.hdfs...ClientNamenodeProtocolTranslatorPB
  in a Spark application and identify long latencies on NameNode calls.
  We monitor more than 50 thousand Spark applications each day with
  several billions of such RPC calls.
- Monitor driver dropped events: We profile methods like
  org.apache.spark.scheduler.LiveListenerBus.onDropEvent to trace
  situations during which the Spark driver event queue becomes too long
  and drops events.
- Trace data lineage: We profile file path arguments on the method
org.apache.hadoop.hdfs...getBlockLocations and
org.apache.hadoop.hdfs...addBlock

Uber JVM Profiler provides a Java Agent to collect various metrics
and stacktraces for Hadoop/Spark JVM processes in a distributed way,
for example, CPU/Memory/IO metrics.

Uber JVM Profiler also provides advanced profiling capabilities to
trace arbitrary Java methods and arguments on the user code without
user code change requirement. This feature could be used to trace
HDFS name node call latency for each Spark application and identify
bottleneck of name node. It could also trace the HDFS file paths each
Spark application reads or writes and identify hot files for further
optimization.

This profiler is initially created to profile Spark applications
which usually have dozens of or hundreds of processes/machines for a
single application, so people could easily correlate metrics of these
different processes/machines. It is also a generic Java Agent and
could be used for any JVM process as well.
[[}]]
[[$div}]]

[[{$div]]
    ● Concurrent Programming
[[{$div]]
[[{concurrency.101]]
● External Links
- Youtube Concurrency Classes:
@[https://www.youtube.com/watch?v=8yD0hHAz3cs&list=PLw8RQJQ8K1ySGcb3ZP66peK4Za0LKf728&index=4] [  ES lang ]
[[}]]
[[{concurrency.101,scalability.101,01_PM.low_code]]
● 1uSec Thread sync
REF:
@[https://software.rajivprab.com/2018/04/29/myths-programmers-believe-about-cpu-caches/]
"""
  ...
- If caches are so in-sync with one another, why do we need volatiles at all in
  languages like Java?

  That’s a very complicated question that’s better answered elsewhere, but
  let me just drop one partial hint. Data that’s read into CPU registers, is
  not kept in sync with data in cache/memory. The software compiler makes all
  sorts of optimizations when it comes to loading data into registers, writing it
  back to the cache, and even reordering of instructions. This is all done
  assuming that the code will be run single-threaded. Hence why any data that is
  at risk of race-conditions, needs to be manually protected through concurrency
  algorithms and language constructs such as atomics and volatiles.

 ☞In the case of Java volatiles, part of the solution is to force all
  reads/writes to bypass the local registers, and immediately trigger cache
  reads/writes instead. As soon as the data is read/written to the L1 cache, the
  hardware-coherency protocol takes over and provides guaranteed coherency across
  all global threads. Thus ensuring that if multiple threads are reading/writing
  to the same variable, they are all kept in sync with one another. And this is
  how you can achieve inter-thread coordination in as little as 1ns.
"""


See also: fast Inter-thread communication:
@[https://www.infoq.com/articles/High-Performance-Java-Inter-Thread-Communications]
- The story begins with a simple idea: create a developer friendly,
  simple and lightweight inter-thread communication framework without
  using any locks, synchronizers, semaphores, waits, notifies; and no
  queues, messages, events or any other concurrency specific words or
  tools.
  Just get POJOs communicating behind plain old Java interfaces.
[[}]]

● Concurrency Basics [[{concurrency.101]]
- Concurrency problems arise from the desire to use CPU resources more efficiently. Non concurrent
  applications (single threaded/single process) are complete Touring machines that can potentially
  solve any problem with enough time and memory. In practice having a CPU assigned to single thread
  will be very inneficient since the CPU will stand-by while the thread is waiting for input/output
  operations. Also, many algorithms allows to split processed data in isolated regions that can be
  processed in parallel by different CPU/CPU cores
- Concurrent tries to solve the problem of multiple independents CPUs or threads accesing share
  resources (memory)
- Locks is the simples concurrent primite to protect code or data from concurrent
  access in situations where there are many threads of execution. Locks can be classified like:
  | According to lock ussage:
  |    Cooperative   A thread is encouraged (but not forced) to cooperate with other
  |                  threads by adquiring a lock before accessing the associated data
  |
  |    Mandatory     a thread trying to access an already locked resource will throw
  |                  an exception
  | _________________________________________________
  | According to lock rescheduing strategy:
  |    Blocking      The OS block the thread requesting the lock and rescheduled another thread
  |
  |    Spinlock      The thread waits in a loop until the requested lock becomes available.
  |                  It's more efficient if threads are blocked for very short time (smaller than
  |                  the time needed by the OS to reschedule another thread into the current CPU)
  |                  It's inneficient if the lock is held for a long time since a CPU core is
  |                  waisted on the spinlock loop
  | _________________________________________________
  | According to granularity: (measure of the ammount of data the lock is protecting)
  |    Coarse        Protect large segments of data (few locks). Results in less lock overhead
  |                  for a single thread, but worse performance for many threads running concurrently
  |                  (most thread will be lock-contended waiting for share resource access)
  |
  |    Fine          Protect small amounts of data. Require more lock instances reducing lock
                     contention

- Locks require CPU atomic instructions for efficient implementations suchs as
    "test-and-set", "fetch-and-add", or "compare-and-swap", whether there are blocking
    (managed by the OS) or spinlocks (managed by the thread)
- Uniprocessors can just disable interruptions to implement locks, while multiprocessors
  using shared-memory will require complex hardware and/or software support
-   Monitors wrap mutex-locks with condition variables (container of threads waiting
    for certain condition) . They are implemented as thread-safe classes
[[}]]
[[{]]concurrency.101" >
● monitors
- Object providing Mutual exclusion of threads to shared resources
- simplest form of synchronization:
  alternatives include:
  - reads and writes of volatile variables
  @[https://avaldes.com/examining-volatile-keyword-with-java-threads-example/]
    typically used in applications when one thread will
    be making changes to the variables and the others all reading or
    consumers of the data. If you have multiple threads making changes to
    the data it will be best to stick with synchronized block or use
    java.util.concurrent library package.
    (volatile is actually simpler than monitors, but not universal)
    Important Points on Volatile Variables:
    - Volatile variables are not cached in registers or in caches :
      All read and writes are done in main memory, never done thread-locally
    - Example Ussage: status flags used in spin loops
    - Volatile keyword guarantees visibility and ordering
  - use of classes in the java.util.concurrent package
- Monitors also have the ability to wait(block a thread) for a certain condition
  to become true, and signal other threads that their condition has been met
- Monitors provide a mechanism for threads to temporarily give up exclusive access in
  order to wait for some condition to be met, before regaining exclusive access and
  resuming their task
- each java object can be used as a monitor.
- Methods/blocks of code requiring mutual exclusion must be explicitly marked with the
  synchronized keyword :
  - The synchronized statement computes a reference to an object;
    it then attempts to perform a lock action on that object's monitor and does not
    proceed further until the lock action has successfully completed.
    After the lock action has been performed, the body of the synchronized statement
    is executed. If execution of the body is ever completed, either normally or abruptly,
    an unlock action is automatically performed on that same monitor.
  -   WARN : The Java programming language neither prevents nor requires detection
    of deadlock conditions.
- Instead of explicit condition variables, each monitor(/object) is equipped with
  a single wait queue in addition to its entrance queue.
- All waiting is done on this singleO wait queue  and allO notify/notifyAll
  operations apply to this queue.

 monitor    enter
 ┌───┬─────── │ ──┐   - Wait sets are manipulated solely and atomically
 │  notified  v   │     through the methods
 │ ─────→         │     Object.wait      : move     running thread    → wait-queue
 │   │        O   │     Object.notify    : move     thread  wait-queue → enter-queue
 │ O │        O   │     Object.notifyAll : move all threads wait-queue → enter-queue
 │ O ├─────── │ ──┴─┐   Interrupt??      : put thread into to monitor enter-queue
 │ O │        v     │
 │  ←──wait   O     │  - In timed-waits  : internal action removes thread to enter-queue?
 │   │     (Running │                      after at least milliseconds plus nanoseconds
 └───┤      thread) │  - Implementations are permitted (but discouraged),
     │              │    to perform "spurious wake-ups"
     │    leave     │
     └────── │ ─────┘  O = Thread (Instruction Pointer + Stack Pointer + ...?)
             v
<!--
TODO Concurrent
@ma: https://en.wikipedia.org/wiki/Monitor_(synchronization)
     https://cs.nyu.edu/~lerner/spring12/Preso03-JavaPrimitives.pdf
     https://en.wikipedia.org/wiki/Concurrent_computing
     http://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/
-->
[[}]]

[[{]]concurrency.barrier" >
● CountDownLatch
• (java.util.concurrent) Since JDK 1.5
@[https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CountDownLatch.html]
• Object allowing 1+ threads to wait until a
  1+ operations are completed in other threads.

• example ussages:
  - on/off latch or gate:
    When initialized to "one", parallel processing threads will
    invoke "await" and standby waiting for a "control" thread to
    open the gate with countDown().
  - parallel thread synchonization:  (barriers, ...)
    When initialized to 2+, it can be used to make a thread
    wait until "N" processing threads complete their task,
    (or 1+ proccesing threads complet an action N times).

    NOTE :
  - Threads calling countDown() can continue processing before count reach 0.
    Only threads invoquing await will wait.

- The first is a start signal that prevents any worker from
   proceeding until the driver is ready for them to proceed; The second
   is a completion signal that allows the driver to wait until all
   workers have completed.

  -  Ex. 1:
     class DriverThread { // ...

       class Worker implements Runnable {
         private final CountDownLatch   startSignal ;
         private final CountDownLatch   doneSignal ;
         Worker(CountDownLatch   startSignal , CountDownLatch   doneSignal ) {
            this.startSignal = startSignal ;
            this.doneSignal  = doneSignal ;
         }
         public void run() {
            try {
              startSignal .await();      // ← Wait for driver-thread to be ready.
              doWork();
              doneSignal .countDown();   // ← Decrease count.
            } catch (InterruptedException ex) {} // return;
         }

         void doWork() { ... }
       }

       void main() throws InterruptedException {
         CountDownLatch   startSignal =
                          new CountDownLatch(1); // ← 1: Gate: Avoid workers to start before
                                                 //       driver-thread is ready.

         CountDownLatch   doneSignal  =          // ← N: Make driver thread wait until workers
                          new CountDownLatch(N); //      have completed.
                                                 //   Consider also CyclicBarrier
                                                 //   (reset after count),

         for (int i = 0; i < thread_number ; ++i) {
           new Thread(                           // ← Setup workers in this (driver) thread.
                new Worker(
                      startSignal ,
                      doneSignal
           )).start();
         }
         ...
         startSignal .countDown();      // ← Decrease count. count cannot be reset.
         doSomethingElse();
         doneSignal .await();           // ← block until current count reaches zero
                                            Thread is released. Any subsequent invocations
                                            return immediately.
       }
     }

  -  Ex. 2:
     - divide problem into N parts
     - describe each part with a Runnable executing a portion,
     - queue all Runnables to an Executor.
     - When all sub-parts are complete, coordinating-thread will "pass" through await.

     class Driver2 { // ...
       class WorkerRunnable implements Runnable {
         private final CountDownLatch   doneSignal ;
         WorkerRunnable(
            CountDownLatch   doneSignal , ...) {
            this.doneSignal = doneSignal ;
         }

         public void run() {
            try {
              doneSignal.countDown();
            } catch (InterruptedException ex) {} // return;
         }

         void doWork() { ... }
       }
       void main() throws InterruptedException {
         CountDownLatchO doneSignal = new CountDownLatch(N);
         Executor e = ...

         for (int i = 0; i < N; ++i) // create and start threads
           e.execute(new WorkerRunnable(  doneSignal , i));

         doneSignal .await();           // wait for all to finish
       }
     }

@[https://liakh-aliaksandr.medium.com/java-barrier-synchronizers-countdownlatch-cyclicbarrier-phaser-50eb69724d67]
[[}]]

● Scheduling: Runnables|Callables Executors [[{concurrency.101,concurrency.scheduling,<02_doc_has.diagram]]
@[https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html]
• Basic Thread objects

   Java 1.0+           Java 1.5+
  ┌────────────┐       (java.util.concurrent)
  │<<Runnable>>│
  │────────────│
  │+run()      │
  └────────────┘
        △
        ┆
  ┌────────────┐       ┌───────────────┐
  │Thread      │       │<<Callable<V>>>│
  │────────────│       │───────────────│
  │+run()      │       │+call()        │
  │+start()    │       └───────────────┘
  │+sleep()    │       Complements Thread, returning a result/exception
  │....        │       the "parent" thread triggering the Callable
  └────────────┘


• Executor interface ( Java 1.5+):
  REF: https://www.uml-diagrams.org/java-7-concurrent-uml-class-diagram-example.html

  *0: Executors : Utility Factory + utility methods for Executor,(Scheduled)ExecutorService,
                  ThreadFactory, Callable) It can also create a "wrapped" ExecutorService
                  disabling reconfiguration.
  ┌╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶ <<CompletionService>>                        │
  ┆                Executors *0                         △                                    │
  ┆                  ┆┆┆┆      <<Executor>>  ←╶╶╶╶╶╶╶┐  ┆                                    │
  ┆   <<Callable>> ←─┘┆┆┆      void execute(Runnable)┆  ┆                                    │
  ┆                   ┆┆┆           △                ┆  ┆                                    │
  ┆ <<ThreadFactory>>←┘┆┆           │       ExecutorCompletionService ───┐                   │
  ┆                    ┆┆           │                                    ↓                   │
  ┆                    ┆┆           │                                <<BlockingQueue>>       │
  ┆                    ┆└╶╶→ <<ExecutorService>>◁╴╴╴╴╴╴╴┐                    │               │
  └→ <<Future>> ←╶╶╶╶╶╶┆╶╶╶╶╶╶╶╶╶┘  △ *1                ┆                    │               │
       △   △           ┆            │             AbstractExecutorSevice     │               │
       ┆   ┆           └╶╶╶╶╶╶→ <<Scheduled─ *2      △   △                   │               │
       ┆   ┆                  ExecutorService>>      │   │                   │               │
    ┌╴─┘   └─╴╴╴╴╴┐                 △                │   │                   │               │
  FutureTask     ForkJoin           ┆  1.7+     ┌────┘   └──────┐            │               │
                 Task    ←╶╶╶╶╶╶┐   ┆  ForkJoinPool       ThreadPoolExecutor ◇               │
                 △  △           ┆   ┆           │               △            ◇               │
                 │  │           ┆   ┆           │               │            │               │
           ┌─────┘  └────┐      ┆   ┆           ◇               │        Rejected            │
       Recursive    Recursive   └╶╶╶┆╶╶╶╶╶ ForkJoin             │      ExecutionHandler      │
       Action       Task            ┆      WorkerThread         │                            │
                                    ┆                           │                            │
                                    └╴╴╴╴╴╴╴╴ ScheduledTreadPoolExecutor                     │
                                     ┌────────┴────────────────────────┘                     │
                                     └ Prefered to "old" java.util.timer:                    │
                                       • timer can be sensitive to system clock changes      │
                                       • timer has only one execution thread. Long-running   │
                                         task can delay other tasks. Sch.Thre.PoolEx.        │
                                         can be configured with "N" threads.                 │
                                       • runtime exceptions kill the Timer thread.           │
        CyclicBarrier Semaphore          Sch.Thre.Ex. catches them, allowing to handle       │
 CountDownLatch ┆ Phaser ┆   Exchanger   by overriding 'afterExecute' from ThreadPoolExecutor│
    └───────────┴──┬─┴───┴───────┘       Only Task throwing the exception will be canceled.  │
               TimeUnit enum                                                                 │

  *1: ExecutorService:    managed threads collection available to execute tasks
        <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks[,long timeout, TimeUnit unit])
                            Executes given tasks. when ALL complete (or timeout expires), return result.
                      <T> T invokeAny(Collection<? extends Callable<T>> tasks[,long timeout, TimeUnit unit])
                            Executes given tasks, Returns result of (first?) one completing
                            without exception, if any do before the given timeout elapses.
                    boolean isShutdown()  : true if this executor has been shut down.
                    boolean isTerminated(): true if all tasks have completed following shut down.
                       void shutdown()    : Init clean shutdown.
             List<Runnable> shutdownNow() : Attempts non─clean shutdown
                    boolean awaitTermination(long timeout, TimeUnit unit)
                            · Blocks until ALL tasks have completed (after shutdown request)
                              or the timeout occurs, or the current thread is interrupted,
              <T> Future<T> submit(Callable<T> task): Submit Callable for execution
                  Future<?> submit(Runnable task)   : Submit Runnable for execution
              <T> Future<T> submit(Runnable task, T result)
    ussage Alt 1: use an implementation of the interface (ThreadPoolExecutor, ScheduledThreadPoolExecutor)
                  an Instance.execute(runnableInstance) to add a Runnable task to thread pool.
    ussage Alt 2: Use factory methods in the 'Executors' class:
                  Executors.newSingleThreadExecutor()
                  Executors.newFixedThreadPool(int numThreads)
                  Executors.newCachedThreadPool() (← unbounded pool, automatic reclamation)
                  Executors.newSingleThreadScheduledExecutor()
                  Executors.newScheduledThreadPool(int size)

 *2: ScheduledExecutorService:  schedule tasks periodically/after (absolute/relative) delay/period
     <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit)
         ScheduledFuture<?> schedule(Runnable command    , long delay, TimeUnit unit)
                            · Creates + exec ScheduledFuture, enabled after delay.
         ScheduledFuture<?> scheduleAtFixedRate   (Runnable command, long initDelay,
                                                   long period, TimeUnit unit)
                            schedules after initDelay + n*period (n=0,..)
                            Executions running longer than period overlap.
         ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initDelay,
                                                   long delay , TimeUnit unit)
                            Wait until termination. Then wait for 'delay' until next execution.
                            Executions running longer than delay will just "shift/delay" next executions.

  • Example: (import java.util.concurrent.*;)
    ...
    int numWorkers = 10;                                         EXAMPLE 1: Create Pool of Callables
                                                                 ===================================
    ExecutorService pool = Executors.newCachedThreadPool();    ← STEP 1) create new pool
    MyCallableThread workers[]  =  new MyCallable[numWorkers]; ← allocate array for Callables and Futures
    Future futures[] = new Future[numWorkers];
    for (int i = 0; i < numWorkers; ++i) {
       workers[i] = new MyCallable(i+1);                       ← Initialize array
       futures[i] = pool.submit(workers[i]);
    }
    for (int i = 0; i < numWorkers; ++i) {
          try {
      futures[i].get();                                        ← Wait (Blocking) on each future.
          } catch (InterruptedException ex) { ...
          } catch (ExecutionException ex) {   ...  }
    }

                                                                EXAMPLE 2: Create Pool of Workers
    ExecutorService pool =  Executors.newFixedThreadPool(10);   =================================
    MyWorker[] workers =  new MyWorker[numWorkers];
    for (int i = 0; i < numWorkers; ++i)
      pool.execute(new MyWorker(i+1));                        ← Schedule new worker
    pool.shutdown();                                          ← Don't Forget

  *3 ForkJoinPool (1.7+)
     REF: @[http://tutorials.jenkov.com/java-util-concurrent/java-fork-and-join-forkjoinpool.html]
     • ForkJoinPool scheduler is similar to "ExecutorService" but
       IT MAKES IT EASY FOR TASKS TO RECURSIVELY SPLIT  WORK INTO SMALLER ONES
     • Fork : Task (=="thread") that "Splits itself" into smaller subtasks, executing concurrently.
     • Join : End children tasks (=="threads") and merge results (if any).

                                   ┌Task04··· CPU1 ·········┐end
                     ┌Task02(fork) ┤                  ┌──── ┴ ────┐
                     │             └Task05··· CPU2 ···┘end  ^     │
        Task01(fork) ┤                                      join >├  Task ...CPU1 ...
                ^    │             ┌Task06··· CPU3 ······┐end     │
                │    └Task03(fork) ┤                     └──── ┬ ─┘
                │             ^    └Task07··· CPU4 ···········─┘
                │             │
                │             │
              - There is an overhead in forks and maintaing new threads.
                Forking makes sense only for long running tasks with
                intensive use of CPU
              - Task01, 02, 03  wait  for subtasks to finish execution.

     • Creating new ForkJoinPool
       ForkJoinPool   forkJoinPool  = new ForkJoinPool(4);  Desired level of paralellism
                                                       └─── (Desired number of threads/CPUs)
     • Submiting tasks to ForkJoinPool scheduler  is very similar
       to how it is done in the ExecutorService. We can submit:
        -   RecursiveAction : task not returning any result.
        -   RecursiveTask   : task     returning a   result.


     import java.util.ArrayList;                       │import java.util.ArrayList;
     import java.util.List;                            │import java.util.List;
     import java.util.concurrent.RecursiveAction;      │import java.util.concurrent.RecursiveTask;
                                                       │
     //   Creating new RecursiveAction                 │//   Creating new RecursiveTask
     public class   MyRecursiveAction                  │public class   MyRecursiveTask
     extends   RecursiveAction  {                      │extends   RecursiveTask <Long> {
       private long workLoad = 0;                      │  private long workLoad = 0;
       public MyRecursiveAction(long workLoad) {       │
           this.workLoad = workLoad;                   │  public MyRecursiveTask(long workLoad) {
       }                                               │      this.workLoad = workLoad;
                                                       │  }
       @Override                                       │
       protected void compute() {                      │  protected Long compute() {
         if(this.workLoad < 16) {                      │    if(this.workLoad < 16) {
           // 16 is a  Tunnable Threshold parameter    │      // 16 is a  Tunnable Threshold parameter
           // Do workload in current thread            │      // Process work in current thread
           return                                      │      return workLoad * 3;
         }                                             │    }
         List<MyRecursiveAction> subtasks =            │    List<MyRecursiveTask> subtasks =
            Arrays.asList                              │       Arrays.asList
            ( new MyRecursiveAction(this.workLoad / 2),│       ( new MyRecursiveTask(this.workLoad / 2),
              new MyRecursiveAction(this.workLoad / 2) │         new MyRecursiveTask(this.workLoad / 2)
            );                                         │       );
                                                       │
         for(RecursiveAction subtask : subtasks)       │    for(MyRecursiveTask subtask : subtasks)
           subtaskO .fork() ;                          │        subtaskO .fork ();
           //       ^^^^^^^                            │        //       ^^^^^^^
           //     work split into subtasks to be       │        //     work split into subtasks to be
           //     scheduled for execution              │        //     scheduled for execution
       }                                               │
                                                       │    long result = 0;
     }                                                 │    for(MyRecursiveTask subtask : subtasks) {
                                                       │        result += subtaskO .join ();
                                                       │    }
                                                       │    return result;
                                                       │  }
                                                       │}
                                                       │
       USSAGE:                                         │ USSAGE:
       MyRecursiveAction myRecursiveAction =           │  MyRecursiveTask myRecursiveTask =
          new MyRecursiveAction(24);                   │     new MyRecursiveTask(128);
                                                       │  long mergedResult =
       forkJoinPool   .invoke(myRecursiveAction);      │  forkJoinPool   .invoke(myRecursiveTask) ;
                                                       │  System.out.println("mergedResult = " + mergedResult);

     •  ForkJoinPool Detractors
      @[http://coopsoft.com/ar/CalamityArticle.html]
[[}]]

● Completable Future [[{async/reactive.101,<02_doc_has.diagram]]
@[https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html]
• Future:            (Java 5+) Represent an asynchronous computation result.
  CompletableFuture: (Java 8+)
  · Extends Future with methods to combine and handle errors
  · Extends the CompletionStage interface
    · Contract for an asynchronous computation step that
      can be combined with other steps.
  · About 50 different methods for composing/combining/executing async computations.

•       ┌ LOCAL SYSTEM (Under Control) ─────────────────────────┐
        │               ┌·······(RPE Loop)··················┐   │
        │               ↓                                   │   │
        │    Input    Parse    Create      Parse  Create  → ... │
  INPUT ···→ Thread :  Data → │Future│  →  Data →│Future│       │
   DATA │    RPEL Loop                                          │
        │                        │                  │           │
        │┌───────────────────────┘                  │           │
        ││ ┌────────────────────────────────────────┘           │
        ││ │  I/O       External    Wait     Handle    |Future| │
        ││ └→ Thread :  Request  →  Respose →Respose → .complete│
        ││                     ↓                                │
        ││    I/O              ·               ↑                │
        │└──→ Thread :         ·               ·                │
        └──────────────────────·───────────────·────────────────┘
                               ·               · Response|RemoteeError
                               ·               · |Timeout
                           ┌───↓───────────────↑─┐
                           │REMOTE SYSTEM        │
                           │(Out of control)     │
                           └─────────────────────┘
• A Future that may be explicitly completed (setting its value and status),
  and may be used as a CompletionStage, supporting dependent functions and
  actions that trigger upon its completion.
• When two or more threads attempt to complete, completeExceptionally, or
  cancel a CompletableFuture, only one of them succeeds.

•  Barriers  (  allOf ):
   CompletableFuture<Void>[] future_list = new CompletableFuture[list.size()];
  int idx=0;
  log.info("Connecting plugins ...");
  for (Object el : list) {
    final CompletableFuture<Void>
      connectFuture = new CompletableFuture<>();
    asyncMethod(connectFuture);  // ← async Method at some moment must call complete()
    ...
  }
  return CompletableFuture.  allOf (future_list);

• Example: Using CompletableFuture as a Simple Future (no-arg constructor)
  create CompletableFuture instance,
  launch some computation in another thread,
  returns Future immediately.

  public Future<String> calculateAsync() throws InterruptedException {
      Future<String> result = new CompletableFuture<>(); // *1 or .

      Executors.newCachedThreadPool().submit(() -> {
          Thread.sleep(500);
          completableFuture.complete("Hello"); // alt.: completableFuture.cancel(false);
          return null;
      });

      return completableFuture;
  }
  *1: when the result of computation is known:
      Future<String> result = CompletableFuture.completedFuture("Hello");

  Future<String> completableFuture = calculateAsync();
  ...
  String result = completableFuture.get(); // .get() wait for completion/error
                                              (ExecutionException|InterruptedException)
  assertEquals("Hello", result);              until second threads "completes" the future.

• Ex: CompletableFuture with Encapsulated Computation Logic <!-- @ma -->
   (runAsync -<<Runnable>>-, supplyAsync -<<Supplier>>-)
   <<Supplier>>: generic functional interface with single method
                 (zero arguments, returns value)

  CompletableFuture<String> future
    = CompletableFuture.supplyAsync(/* supplier lambda*/ () -> "Hello")
  .thenApply(/* "processor" lambda */ s -> s + " World") // ← returns CompletableFuture
  .thenAccept(/* consumer lambda */
     s -> System.out.println("Computation returned: " + s)).
  .thenRun(/* Runnable lambda*/ () -> System.out.println("Computation finished."));

• Combining Futures (monadic design pattern in functional languages)
  CompletableFuture<String> completableFuture
    = CompletableFuture.supplyAsync(() -> "Hello")
      .thenCompose(
            s -> CompletableFuture.supplyAsync(() -> s + " World"));
  assertEquals("Hello World", completableFuture.get());

• Ex: Execute two independent Futures and do something with their results:
  CompletableFuture future = CompletableFuture.supplyAsync(() -> "Hello")
      .thenCombine(CompletableFuture.supplyAsync(
        () -> " World"), (s1, s2) -> s1 + s2));

  assertEquals("Hello World", future.get());

• Ex: Execute two independent Futures and do nothing with result:
  CompletableFuture future = CompletableFuture.supplyAsync(() -> "Hello")
    .thenAcceptBoth(CompletableFuture.supplyAsync(
       () -> " World"), (s1, s2) -> log(s1 + s2));

• Ex: Running Multiple Futures in Parallel:
   -  wait for all to execute and process combined results

  CompletableFuture<String> future1
    = CompletableFuture.supplyAsync(() -> "Hello");
  CompletableFuture<String> future2
    = CompletableFuture.supplyAsync(() -> "Beautiful");
  CompletableFuture<String> future3
    = CompletableFuture.supplyAsync(() -> "World");

  CompletableFuture<Void> combinedFuture
    = CompletableFuture.allOf(future1, future2, future3);

  // ...

  combinedFuture.get();

  String combined = Stream.of(future1, future2, future3)
    .map(CompletableFuture::join)  // ← join(): similar to get, but throws unchecked
                                                exception if future fails.
    .collect(Collectors.joining(" "));
  assertEquals("Hello Beautiful World", combined);

• Handling Errors: <!-- @ma -->

  We can NOT try-catch.

  CompletableFuture<String> completableFuture
    =  CompletableFuture.supplyAsync(() -> {
        ...
        if(errorDetected)
           throw new RuntimeException("Computation error!");
        return "Hello ";
    })
   .handle( (s, t) -> s != null ? s : "Hello, Stranger!"); //
   // result ┘  └ exception thrown? TODO:
  assertEquals("Hello, Stranger!", completableFuture.get());

  completableFuture.completeExceptionally(          Alternatively. Complete with Error
    new RuntimeException("Calculation failed!"));
  ...
  completableFuture.get();                          ← ExecutionException

• Async Methods
  - methods without Async-postfix run next execution blocking current thread.
  - async* without the Executor argument runs a step using the common
    fork/join pool implementation.

  - Ex.: process result of computation with a Function instance
    CompletableFuture<String> completableFuture
      = CompletableFuture.supplyAsync(() -> "Hello");

    CompletableFuture<String> future = completableFuture
      .thenApplyAsync(s -> s + " World"); // lambda is wrapped into ForkJoinTask instance
    assertEquals("Hello World", future.get());
[[}]]

● Guava ListenableFuture [[{async/reactive.101,<02_doc_has.comparative,qa]]
@[https://github.com/google/guava/wiki/ListenableFutureExplained]
- Concurrency is a hard problem, but it is significantly simplified by
  working with powerful and simple abstractions. To simplify matters,
  Guava extends the Future interface of the JDK with ListenableFuture.

- """We strongly advise that you always use ListenableFuture instead
  of Future in all of your code, because:
  - Most Futures methods require it.
  - It's easier than changing to ListenableFuture later.
  - Providers of utility methods won't need to provide Future and ListenableFuture
      variants of their methods.

● Listenable vs CompletableFutures
@[https://stackoverflow.com/questions/38744943/listenablefuture-vs-completablefuture]
          ListenableFuture                           │               CompletableFuture
─────────────────────────────────────────────────────┼───────────────────────────────────────────────────
                                                     │ It is different from ListenableFuture in that it
                                                     │ can be completed from any thread
─────────────────────────────────────────────────────┼───────────────────────────────────────────────────
ListenableFuture listenable = service.submit(...);   │ CompletableFuture completableFuture =
  Futures.addCallback(listenable,                    │     new CompletableFuture();
                      new FutureCallback<Object>() { │ completableFuture.whenComplete(new BiConsumer() {
    @Override                                        │   @Override
    public void onSuccess(Object o) {                │   public void accept(Object o, Object o2) {
        //handle on success                          │       //handle complete
    }                                                │   }
                                                     │ }); // complete the task
    @Override                                        │ completableFuture.complete(new Object())
    public void onFailure(Throwable throwable) {     │
       //handle on failure                           │ When a thread calls complete on the task,
    }                                                │ the value received from a call to get() is
  })                                                 │ set with the parameter value if the task is
                                                     │ not already completed.

  ..."CompletableFuture is dangerous because it exposes  complete  methods."
  ..."CompletableFuture would have been good if it extended Future
     and did not expore toCompletableFuture,... and they could have named
     it something meaningful like ChainableFuture "
[[}]]

● DragonWell JDK with Coroutine Support [[{concurrency.*,scalability.jvm,<02_doc_has.comparative]]
REF: @[https://www.infoq.com/news/2021/01/adoptopenjdk-welcomes-dragonwell/]
- AdoptOpenJDK and Alibaba announced that the Dragonwell JDK will be
  built, tested, and distributed using AdoptOpenJDK's infrastructure.
  ...  Another interesting feature is the Wisp2 coroutine support.
       Wips2  maps Java threads to coroutines instead of kernel-level threads: .
       Many coroutines can be scheduled on a small number of core lines,
       reducing scheduling overhead.

     Wisp2 engine is similar in some respects to the aims of Project Loom
     but (unlike Loom)   it works out of the box on existing code by enabling
     it with these Java arguments:
     $ java -XX:+UnlockExperimentalVMOptions -XX:+UseWisp2

    I/O intensive applications where tasks are blocked on events and
  then scheduled can benefit from the coroutine support. On the other
  side,   CPU intensive applications will probably not benefit from
  coroutines.

• See also reddit thread "Loom vs DragoWell JV:":
@[https://www.reddit.com/r/java/comments/ld2ame/video_loom_modern_scalable_concurrency_for_the/gm7rq7i/?context=3]
<hr/>
● Loom Project: Ligthweight threads
@[https://developers.redhat.com/blog/2019/06/19/project-loom-lightweight-java-threads/]
@[https://openjdk.java.net/jeps/353]

- MISSION:
  - make concurrency simple(r) again!

- Threads, provided by Java from its first day, are a convenient concurrency
  construct
  putting aside the separate question of communication among threads
  which is being supplanted by less convenient abstractions because their
  current implementation as OS kernel threads is insufficient for meeting
  modern demands, and wasteful in computing resources that are particularly
  valuable in the cloud.

- Project Loom will introduce   FIBERS:
  - lightweight, JVM managed, efficient threads ,
  - A fiber is composed of:
    -  1 scheduler    : Already in place for Java through the excellent scheduler
                       ForkJoinPool
    -  1 continuation : To be implemented in Loom.

  https://zeroturnaround.com/rebellabs/what-are-fibers-and-why-you-should-care/
  ....
  The overhead of fibers is higher but still very low even when
  compared to async and monadic APIs, which have the disadvantage of
  introducing a cumbersome, infectious programming style and don’t
  interoperate with imperative control flow constructs built into a
  language.
  So aren’t fibers generators or async/awaits?

  No, as we have seen fibers are real threads: namely a continuation
  plus a scheduler. Generators and async/awaits are implemented with
  continuations (often a more limited form of continuation called
  stackless, which can only capture a single stack frame), but those
  continuations don’t have a scheduler, and are therefore not threads.


RELATED:
@[http://www.linuxplumbersconf.org/2013/ocw/system/presentations/1653/original/LPC%20-%20User%20Threading.pdf]

@[https://www.infoq.com/presentations/continuations-java/]
Ron Pressler discusses and compares the various techniques of dealing with concurrency
and IO in both:
- pure functional (monads, affine types)
- imperative      (threads, continuations, monads, async/await)
and shows why delimited continuations are a great fit for the imperative style.

Bio
Ron Pressler is the technical lead for Project Loom, which aims to add delimited
continuations, fibers and tail-calls to the JVM

● Quasar(Fibers)
• fast threads for java and Kotlin
@[http://docs.paralleluniverse.co/quasar/]

NOTE: To be superseded by Prj. Loom?
Extracted from @[https://github.com/puniverse/quasar/issues/305]
My understanding is that Ron is currently busy working for/with Oracle on
project Loom which should bring "native" Fiber/lightweight continuation
support directly into JVM without the need of auxiliary library like Quasar.
[[}]]
[[$div}]]
[[$div}]]


[[{$div]]
● Async/Reactive Programming
[[{$div]]
[[{]]async/reactive.*,java_lang.functional,java_lang.101" >
● Labmdas Intro
• Java 8+.
• simplifies development of non-blocking style APIs
  (low-level CompletableFuture or higher level ReactiveX).
• Context:
  The conventional computing model of a Touring machine takes for granted
  that data is already available to be processed.
  In the Internet era, data is arriving at random and we don't want to block
  our CPU in an infinite loop waiting for such data to arrive.

  The conventional approach is to let the OS scheduler to divide the CPU
  into threads or processes sharing the hardware at defined intervals.
  While this approach works well for standard load scenarios, it fails for
  "moderm" workloads with thousands or tens of thousands of simultaneous
  clients accessing the server. Each new OS thread requires some extra
  memory on the OS kernel (about 2Kilobytes per Thread, and even more
  per Process). Switching from thread to thread or process to process becomes
  expensive or prohibitive with that number of concurent I/O flows.
  This is even worse when our server is virtualized with many other
  competing VMs running on the same physical server.

  Async programming will try to reause the same thread by many different
  clients or flows of I/O data providing a much better ussage of hardware
  resources and avoiding unnecesary context-switches between threads or
  processes.

  The term "reactive" refers to programming models that are built around
  reacting to change — network component reacting to I/O events, UI controller
  reacting to mouse events, etc. In that sense non-blocking is reactive because
  instead of being blocked we are now in the mode of reacting to notifications
  as operations complete or data becomes available.

  Spring Reactive Streams is a small spec, also adopted in Java 9, that defines
  the interaction between asynchronous components with back pressure. For
  example a data repository — acting as Publisher, can produce data that an
  HTTP server — acting as Subscriber, can then write to the response. The main
  purpose of Reactive Streams is to allow the subscriber to control how fast or
  how slow the publisher will produce data.

  Reactive Streams is of interest to low-level reusable libraries but
  no final applications are better suites using a higher level and richer
  (functional) API like Java8+ Collection-Stream API or more ingeneral APIs
  like those provided by ReactiveRX.

  Reactive programming can also be compared with the way data flows in Unix
  pipelines when handling text files. In the next Unix command there is a
  file input (it can be a real file in the hard-disk or a socket receiving
  data) and the different commands in the pipe consume STDIN and result to
  STDOUT for further processing.
  $ cat input.csv | grep "...." | sort | uniq | ... >  output.csv
  Reactive Java frameworks are ussually much fasters since everything executes
  on the same process (a Unix pipeline requires the help of the underlying
  OS to work), and the type of input/output data can be any sort of Java
  object (not just file text).
[[}]]

[[{]]async/reactive.io,async/reactive.101,01_PM.TODO">
● java.util.concurrent.Flow(1.9+)
@[https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html]
- JDK 1.9+
- Reactive Streams was adopted by the JDK in the form of the java.util.concurrent.Flow API.
- It allows two different libraries that support asynchronous streaming to connect to each other,
    with well specified semantics about how each should behave, so that backpressure, completion, cancellation
    and error handling is predictably propagated between the two libraries.
- There is a rich ecosystem of open source libraries that support Reactive Streams,
    and since its inclusion in JDK9, there are a few in development implementations that are
    targetting the JDK, including the incubating <a href="http://openjdk.java.net/jeps/321">JDK9 HTTP Client</a>,
    and the <a href="https://twitter.com/brunoborges/status/915302682939711488">Asynchronous Database Adapter (ADBA)</a>
    effort that have also adopted it
- (See also <a href="http://www.eclipse.org/community/eclipse_newsletter/2018/may/reactivestreams-ee4j.php">What can Reactive Streams offer to EE4J</a>)
[[}]]

[[{]]async/reactive.rxjava,qa.*" bgorange id="rxjava_summary">
● RxJava
@[https://github.com/ReactiveX/RxJava]

ReactiveX provides a set of very-well thought-out cross-language abstraction to
implement the reactive patterns.

 Observable/Operators/Observers
@[http://reactivex.io/documentation/contract.html]
@[http://reactivex.io/documentation/observable.html]
                                         ⇑
                                    <<Subscriber>>
                                    unsubscribe  : - Observable can opt to stop
                                                   event-emission if no more clients
                                                   are subcribed
rLoop-of-Observable-emitted-events:                - unsubscription will cascade back
 ·  Observable → <<IObserver>>: onNext(event)      through the chain of operators
 ·                                                 applying to associated Observable.
 ·  observer   →   observer*1 : handle event    *1 also called "subscriber", "watcher"
 ·                                                 or "reactor" ("reactor pattern")
 end-loop
 Observable    → <<handler>>  : onCompleted()
                  (instance)
 observer      →  observer    : handle event

   WARN:  There is no canonical naming standard in RXJava


  Observable<T>  → operator1 → ... → operatorN  →  Observer
  pushes objects       ^        ^      ^           Subscribes to
 (events) from         ·        ·      ·           the observable
 any source            ·        ·      ·           events
 (ddbb, csv,...)       ·        ·      ·           .onNext()
                       ·        ·      ·           .onCompleted()
          TIP :Learning which operators to use     .onError()
               for a situation and how to combine  .onSubscribe(Disposable d);
               them is the key to master RxJava    ^
┌──────────────────────────────────────────────────┘
├─onSubscribe(Disposible): Free any resources created by the rxJava pipeline.
├─onNext()     : passes each item, one at a time,   to the  Observer
├─onCompleted(): communicates a completion event    to the  Observer
└─onError()    : communicates an error up the chain to the  Observer
                 where the Observer typically defines how to handle it.
                 Unless retry() operator is used to intercept the error,
                 the Observable chain typically terminates, and no
                 more emissions will occur.
                 See also   operators 'Catch' and 'Retry'

By default, Observables execute work on the immediate thread,
which is the thread that declared the Observer and subscribed it.
Not all Observables will fire on the immediate thread, (Observable.interval(),...)

 Creating a source Observable:
  Observable<String> source01 = Observable .just ("value1",...,"valueN");
  Observable<String> source02 = Observable .fromCallable (() -> 1/0);
                                            ^^^^^^^^^^^^        ^^^
                                            Similar to .just() but errors
                                            are captured by the rxJava "pipeline"

  Observable<String> source02 = Observable .create ( emitter ->
  {
        try {
    emitter .onNext (myList.get(0));
    emitter .onNext (myList.get(1));
    ...
    emitter .onComplete() ; // ← Optional
        } catch(Throwable e) {
    emitter .onError(e) ;
        }
  } );
  Observable<String>  source03 = Observable .fromIterable (myIterableList);
  Observable<Integer> source04 = Observable .range (1,10);
  Observable<String>  source05 = Observable .interval (1, TimeUnit.SECONDS);
                                             ^^^^^^^^
                                             Since it operates on a timer →
                                             needs to run on separate thread
                                             and will run on the computation
                                             Scheduler by default

  Observable<String>  source06 = Observable .fromFuture (myFutureValue);
  Observable<String>  source07 = Observable .empty ();
                                             ^^^^^
                                             calls onComplete() and ends

  Observable<String>  source08 = Observable .defer ( () -> Observable.range(start,count));
                                             ^^^^^
                                      Advanced factory pattern.
                                      allows a separate state for each observer
  Observable<String>  source09 = Observable .fromCallable ( () -> Observable.range(start,count));

 creating Single/Maybe/Completable "Utility" Observables:
 ┌─────────────────────────────┬────────────────────────────────┬─────────────────────────────────┐
 │ Single.just("Hello")        │ Maybe.just("Hello")            │ Completable.fromRunnable(       │
 │ .subscribe(...);            │   .subscribe(...);             │   () -> runProcess() )          │
 │                             │                                │ .subscribe(...);                │
 ├─────────────────────────────┼────────────────────────────────┼─────────────────────────────────┤
 │ Emits a single item         │ Emits (or not)a single item    │  does not receive any emissions │
 ├─────────────────────────────┼────────────────────────────────┼─────────────────────────────────┤
 │ SingleObserver              │  MaybeObserver                 │  CompletableObserver            │
 │ .onSubscribe(Disposable d); │  .onSubscribe(Disposable d);   │  .onSubscribe(Disposable d);    │
 │ .onSuccess(T value);        │  .onSuccess(T value);          │  .onComplete();                 │
 │ .onSuccess(Throwable error);│  .onSuccess(Throwable error);  │  .onError(Throwable error);     │
 │                             │  .onComplete();                │                                 │
 └─────────────────────────────┴────────────────────────────────┴─────────────────────────────────┘

 Create Test-oriented observables
   Observable .never ();
   Observable .error ();

 Derive Observables from source:
Observable<Integer> lengths  =  source .map    (String::length);
Observable<Integer> filtered = lengths .filter (i -> i  = 5);

 creating an Observer:
(Lambdas in the source Observable .subscribe can be used in place)
Observer<Integer> myObserver = new Observer<Integer>() {
  @Override public void onSubscribe(Disposable d) { //... }
  @Override public void onNext(Integer value)     { log.debug("RECEIVED: " + value); }
  @Override public void onError(Throwable e)      { e.printStackTrace();}
  @Override public void onComplete()              { log.debu("Done!"); }
};

  Cold/Hot Observables
  └ Cold: - Repeat the same content to different observers.
          - Represent sort-of inmmutable data.
          - A "cold" Observable waits until an observer subscribes to it
            an observer is guaranteed to see the whole sequence of events
  └ Hot : "Broadcast" to all observers at the same time.
          - A "hot" Observable may begin emitting items as soon as it is created.
          - An observer connecting "later" will loose old emissions.
          - Represent real-time events . They are time-sensitive.
          - Emissions will start when first observers calls connect().
          - a cold/hot observable can generate a new hot observable by
            calling publish() that will return a hot ConnectableObservable.
            Helpful to avoid the replay of data on each subscrived Observer.

          - NOTE: A "Connectable" Observable: does NOT begin emitting items
              until its Connect method is called, whether or not any observers
              have subscribed to it.

  About Null
 └ In RxJava 2.0, Observables ☞  NO LONGER SUPPORT EMITTING null VALUES ☜ !!!

  Decision Tree  (Choosing the right Operator for a task)
  (REF: @[http://reactivex.io/documentation/operators.html#tree])
  └ Alphabetical List of Observable Operators
  @[http://reactivex.io/documentation/operators.html#alphabetical

  Core API
  └ rx.Observable "==" [Java 8 Stream + CompletableFuture + "Back-presure" measures ]
    @[http://reactivex.io/documentation/observable.html]    └──────────────┬──────┘
                                                                           │
                                                            probably an intermediate
                                                            buffer for incomming/outgoing
                                                            messages that acts async.
                                                            when not full, and sync when
                                                            full.
    -  rx.Single : specialized version emiting a single item

  └ rx.Operators :
    - Compose Observables in a chain
    - gives the real "reactive" power
    - operators allow to transform, combine, manipulate, and work
      with the sequences of items emitted by Observables.
    - declarative programming
      - AVOID THE THE DRAWBACKS OF CALLBACK-NESTING("callback hell")
      - Most operators operate on an Observable and return an Observable.
        Each operator in the chain modifies the Observable that results
        from the operation of the previous operator. Order matters.
        (the Builder Pattern, also supported, is non-ordered)
  └ rx.Subject :
  @[http://reactivex.io/documentation/subject.html]
    sort of "bridge or proxy" is available in some implementations
    that acts both as an observer and as an Observable.
  └ rx.Scheduler :
  @[http://reactivex.io/documentation/scheduler.html]
    - Needed when using multithreading into the
      cascade of Observable operators.
    - By default, the chain of Observables/operators
      will notify its observers  on the same thread
      on which its Subscribe method is called
    Operator|SubscribeOn         |ObserveOn
    --------+--------------------+---------
            |sets an Scheduler on|sets an Scheduler used
            |which the Observable|by the Observable to
            |should operate.     |send notifications to
            |                    |its observers.
    Scheduler "==" Thread

<hr/>
● External links:
- Rx Workshop: Introduction
 @[https://channel9.msdn.com/Series/Rx-Workshop/Rx-Workshop-Introduction]
- Introduction to Rx: IObservable
 @[http://introtorx.com/Content/v1.0.10621.0/02_KeyTypes.html#IObservable]
- Mastering observables (from the Couchbase Server documentation)
 @[https://developer.couchbase.com/documentation/server/3.x/developer/java-2.0/observables.html]
- 2 minute introduction to Rx by Andre Staltz (“Think of an Observable as an asynchronous immutable array.”)
 @[https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877]
- Introducing the Observable by Jafar Husain (JavaScript Video Tutorial)
 @[https://egghead.io/lessons/rxjs-introducing-the-observable]
- Observable object (RxJS) by Dennis Stoyanov
 @[http://xgrommx.github.io/rx-book/content/observable/index.html]
- Turning a callback into an Rx Observable by @afterecho
 @[https://afterecho.uk/blog/turning-a-callback-into-an-rx-observable.html]
<hr/>
● Ops.classification 1
 Operators creating new Observables
@[http://reactivex.io/documentation/operators.html#creating]
    Create     create Observable from scratch programmatically
    Defer      do not create the Observable until the observer subscribes,
               and create a fresh Observable for each observer
    Empty      create Observables that have very precise and limited behavior
    Never        "
    Throw        "
    From       create some object or data structure
    Interval   create Observable that emits a sequence of integers spaced
               by a particular time interval
    Just       convert an object or a set of objects into an Observable that emits that or those objects
    Range      create an Observable that emits a range of sequential integers
    Repeat     create an Observable that emits a particular item or sequence of items repeatedly
    Start      create an Observable that emits the return value of a function
    Timer      create an Observable that emits a single item after a given delay

 Operators Transforming Items:
@[http://reactivex.io/documentation/operators.html#transforming]
    Buffer     periodically gather items from input into bundles and emit
               these bundles rather than emitting the items one at a time

    FlatMap    transform the items emitted by an Observable into Observables,
               then flatten the emissions from those into a single Observable
    GroupBy    divide an Observable into a set of Observables that each emit a
               different group of items from the original Observable,
               organized by key
    Map        transform each input-item by applying a function
    Scan       apply a function to each item emitted by an Observable,
               sequentially, and emit each successive value
    Window     periodically subdivide items from an Observable into
               Observable windows and emit these windows rather than emitting
               the items one at a time

 Operators selectively filtering emitted events from a source Observable
@[phttp://reactivex.io/documentation/operators.html#filtering]
    Debounce   only emit an item from an Observable if a particular timespan has passed
               without it emitting another item
    Distinct   suppress duplicate items emitted by an Observable
    ElementAt  emit only item n emitted by an Observable
    Filter     emit only those items from an Observable that pass a predicate test
    First      emit only the first item, or the first item that meets a condition, from an Observable
    IgnoreElements   do not emit any items from an Observable but mirror its termination notification
    Last       emit only the last item emitted by an Observable
    Sample     emit the most recent item emitted by an Observable within periodic time intervals
    Skip       suppress the first n items emitted by an Observable
    SkipLast   suppress the last n items emitted by an Observable
    Take       emit only the first n items emitted by an Observable
    TakeLast   emit only the last n items emitted by an Observable


 Operators Combining multiple source Observables into a new single Observable
@[http://reactivex.io/documentation/operators.html#combining]
    And        combine sets of items emitted by two or more Observables by means
    Then       of Pattern and Plan intermediaries
    When

    CombineLatest   when an item is emitted by either of two Observables, combine the
               latest item emitted by each Observable via a specified function and
               emit items based on the results of this function
    Join       combine items emitted by two Observables whenever an item from one
               Observable is emitted during a time window defined according to an
               item emitted by the other Observable
    Merge      combine multiple Observables into one by merging their
               emissions
    StartWith  emit a specified sequence of items before beginning to emit the
               items from the source Observable
    Switch     convert an Observable that emits Observables into a single
               Observable that emits the items emitted by the most-recently-
               emitted of those Observables
    Zip        combine multiple Observables emissions together via a function
               function → emit single items for each input tuple

 Operators handling Errors and helping to recover from error-notifications
@[http://reactivex.io/documentation/operators.html#error]
    Catch   recover from an onError notification by continuing the sequence without error
    Retry   if a source Observable sends an onError notification, resubscribe to it
            in the hopes that it will complete without error

 Utility Operators "toolbox"
@[http://reactivex.io/documentation/operators.html#utility]
    Delay       shift the emissions from an Observable forward in time by a particular amount
    Do          register an action to take upon a variety of Observable lifecycle events

    Materialize    represent both the items emitted and the notifications sent
    Dematerialize   as emitted items, or reverse this process

    ObserveOn   specify the scheduler on which an observer will observe this Observable
    Serialize   force an Observable to make serialized calls and to be well-behaved
    Subscribe   operate upon the emissions and notifications from an Observable
    SubscribeOn   specify the scheduler an Observable should use when it is subscribed to
    TimeInterval  convert an Observable that emits items into one that emits indications
                  of the amount of time elapsed between those emissions
    Timeout     mirror the source Observable, but issue an error notification if a
                particular period of time elapses without any emitted items
    Timestamp   attach a timestamp to each item emitted by an Observable
    Using       create a disposable resource that has the same lifespan as the Observable

 Conditional and Boolean Operators evaluating one or more
  Observables or items emitted by Observables
@[http://reactivex.io/documentation/operators.html#conditional]
    All         determine whether all items emitted by an Observable meet some criteria
                Mathematical and Aggregate Operators
@   Amb         given two or more source Observables, emit all of the items from only the
                first of these Observables to emit an item
              @[http://reactivex.io/documentation/operators.html#mathematical]
    Contains   determine whether an Observable emits a particular item or not
               Average, Concat, Count, Max, Min, Reduce, and Sum
C   DefaultIfEmpty  emit items from the source Observable, or a default item if the
               source Observable emits nothing  onverting Observables
@   SequenceEqual   determine whether two Observables emit the same sequence of items
    SkipUntil   discard items emitted by an Observable until a second Observable emits an item To
C   SkipWhile   discard items emitted by an Observable until a specified condition becomes false

 Connectable Observable Operators
[http://reactivex.io/documentation/operators.html#connectable]
@   TakeUntil   discard items emitted by an Observable after a second Observable emits an item or terminates
    TakeWhile   discard items emitted by an Observable after a specified condition becomes false
    Connect
    Publish
    RefCount
    Replay

 Mathematical and Aggregate Operators
- Operators that operate on the entire sequence of items emitted by an Observable
    Average     calculates the average of numbers emitted by an Observable and emits this average
    Concat      emit the emissions from two or more Observables without interleaving them
    Count       count the number of items emitted by the source Observable and emit only this value
    Max         determine, and emit, the maximum-valued item emitted by an Observable
    Min         determine, and emit, the minimum-valued item emitted by an Observable
    Reduce      apply a function to each item emitted by an Observable, sequentially, and emit the final value
    Sum         calculate the sum of numbers emitted by an Observable and emit this sum

 Backpressure Operators
a variety of operators that enforce particular flow-control policies
    @[http://reactivex.io/documentation/operators/backpressure.html]
- backpressure operators  strategies  for coping with Observables that produce items more
  rapidly than their observers consume them

 Connectable Observable Operators
Specialty Observables that have more precisely-controlled subscription dynamics
    Connect   instruct a connectable Observable to begin emitting items to its subscribers
    Publish   convert an ordinary Observable into a connectable Observable
    RefCount  make a Connectable Observable behave like an ordinary Observable
    Replay    ensure that all observers see the same sequence of emitted items, even if they
              subscribe after the Observable has begun emitting items

 Operators to Convert Observables
    To        convert an Observable into another object or data structure
<hr/>
● Ops.classification 2
- Basic Operators:
  - Suppressing operators:
    - filter, take, skip, takeWhile/skipWhile, distinct, distinctUntilChanged
  - Transforming operators:
    - map, cast, startWith, defaultIfEmpty, switchIfEmpty, sorted, deplay,repeat, scan
  - Reducing operators:
    - count, reduce, all, any, contains
  - Collection operators:
    - toList, toSortedList, toMap, toMultiMap, collect
  - Error recovery Operators
    - onErrorReturn, onErrorReturnItem, onErrorResumeNext, retry
  - Action ("stream life-cicle") Operators:
    - doOnNext, doOnComplete, doOnError, doOnSubscribe, doOnDispose
- Combining Observables:
  - Merging:
    - merge, mergeWith
    - flatMap
  - Concatenation:
    - concat, concatWith
    - concatMap
  - Ambiguous:
    - amb
  - Zipping
  - Combine Latest:
    - withLatestFrom
  - Grouping:
    - groupBy

- Multicasting, Replaying and Caching:
  ( Multicasting is helpful in preventing redundant work being done by multiple
    Observersand instead makes all Observers subscribe to a single stream,
    at least to the point wherethey have operations in common)
  - "Hot" operators. (TODO)
  - Automatic connection:
    - autoConnect, refCount, share
  - replay
  - cache

-<span xspam>Subjects
  - Just like mutable variables are necessary at times even though you
    should strive forimmutability, Subjects are sometimes a necessary tool
    to reconcile imperative paradigmswith reactive ones.
  - PublishSubject
  - Serializin Subject
  - BehaviourSubject
  - ReplaySubject
  - AsyncSubject
  - UnicastSubject

● Custom Ops
@[http://reactivex.io/documentation/implement-operator.html]
[[}]]

[[{]]async/reactive.rxjava,qa.*,01_PM.troubleshooting,01_PM.TODO">
● 5 Not So Obvious Things About RxJava
@[https://medium.com/@jagsaund/5-not-so-obvious-things-about-rxjava-c388bd19efbc]

- Error control [qa]
@[https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators]

- Dealing with RxJava's never-ending Observables [troubleshooting]
@[https://tech.xing.com/dealing-with-rxjavas-never-ending-observables-1ca8f18797ff]
[[}]]



[[{]]async/reactive.testing,qa.testing.async/reactive,01_PM.TODO">
● Awaitility(Async→Sync) Tests
@[https://github.com/awaitility/awaitility]
- Awaitility: DSL allowing to express async results (test expectations) easely.
  removing complexity of handling threads, timeouts, concurrency issues, ...
  that obscured test code.

- Ex 1:
  @Test
  public void updatesCustomerStatus() {
    // Publish a (async) message to a message broker:
    messageBroker.publishMessage(updateCustomerStatusMessage);
    await().atMost(5, SECONDS).until(customerStatusIsUpdated()) ;
    ...
  }
[[}]]

[[$div}]]

<pre zoom  labels="vertx.101,devops">
● Maven Bootstrap
@[https://github.com/vert-x3/vertx-guide-for-java-devs/blob/3.8/step-1/README.adoc]
@[https://github.com/vert-x3/vertx-guide-for-java-devs/tree/3.8/step-1]

Ex: minimally viable wiki written with Vert.x

   └ Features:
     - server-side rendering
     - data persistence through a JDBC connection
       and async ddbb access

   └ Dependencies:
     - Vert.x web: "elegant" APIs to deal with routing, request payloads, etc.
     - Vert.x JDBC client: asynchronous API over JDBC.
     - other libreries for HTML/md rendering

                                          ┌ o configured pom.xml:
 $ $ URL="https://github.com/vert-x3"     │   - Maven Shade Plugin configured to create a single
 $ $ URL="${URL}/vertx─maven─starter"   ←─┤     "fat" Jar archive with all required dependencies
 $ $ git clone ${URL} project01           │   - Exec Maven Plugin to provide the exec:java goal
 $ $ cd project01                         │     that in turns starts the application through the
                                          │     Vert.x io.vertx.core.Launcher class.
                                          │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                          │     (equivalent to running using the vertx cli tool)
                                          │
                                          │ o sample verticle
                                          │
                                          │ o unit tests
                                          │
                                          └ o redeploy.sh: auto compile+redeploy on code changes.
                                              (adjust $VERTICLE in script to match main verticle)
 $ $ mvn package exec:java             ← check that maven install is correct


Tip: The SQL database modules supported by the Vert.x project do not currently
   offer anything beyond passing SQL queries (e.g., an object-relational mapper)
   as they focus on providing asynchronous access to databases.
   However, nothing forbids using more advanced modules from the community,
   and we especially recommend checking out projects like this jOOq generator
   for VertX
   @[https://github.com/jklingsporn/vertx-jooq]

$ mvn clean package
$ java -jar target/project01-SNAPSHOT-fat.jar
[[}]]

[[{]]vertx.101">
● Create HttpServer
REF:@[https://github.com/vert-x3/vertx-guide-for-java-devs/blob/3.8/step-1/src/main/java/io/vertx/guides/wiki/MainVerticle.java]

   import io.vertx.ext.web.handler.BodyHandler;
   public class MainVerticle  extends io.vertx.core.AbstractVerticle  {
      ...
      private io.vertx.core.http.HttpServer server = vertx.createHttpServer(); // vertx defined in Parent Class

      @Override
      public void start(Future<Void> startFuture) {
          Json.mapper.registerModule(new JavaTimeModule());
          FileSystem vertxFileSystem = vertx.fileSystem();
          vertxFileSystem.readFile("swagger.json", readFile -> {
              if (readFile.succeeded()) {
                  // Swagger swagger = new SwaggerParser().parse(readFile.result().toString(Charset.forName("utf-8")));
                  // SwaggerManager.getInstance().setSwagger(swagger);
                  Router router = Router.router(vertx);
                  router.get  (ROUTE_ENTITY01+"/:id")                              .handler(this:: GetEntity01Handler);
                  router.post (ROUTE_ENTITY01       ).handler(BodyHandler.create()).handler(this::PostEntity01Handler);
                                                              └───────┬───────────┘         └───────────┬───────────┘
                                                decode POST req.body (forms,...) to         function signature:
                                                Vert.x buffer objects                       void functionName( RoutingContext context )
                  router.delete(ROUTE_ENTITY01+"/:id")                              .handler(this::DeleEntity01Handler);
                  log.info("Starting Server... Listening on "+RC.host+":"+RC.port);
                  vertx.createHttpServer(_getHTTPServerOptions()).
                          requestHandler(router::accept).listen(
                           8080,                                  ← Different deployments can share the port. Vertx will round-robin
                           /* AsyncResult */ar -> { //
                            if (ar.succeeded()) {
                              LOGGER.info("HTTP server running on port 8080");
                              startFuture.complete();
                            } else {
                              LOGGER.error("Could not start a HTTP server", ar.cause());
                              startFuture.fail(ar.cause());
                            }
                          });
              } else {
                  startFuture.fail(readFile.cause());
              }
          });
      }
    }
[[}]]

<pre zoom  labels="vertx.101">
● Reusable Verticles
@[https://github.com/vert-x3/vertx-guide-for-java-devs/blob/3.8/step-2/README.adoc]

- resulting verticles will not have direct references to each other
  as they will only agree on destination names in the event bus as well
  as message formats.
- messages sent on the event bus will be encoded in JSON.

- Ex:
@[https://github.com/vert-x3/vertx-guide-for-java-devs/tree/3.8/step-2/src/main/java/io/vertx/guides/wiki]
 HttpServerVerticle.java
 WikiDatabaseVerticle.java
 MainVerticle.java      ← its sole purpose is to bootstrap the app
                          and deploy other verticles.
 @[https://github.com/vert-x3/vertx-guide-for-java-devs/blob/3.8/step-2/src/main/java/io/vertx/guides/wiki/MainVerticle.java]
  package io.vertx.guides.wiki;

  public class MainVerticle extends AbstractVerticle {
    @Override
    public void start(Promise<Void> promise) {
      Promise<String> promise01 = Promise.promise();
      vertx.deployVerticle(new WikiDatabaseVerticle(), promise01);
      promise01.future().compose(id -> {
        Promise<String> promise02 = Promise.promise();
        vertx.deployVerticle(
          "io.vertx.guides.wiki.HttpServerVerticle",  // <4>
          new DeploymentOptions().setInstances(2),    // <5>
          promise02);
        return promise02.future();
      }).setHandler(ar -> {
        if (ar.succeeded()) {
          promise.complete();
        } else {
          promise.fail(ar.cause());
        }
      });
    }
  }
[[}]]

[[$div}]]

[[{$div]]
● VertX Continuation [[{vertx.101,async/reactive.rxjava,cloud.k8s,architecture.frontend,01_PM.TODO]]
● VertX (TODO)
• RxJava Integration:
@[https://github.com/vert-x3/vertx-guide-for-java-devs/blob/3.8/step-7/README.adoc]
  <!-- Refactoring some code to use reactive programming with the
        popular RxJava library and its Vert.x integration -->

• Vertx+k8s:
@[http://escoffier.me/vertx-kubernetes/]
• SockJS:
@[https://github.com/vert-x3/vertx-guide-for-java-devs/blob/3.8/step-10/README.adoc]
  - Event-bus bridge allowing web apps to seamlessly communicate over
  - event bus from JavaScript running in the browser by receiving and publishing
  - messsages just like any verticle would do
• Angular Client:
@[https://github.com/vert-x3/vertx-guide-for-java-devs/blob/3.8/step-9/README.adoc]

 TODO:
 Cookbook recipe:
    Vertx vertx = Vertx.vertx();
    HttpServer server = vertx.createHttpServer();
    server.requestHandler(req -> {
      req.response().end("Hello world");
    });
    server.listen(8080);
 ------------------------------------
  """
  There are many features and modules that we haven’t covered in this guide, such as:
    - Clustering using Hazelcast, Infinispan, Apache Ignite or Zookeeper,
    - Exposing⅋consuming over HTTP/2, possibly (but not necessarily) with gRPC
    - Using NoSQL databases such as MongoDB or Redis.
    - Sending emails over SMTP.
    - Messaging with AMQP, Stomp, Kafka, MQTT or RabbitMQ.
    - Using OAuth2 authentication from custom and popular providers.
    - Vert.x sync for writing blocking-style code that is later
      turned into fibers non-blocking code at runtime.
    - Publishing and discovering micro-services from registries, for
      instance when deploying on cloud environments like OpenShift,
    - Exposing metrics and health checks.
  """

• What's new Vert.X 4.0: (2020-12-09):
@[https://github.com/vert-x3/wiki/wiki/4.0.0-Release-Notes]
[[}]]

[[$div}]]

[[{$div]]
● Other frameworks [[{async/reactive.*,01_PM.low_code,messaging.jms,messaging.activemq]]
                   [[architecture.batch,architecture.distributed]]
● JavaLite
- lightweight system for processing asynchronous jobs.
- Use Cases:
  - website that needs to run batch process in background
  - We receive batch of inputs to be processed in a "best-effort"
    but replay as-soon-as-possible to client that we have the
    input batch ready for processing.

- easy-to-use "Wrapper" on top o Apache Artemis (ActiveMQ "next Gen")
  the Async adds an abstraction layer based on a Command Pattern,
  which makes it trivial to add asynchronous processing.

- Embedded broker instance with reasonable defaults

- Ex:
  Async async = new Async(            ←  CREATE one or more Queues
            "/opt/project1",          ← place to store persistent messages
            false,
            new QueueConfig(
               "MESSAGES_QUEUE",      ← queue 1 name
               new CommandListener(),
               5)                     ← number of listeners(threads) to
            ,
            new QueueConfig(
                  "ERRORS_QUEUE",     ← queue 2 name (No limit in the number o
                  new ErrorListener(),                queues)
               5)
            );
        async .start();

   public class HelloCommand             ←  Create a command
       extends Command {
       private String message;

       public HelloCommand(String message) {
         this.message = message;
       }

       public HelloCommand() {}          ←   necessary (forbid finals)

       @Override
       public void execute() {
           System.out.println(message);
       }
   }


   for(int i = 0; i < 100; i++){         ←  sending commands async
      async.send(
        "MESSAGES_QUEUE",
        new HelloCommand("Hello Number "+ i));
   }
   Output will be similar to
   → Hello Number 0
   → Hello Number 1
   → ...

   List<Command> topCommands             ←  Peek (vs Consume) 3 "top"
      =  async .getTopCommands(            commands from "ERROR_QUEUE"
           3, "ERROR_QUEUE");


- Commands can be read and processed synchronously (one-by-one)
  from an individual queue one at the time without a listener.
  Ex:   you do not want to process errors automatically . To do so:

  ErrorCommand errorCommand =           ←  Consume message
       (ErrorCommand)receiveCommand("ERROR_QUEUE");
  ... // Process manually

  Text vs Binary messages
  - To be compatible with JMS the  communication protocol is limited t
    - javax.jms.TextMessage   ← Default mode.
    - javax.jms.BytesMessage  ← async.setBinaryMode(true);

    In both cases, the   serialization of a command is first done to XML
    with the use of XStream.
  - If a given command has transient field that must NOT  be serialized,
    use the field annotation @XStreamOmitField to ignore it.

  -  WARN:  Do not switch from mode to mode while having persistent
            messages stored in your queues.

  Commands with DB access
  - If queue processing requires a database connetion, DBCommandListener
    can be used:
    Async async = new Async(filePath, false, new
        QueueConfig("MESSAGES_QUEUE", new
        DBCommandListener(                 ← If JNDI connection is setup, the
         "java:comp/env/jdbc/conn01"), 5)    listener will find and open it
   );                                        Use your tomcat/Jboss/... container
                                             documentation to set up it properly

  (Artemis) Config API
  - For complex app configuration, the underlying Artemis API
    can be used:
    org.apache.activemq.artemis.core.config.Condifuration
       artemisCOnfig = async.getConfig();

- See also filequeue in this map. It's faster but doesn't support
  Queue to DDBBs.
[[}]]

[[{]]async/reactive.*,01_PM.low_code,messaging.jms,messaging.activemq,scalability.101"
   id="fileQueue_summary">
<span bgorange xsmall>FileQueue
@[https://github.com/stimulussoft/filequeue]
- KISS alternative using MVStore
@[http://www.h2database.com/html/mvstore.html]
- All producers and consumers run within a JVM.
- H2 MVStore DB used for storage.
- Queue items are   POJOs serialized into Json using jackson .
-  faster than JavaLite due to performance shortcut :
  -  File Queue will transfer queued items directly to consumers
     without hitting the database provided there are consumers
     available, otherwise, message will be persisted
-  Doesn't support persistence to JNDI DDBB
- fixed and exponential back-off retry is present.

  PRE-SETUP :
  - maven/gradle package dependency:
    com.stimulussoft:filequeue:1.1.4

  Usage :
  - Implement POJO extending FileQueueItem
  - Implement consume(FileQueueItem) on <<Consumer>> to process items
  - Instantiate a FileQueue object and call config() to configure
  - Call startQueue() to start the queue
  - Call stopQueue() to stop the queue processing
  - Call FileQueue.destroy() to shutdown all static threads (optional)

  Example Implementation:
  └ Queue Ussage example:
    FileQueue queue = FileQueue.fileQueue();
    FileQueue.Config config = FileQueue.
        config(
          queueName,
          queuePath,
          TestFileQueueItem.class,
          new TestConsumer()
        )
        .maxQueueSize(MAXQUEUESIZE)           // ← queueItem will block until an slot becomes
                                                   available or ExceptionTimeout thrown
        .retryDelayAlgorithm(
           QueueProcessor.RetryDelayAlgorithm.EXPONENTIAL)
        .retryDelay(RETRYDELAY)
        .maxRetryDelay(MAXRETRYDELAY)
        .maxRetries(0);                       // ← Infinite retries
        .persistRetryDelay(                   // ← delay between DDBB scans.
           PERSISTENTRETRYDELAY);
    queue.startQueue(config);                 // ← Start queue
    for (int i = 0; i < ROUNDS; i++)
      queue.queueItem(                        // ← Submit items
        new TestFileQueueItem(i)
      );
    queue.stopQueue();                        // ← stopQueue

  └ Consumer implementation:
    static class TestConsumer implements Consumer<FileQueueItem> {

        public TestConsumer() { }

        @Override
        public Result consume(FileQueueItem item)
        throws InterruptedException {
                        try {
        TestFileQueueItem retryFileQueueItem =
            (TestFileQueueItem) item;
        if (retryFileQueueItem.getTryCount() == RETRIES )
            return Result.SUCCESS;
        return Result.FAIL_REQUEUE;
                        } catch (Exception e) {
        logger.error(e.getMessage(), e);
        return Result.FAIL_NOQUEUE;
                        }
        }
    }

  └ FileQueueItem implementation:

    import com.stimulussoft.filequeue.*;

    static class TestFileQueueItem extends FileQueueItem {
      Integer id;
      public TestFileQueueItem() { super(); };
      private TestFileQueueItem(Integer id) {
          this.id = id;
      }
      @Override
      public String toString() { return String.valueOf(id); }
      public Integer getId() { return id; }
      public void setId(Integer id) { this.id = id; }
    }

  └ File Caching:
    - If there is the need to cache a file to disk or perform resource
      availability checks prior to items being placed on the queue,
      implement availableSlot() on the QueueCallback interface. This method
      is called as soon as a slot becomes available, just before the item
      is place on the queue. It may be used to cache a file to disk, or
      perform resource availability pre-checks (e.g. disk space check).
[[}]]
[[$div}]]
[[$div}]]

[[{$div]]
● QA
[[{$div]]
[[{]]qa.billion_dolar_mistake">
● Cost of software failures
$312 billion per year: global cost of software bug (2013)
$300 billion dealing with the Y2K problem

$440 million loss by Knight Capital group Inc. in 30 minutes, August 2012
$650 million loss by NASA Mars missions in 1999; unit conversion bug
$500 million Arian 5 maiden flight in 1996; 64-bit to 16-bit conversion bug
"$Nightmare" billion Boeing 737Max

2011: Software caused 25% of all medical device recalls.
[[}]]

[[{]]qa.101,qa.error_control,qa.billion_dolar_mistake" id="code_analysis_tools_summary">
● Checker framework (Java 8+)
 fix errors at compile time  (vs later on at execution/runtime)
@[https://github.com/typetools/checker-framework]
@[https://checkerframework.org/manual/]
@[https://www.youtube.com/watch?v=6E1CSydgzQc]
@[https://www.baeldung.com/checker-framework]

  COMPARED TO ALTERNATIVES (SpotBugs, Infer  Jlint, PMD,...)
                 ┌─────────────┬────────┬────────┐                 ┌──────────────────┬─────────────────────┐
                 │ Null Pointer│        │        │                 │ Verification     │ Bug─Finding         │
                 │    errors   │ False  │Annotat.│                 │ ( Checker FW ,)  │ (Infer,StopBugs,    │
                 │             │        │        │                 │                  │  SonarQube,...      │
                 │Found│ Missed│warnings│written │  ┌──────────────┼──────────────────┼─────────────────────┤
  ┌──────────────┼─────┼───────┼────────┼────────┤  │Goal          │ prove that       │ find some bugs      │
  │ Checker FW.  │9    │ 9     │  4     │  35    │  │              │ no bug exits     │ at "low cost"       │
  ├──────────────┼─────┼───────┼────────┼────────┤  ├──────────────┼──────────────────┼─────────────────────┤
  │StopBugs      │0    │ 9     │  1     │  0     │  │Check specifis│ user provided    │ infer likely specs  │
  ├──────────────┼─────┼───────┼────────┼────────┤  │specificat    │                  │                     │
  │Jlint         │0    │ 9     │  8     │  0     │  ├──────────────┼──────────────────┼─────────────────────┤
  ├──────────────┼─────┼───────┼────────┼────────┤  │False         │ None!!!          │ acceptable          │
  │PMD           │0    │ 9     │  0     │  0     │  │negatives     │                  │                     │
  ├──────────────┼─────┼───────┼────────┼────────┤  ├──────────────┼──────────────────┼─────────────────────┤
  │Eclipse 2017  │0    │ 9     │  8     │  0     │  │False         │ manually supress │ heuristics focus on │
  ├──────────────┼─────┼───────┼────────┼────────┤  │positives     │ warnings         │ most important bugs │
  │IntelliJ      │0    │ 9     │  1     │  0     │  ├──────────────┼──────────────────┼─────────────────────┤
  │+@NotNull 2017│3    │ 6     │  1     │ 925+8  │  │Downside      │ user burden      │ missed bugs         │
  └──────────────┴─────┴───────┴────────┴────────┘  └──────────────┴──────────────────┴─────────────────────┘

  PROBLEM:                                           │  SOLUTION:
   STANDARD JAVA TYPE SYSTEM IS NOT GOOD ENOUGH      │  Java 8+ allows to compile programs
   - Next example compile, but fail at runtime:      │  using   "PLUGGABLE TYPE SYSTEMs" ,
     Ex.1:                                           │  allowing to apply stricter checks
       System.console().readLine(); ←  NullPointer   │  than default ones in compiler like
     Ex.2:                                           │  Ex:
       Collections.emptyList()                       │  $ javac  -processor NullnessChecker  MyFile.java
               .add("one"); ←  Unsupported Operation │
     Ex.3:                                           │   PLUGABLE TYPE SYSTEM COMPILATION SCHEMA:
       Date key1 = new Date();                       │           (1)           No errors (2)
       myMap.put(key1, "now");                       │    Source ───→ Compiler ────┬───→ Executable
       myMap.get(key1);    ←  returns "now"          │      ^            │         │(2)       ^
       key1.setSeconds(0); ←  Mutate key             │      │            v         v          │
       myMap.get(key1);    ←  returns null           │      │         Standard    Optional    │ Guaranteed
                                                     │      │         Compiler    Type     ───┘ Behaviour
                                                     │      │         Errors      Checker
                                                     │      │                      │
                                                     │      │                      v
                                                     │      └────────────────── Warnings :
                                                     │
                                                     │     (2) plugable type system allows generation
                                                     │         of executable to allow CI continue the
                                                     │         pipeline with further tests (functional
                                                     │         testing, configuration testing, ...)

  #################################
• # Checker Framework Instalation #
  #################################
<!-- { -->
(See new releases/versions at
  @[https://search.maven.org/search?q=g:org.checkerframework])

  STEP 01:                            │  STEP 02:
──────────────────────────────────────┼────────────────────────────────────────────────────
  Add next pom.xml dependencies like: │  tweak  maven-compiler-plugin  to use
  <dependency>                        │  Checker Framework as a pluggable Type System:
      <groupId>                       │  <plugin>
        org.checkerframework          │    <artifactId> maven-compiler-plugin </artifactId>
      </groupId>                      │    <version>3.6.1</version>
      <artifactId>                    │    <configuration>
        checker-qual                  │      <source>1.8</source>
      </artifactId>                   │      <target>1.8</target>
      <version>2.11.0</version>       │      <compilerArguments>
  </dependency>                       │        <Xmaxerrs>10000</Xmaxerrs>
  <dependency>                        │        <Xmaxwarns>10000</Xmaxwarns>
      <groupId>                       │      </compilerArguments>
        org.checkerframework          │      <annotationProcessors>  ← "==" javac -processor ...
      </groupId>                      │        <annotationProcessor>
      <artifactId>                    │      org.checkerframework.checker.nullness.NullnessChecker
        checker<                      │         </annotationProcessor>
      /artifactId>                    │         <annotationProcessor>
      <version>2.11.0</version>       │      org.checkerframework.checker.interning.InterningChecker
  </dependency>                       │         </annotationProcessor>
  <dependency>                        │         <annotationProcessor>
      <groupId>                       │      org.checkerframework.checker.fenum.FenumChecker
        org.checkerframework          │         </annotationProcessor>
      </groupId>                      │         <annotationProcessor>
      <artifactId>                    │      org.checkerframework.checker.formatter.FormatterChecker
        jdk8                          │         </annotationProcessor>
      </artifactId>                   │      </annotationProcessors>
      <version>2.11.0</version>       │      <compilerArgs>
  </dependency>                       │        <arg>-AprintErrorStack</arg>
                                      │        <arg>-Awarns</arg>
                                      │      </compilerArgs>
                                      │    </configuration>
                                      │  </plugin>

( STEP 03:  Manually add extended type annotations to your java code)
<!-- } -->


  ###########
• # Ussage  #
  ###########
<!-- { -->
-   Avoiding Nulls

  CHECKS  ON TYPES                               │ CHECKS ON FUNCTION DECLARATION
                                                 │                   ┌────┬────┬───────────────────────────┐
                                                 │                   │FUNC│FUNC│DESCRIPTION                │
  private static int func1                       │                   │PRE─│POST│                           │
    ( @NonNull  String[] args)                   │                   │COND│COND│                           │
  {                                              │ ┌─────────────────┼────┼────┼───────────────────────────┤
      return args.length;                        │ │@RequiresNonNull │X   │    │variables are expected  to │
  }                                              │ │                 │    │    │be non─null when invoked.  │
                                                 │ ├─────────────────┼────┼────┼───────────────────────────┤
  public static void main                        │ │@EnsuresNonNull  │    │X   │variables are guaranteed to│
    ( @Nullable  String[] args) {                │ │                 │    │    │be non─null on return.     │
      ...                                        │ ├─────────────────┼────┼────┼───────────────────────────┤
      func1(args);                               │ │@EnsuresNonNullIf│    │X   │variables are guaranteed to│
  }         ^^^^                                 │ │                 │    │    │benon─null on ret.true/fals│
      [WARNING] ... [argument.type.incompatible] │ └─────────────────┴────┴────┴───────────────────────────┘
       incompatible types in argument.           │
        found    : null                          │
        required : @Initialized @NonNull ...     │

-   Convert String constants into Safe Enum with Fenum
                                                (Fake enum)
  static final @Fenum("country") String ITALY = "IT";
  static final @Fenum("country") String US = "US";
  ...
  static final @Fenum("planet") String MARS = "Mars";
  static final @Fenum("planet") String EARTH = "Earth";
  ...

  void function1(@Fenum("planet") String inputPlanet){
      System.out.println("Hello " + planet);
  }

  public static void main(String[] args) {
      obj.greetPlanets(US);   ←----  [WARNING] ...
  }                                   incompatible types in argument.
                                       found   : @Fenum("country") String
                                       required: @Fenum("planet") String

-   Regular Expressions
  @Regex(1) private static String FIND_NUMBERS = "\\d*";
  ^^^^^^^^^                                      ^^^^^^
  Force String variable                       [WARNING] ...
  to store a regex with                       incompatible types in assignment.
  at least one matching                         found   : @Regex String
  group                                         required: @Regex(1) String



-   Validating tainted (non-trusted) input

   @Untainted
   String validate (String sqlInput) {
      // Do any suitable checks, throw on error
      @SuppressWarnings("tainting")      ← "swear" that developer got sure
      @Untainted String result = ...;       of input correctness
      return result;
  }

  void execSQL( @Untainted  String sqlInput) {
      ...
  }

  public static void main(String[] args) {
      obj.execSQL(arg[0]);             ← warning at compile time
      obj.execSQL(validate(arg[0]));   ← "OK". validate un-tain the input
  }

-   Mark as Immutable
  @Immutable Date date = new Date();
  date.setSeconds(0);   ←   compile-time error
<!-- } -->

- Avoiding (certain) concurrency errors
<!-- { -->
  Lock Checker enforces a locking discipline:
  "which locks must be held when a given operation occurs"

  CHECKS ON TYPES                             │ CHECKS ON FUNCTION DECLARATION
                                              │                 ┌────┬────┬───────────────────────────┐
   @GuardedBy("lockexpr1","lockexpr2",...)    │                 │FUNC│FUNC│DESCRIPTION                │
             int var1 = ....;                 │                 │PRE─│POST│                           │
   ^^^^^^^^^^                                 │                 │COND│COND│                           │
  a thread may dereference the value referred │┌────────────────┼────┼────┼───────────────────────────┤
  to by var1 only when the thread holds all   ││@Holding        │X   │    │All the given lock exprs   │
  the locks that ["lockexpr1",...] currently  ││(String[] locks)│    │    │are held at method call    │
  evaluates to.                               │├────────────────┼────┼────┼───────────────────────────┤
                                              ││@EnsuresLockHeld│    │X   │Ensures locks are locked on│
                                              ││(String[] locks)│    │    │return,ex. lock adquired by│
                                              ││                │    │    │ReentrantLock.lock().      │
                                              │├────────────────┼────┼────┼───────────────────────────┤
                                              ││@EnsuresLockHeld│    │X   │Ensures locks are locked on│
                                              ││(String[] locks)│    │    │return,ex.lock conditionaly│
                                              ││                │    │    │adquired by ReentrantLock  │
                                              ││                │    │    │.lock()                    │
                                              ││                │    │    │if method return true|false│
                                              │└────────────────┴────┴────┴───────────────────────────┘
   SIDE EFFECT SPECIFICATIONS
  ┌────────────────────┬───────────────────────────────────────────────┐
  │ @LockingFree       │method does NOT acquire│release locks:         │
  │                    │· it is not synchronized,                      │
  │                    │· it contains NO synchronized blocks           │
  │                    │· it contains no calls to lock│unlock methods  │
  │                    │· it contains no calls to methods that are not │
  │                    │  themselves @LockingFree                      │
  │                    │(@SideEffectFree implies @LockingFree)         │
  ├────────────────────┼───────────────────────────────────────────────┤
  │ @ReleasesNoLocks   │· method maintains a strictly                  │
  │                    │  nondecreasing lock hold count                │
  │                    │  on the current thread for any locks          │
  │                    │  held at method call.                         │
  ├────────────────────┼───────────────────────────────────────────────┤
  │ @EnsuresLockHeld   │method adquires new locsk                      │
  │ @EnsuresLockHeldIf │(default if no @LockingFree│@MayReleaseLocks│  │
  │                    │@SideEffectFree│@Pure used).                   │
  └────────────────────┴───────────────────────────────────────────────┘
<!-- } -->

-  Format String Checker
  - prevents use of incorrect format strings in System.out.printf,....

    void printFloatAndInt
         ( @Format({FLOAT, INT})  String   format )
    {
      System.out.printf(  format , 3.1415, 42);
    }
- I18n Format Checker examples
  MessageFormat.format("{0} {1}", 3.1415);
                                        ^
                              second argument missing
  MessageFormat.format("{0, time}", "my string");
                                    ^^^^^^^^^^^
                                    cannot be formatted
                                    as Time type.
  MessageFormat.format("{0, thyme}", new Date());
                            ^^^^^
                            unknown format type

  MessageFormat.format("{0, number, #.#.#}", 3.1415);
                                    ^^^^^
                              subformat is invalid.

- Property File Checker!!!!    TODO
  - It ensures that used keys are found in the corresponding
    property file or resource bundle.

- GUI Effect Checker
  - It is difficult for a programmer to remember
    which methods may be called on which thread(s).
    (Main GUI thread or others)
   Checker types the method as if:
   - It accesses no UI elements (and may run on any thread);
   - It may access UI elements  (and must run on the UI thread)

- (physical) Internation System UNIT annotations :
  @Acceleration: Meter Per Second Square @mPERs2
  @Angle       : Radians @radians
                 Degrees @degrees
  @Area        : square millimeters @mm2,
                 square meters @m2
                 square kilometers @km2
  @Current     : Ampere @A
  @Length      : Meters @m
                 millimeters @mm
                 kilometers @km
  @Luminance   : Candela @cd
  @Mass        : kilograms @kg
                     grams @g
  @Speed       : meters per second   @m
                 kilometers per hour @kmPERh
  @Substance   : Mole @mol
  @Temperature : Kelvin @K
                 Celsius @C
  @Time        : seconds @s
                 minutes @min
                 hours @h

- @Unsigned/@Signed ← guarantees values are not mixed

- type alias or typedef
  share same representation as another type
  but is conceptually distinct from it.
  Ex 1: get sure that Strings representing addresses
        and passwords are NOT mixed
  Ex 2: get sure that integers used for meters are
        not mixed with integers used for centimeters.

  Example:
  @NonNull List<String>
  List<@NonNull String>
  @Regex String validation = "(Java|JDK) [7,8]"

  private String getInput(String parameterName){
   final String retval = @Tainted request.getParameter(parameterName);
   return retval;
  }

  private void runCommand(@Untainted String… commands){
   // the previously tainted String must be validated before being passed in here.
   ProcessBuilder processBuilder = new ProcessBuilder(command);
   Process process = processBuilder.start();
  }
<hr/>
● SpotBugs
@[https://github.com/spotbugs/spotbugs/issues]
• OOSS static analysis tool for java code bugs.
• Well maintained (as of 2021-12-21)
• "spiritual successor of FindBugs"
• SpotBugs checks for more than 400 bug patterns.
• Works from GUI+cli, maven/gradle/eclipse integration.
• Plugin extension support (just download plugin jar and
  it will be detected and included):
  • fb-contrib:
  • Security Audits for Java Web applications:
  @[https://find-sec-bugs.github.io/]
    It can detect 141 different vulnerability types with
    over 823 unique API signatures.

• Running SpotBugs.
  · Presetup. Compile java code to classes or jars.
    SpotBugs runs against compiles class files, using source code
    as a reference when displaying output.

  $ java -jar ../spotbugs.jar ...$SPOTBUG_ OPTIONS ..

                             JVM OPTIONS
                             ===========
  -Xmx1500m                ← set JVM heap to big/1500MB  (recomended)

                             STANDARD OPTIONS
                             ================
  -textui                  ← vs -gui
  -effort min              ← := min|less|default|more|max
                             min: decrease mem use/precision/exec.time
                             max: increase mem use/precision/exec.time
  -project ... \           ← project *.fb or *.fbp created through the GUI
                             (fb == FindBugs)
  -pluginList jar1;jar2     \
  -home $SPOTBUG_DIR       ← ex: /opt/spotbugs
  -adjustExperimental      ← Lower priority of experimental Bug Patterns.
  -workHard                ← Ensure analysis effort is at least ‘default’.
  -sortByClass=dir1/spotbugs.txt ← textui only
                                   also supported to set multiple reports
  -include filter01.xml     ← show only bugs match filter specified.
  -exclude filter02.xml     ← *1
  -onlyAnalyze com.foo.*,com.bar.* ← Unlike filter, analysis is skipt
                              for any other class type
                              WARN: some detectors may produce inaccurate
                              results
  -low                      ← Report all bugs.
  -medium                   ← Report medium and high priority bugs.
  -high                     ← Report only high priority bugs.
  -relaxed                  ← suppress heuristics, avoidin false positives.
  -html=../report.html      ← Output HTML. Alternative:
                            ← Output HTML. Alternative:
                              NOTE : It is -html=value while other flags work like
                                     -flag value (without the "=" sign)
                              -html:fancy.xsl=...  (DOM+JS for navigation + CSS)
                              -html:fancy-hist.xsl=...  fancy.xsl evolution
                              Other output formats include xml/sarif/emacs/xdocs
  -nested false             ← disable scanning of nested jar (def:enabled)
  -auxclasspath ...         ← It should include all jar/dirs containing classes
                              that are part of the program being analyzed but
                              you do not want to have analyzed for bugs.
  -auxclasspathFromInput    ← Read auxclasspath from STDIN, line by line
  -auxclasspathFromFile
  -analyzeFromFile fileI    ← Read input file list from file line-by-line.
  -showPlugins              ← listavailable detector plugins.

                              OUTPUT CUSTOMIZATION OPTIONS
                              ============================
  -timestampNow             ← Set results timestamp to current time.
  -quiet                    ← Suppress error messages.
  -longBugCodes             ← Report long bug codes.
  -progress                 ← Display progress in console.
  -release $name            ← Set release name in report
  -maxRank $rank            ← Only report issues with a bug rank at least
                              as scary as that provided.
  -dontCombineWarnings      ← Don’t combine warnings differing only in line num.
  -train[:outputDir]:       ← Save training data (experimental);
  -useTraining[:inputDir]:  ← Use training data (experimental);
  -redoAnalysis $filenam    ← Redo using config. from previous analysis.
  -sourceInfo $file         ← Specify source info file (line numbers for
                              fields/classes).
  -projectName $name        ← Descriptive name of project.
  -reanalyze $filename      ← Redo analysis in provided file.

                              OUTPUT FILTERING OPTIONS
                              ========================
  -bugCategories cat1,cat2  ← Only report bugs in those categories.
  -excludeBugs baseline_bug ← Exclude bugs that are also reported in
                              baseline xml output.
  -applySuppression         ← Exclude bugs matching suppress.filter from *fbp

                              DETECTOR (VISITOR) CONFIGURATION OPTIONS
                              ========================================
  -visitors v1,v2,...       ← Run only named visitors.
  -omitVisitors v1,v2,...   ← Omit named visitors.
  -chooseVisitors +v1,-v2,. ← enable/disable detectors.
  -choosePlugins +p1,-p2,   ← Selectively en/dis-able plugins.
  -adjustPriority v1=raise|lower,v2=...

                              PROJECT CONFIGURATION OPTIONS
                              =============================
  -sourcepath $source_path  ← Set source path for analyzed classes.
  -exitcode                 ← Set exit code of process.
  -noClassOk                ← Output empty warning file if no classes are
                              specified.
  -xargs                    ← Get list of class/jar files from STDIN
  -bugReporters name,-name2,.. ← Bug-reporter decorators to explicitly
                                 enable/disable.
  -printConfiguration       ← Print configuration and exit

*1┌── myIncludeOrExcludeFilter.xml ────
  │
  │ <?xml version="1.0" encoding="UTF-8"?>
  │ <FindBugsFilter>
  │ <Match>
  │   <Bug                       match if  pattern and/or code and/or category match
  │     pattern="..."          ← comma-separated list of patterns to match
  │                              ex.: DLS_DEAD_LOCAL_STORE,DM_EXIT,
  │     code="..."             ← coarse-grained matching comma-sep. list of bug
  │                              abbreviations(DC,DE,IC,IJU,MS,SIC,URF,UUF,XYZ,...)
  │     category="..."         ← even more coarse-grained :=
  │                              CORRECTNESS, BAD_PRACTICICE,
  │   />                         PERFORMANCE, STYLE, MT_CORRECTNESS
  │                                 (M)ulti(T)hreaded ┘
  │
  │
  │   <Confidence value="1"/>  ← 1 match high-confidence warnings,
  │                              2 match normal-confidence warnings
  │                              3 match low-confidence warnings
  │
  │    <Rank value="1" />     ←  1  to 4 : scariest
  │                              5  to 9 : scary
  │                             10 to 14: troubling
  │                             15 to 20: concern
  │
  │   <Package name="~.."/> ← name/regex. Nested packages are NOT included
  │   <Class   name="~.. /> ← name/regex. NOTE: Some bug instances relate to
  │                                       2+ classes.
  │   <Source  name="..."/> ← name/regex.  match warnings associated to source file.
  │                           └────┬────┘
  │                         regex if prefixed by ~
  │
  │   <Method
  │    name="funcXXX"
  │    params="int,..."
  │    returns="void"
  │   />
  │
  │   <Field name="..." />   ← type=... instead of name can also be used
  │   <Local name="..." />
  │   <Type  name="..." />
  │ </Match>
  │
  │ <Or>  <Match /><Match /></Or>
  │ <And> <Match /><Match /></And>
  │ <Not> <Match />         </Not>
  │
  │ </FindBugsFilter>
  └────────────────────────────────────────────



• See examples at:
@[https://spotbugs.readthedocs.io/en/latest/filter.html]


<hr/>

● Lint4j
@[http://www.jutils.com/]
•  WARN : Not maintained any more.
• Lint4j ("Lint for Java") is a static Java source and byte code
  analyzer that detects locking and threading issues, performance and
  scalability problems, and checks complex contracts such as Java
  serialization by performing type, data flow, and lock graph analysis.

• Ussage @[http://www.jutils.com/uguide.html]
$ $ lint4j \
$    -sourcepath src/main \             ← analyze source
$    -classpath lib/bcel.jar:... \
$    -exclude "packagename"   \         ← package or package-prefix
$    "com.jutils.lint4j.*"
$
$ $ lint4j -sourcepath .../log4j.jar    ← analyze binary
$     "org.apache.*"
$
$ $ lint4j  \
$    -sourcepath ./build/log4j.jar      ← analyze 2 package in jar
$    org.apache.log4j \
$    org.apache.log4j.spi
$
$ $ lint4j \
$   -sourcepath com/.../ClassN.java \
$               com/.../CalssJ.java

[[}]]

<pre zoom
  labels="qa.101,01_PM.low_code,concurrency.101,01_PM.troubleshooting,scalability.profiling,01_PM.WiP"
  id="sonarqube_summary" >
● SonarQube
• SonarQube empowers all developers to write cleaner and safer code.
• Comunity with 200K+ dev. teams.
• Easely integrates with CI/CD pipelines.
  Jenkins, GitHub Actions, Bitbucket Pipelines, GitLab CI, Azure Pipelines, ...

• A simple client/server working enviroment can be setup in minutes like:

  ┌── SERVER SIDE: ────────────────────────────────
  │
  │• LAUNCH SERVER INSTANCE
  │  ======================
  │$ $ docker run -d --name sonarqube               \
  │$   -e SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true    \
  │$   -v $(pwd)/sonarqube_data:/opt/sonarqube/data \
  │$   -p 9000:9000 sonarqube:latest
  │
  │• Create a new project through the web console
  │  and annotate the 40-random-chars TOKEN.
  │  (Needed by client-side sonar-scanner).
  └─────────────────────────────────────────────────

  ┌─ CLIENT SIDE: ──────────────────────────────────
  │
  │• 1) PROJECT_SRC_ROOT
  │  ┌ └ sonar-project.properties ─┐
  │  │sonar.projectKey=my:project  ← Required
  │  │                             │
  │  │#sonar.projectName=...       ← def:project key
  │  │#sonar.projectVersion=1.0    ← def:'not provided'
  │  │sonar.sources=src/java/      ← relative to
  │  │                             │ sonar-project.properties
  │  │#sonar.sourceEncoding=UTF-8  │
  │  │sonar.java.binaries=./build/ ← compiled *class dir.
  │  │sonar.java.libraries=...     ← ex: /lib/*.jar,./plugins/lib/*jar
  │  └─────────────────────────────┘
  │
  │• 2) launch client scanner like
  │  2.alt1) using mvn plugin:
  │    $ $ mvn clean verify sonar:sonar \
  │    $     -Dsonar.projectKey=test2 \
  │    $     -Dsonar.host.url=http://...:9000 \
  │    $     -Dsonar.login=$PROJECT_TOKEN
  │
  │  2.alt2) using docker
  │    $  $ docker run \
  │    $    --rm \
  │    $    -e SONAR_HOST_URL="http:...:9000" \
  │    $    -e SONAR_LOGIN="$PROJECT_TOKEN" \
  │    $    -v "${YOUR_REPO}:/usr/src" \
  │    $    sonarsource/sonar-scanner-cli
  └─────────────────────────────────────────────────

• See original source for more info about
   SonarScanner Troubleshooting recipes, advanced docker config,
   running, caching scanner files ,  usng self-signed certs:
@[https://docs.sonarqube.org/latest/analysis/scan/sonarscanner/]
  *1: not needed if the associated project is already linked to a
      git repository on the server side.

• alternatives to SonarQube include:
  - Facebook Infer @[http://fbinfer.com/]
    (Static analysis Java/C/...)
  - Scrutinizer:
  - StopBugs:
  - Eclipse Static Code Analasys:
    Eclipse → Properties → Java → Compiler → Errors/Warnings → Null analysis:
      Null pointer access
      Potential null pointer access
      Redundant null check:
        x Include 'assert' in null analysis
        x Enable annotation-based null analysis
          Violation of null specification
          Conflict between null annotations an null inference
          Unchecked conversion from non-annotated type to @NonNull type
          Problems detected by pessimistic analysis fro free type variables
          Unsafe "@Nonnull" interpretation of the free type variable from library
          Redundant null anotation:
          "@NonNull" parametere not annotated in overriding method
          Missing "@NonNullByDefault" annotation on package
          x Use default annotations for null specifications (configure)
          x Inherit null annotations
          x Enable syntatic null analisys for fields
      x Treat above errors like fatal compile erros (make compiled code not executable)
<hr/>
[[}]]


[[{]]qa.101">
● JavaDoc
-----------------------+-------------------------------------+-------------------------+-------   Example
Tag⅋ Parameter         | Usage                               | Applies to              | Since    /**
-----------------------+-------------------------------------+-------------------------+-------    * Short one line description.
@authorJohn Smith      | Describes an author.                | Class, Interface, Enum  |           * <p>
-----------------------+-------------------------------------+-------------------------+-------    * Longer description. ...
@versionversion        | Provides software version entry.    | Class, Interface, Enum  |           * ...here.
                       | Max one per Class or Interface.     |                         |           * <p>
-----------------------+-------------------------------------+-------------------------+-------    * And even more explanations to follow
@sincesince-text       | Describes when this functionality   | Class, Interface, Enum, |           * in consecutive paragraphs
                       | has first existed.                  | Field, Method           |           *
-----------------------+-------------------------------------+-------------------------+-------    * @author John Bla
@seereference          | Provides a link to other element    | Class, Interface, Enum, |           * @param  variable Description ....
                       | of documentation.                   | Field, Method           |           * @return Description ....
-----------------------+-------------------------------------+-------------------------+-------    */
@paramname descrip     | Describes a method parameter.       | Method                  |          public int methodName (...) {
-----------------------+-------------------------------------+-------------------------+-------       // method body with a return statement
@return description    | Describes the return value.         | Method                  |          }
-----------------------+-------------------------------------+-------------------------+-------
@exceptionclass desc   | Describes an exception that may     | Method                  |
-----------------------+-------------------------------------+-------------------------+-------
@throwsclass desc      | be thrown from this method.         |                         |
-----------------------+-------------------------------------+-------------------------+-------
@deprecated descr      | Describes an outdated method.       | Class, Interface, Enum, |
                       |                                     | Field, Method           |
-----------------------+-------------------------------------+-------------------------+-------
{@inheritDoc}          | Copies the description from the     | Overriding Method       | 1.4.0
                       | overridden method.                  |                         |
-----------------------+-------------------------------------+-------------------------+-------
{@linkreference}       | Link to other symbol.               | Class, Interface, Enum, |
                       |                                     | Field, Method           |
-----------------------+-------------------------------------+-------------------------+-------
{@value#STATIC_FIELD}  | Return the value of static field.   | Static Field            | 1.4.0
-----------------------+-------------------------------------+-------------------------+-------
{@codeliteral}         | Formats literal text in the code    | Class, Interface, Enum, | 1.5.0
                       | font. It is equivalent to           | Field, Method           |
                       | {@literal}                          | Class, Interface, Enum, | 1.5.0
-----------------------+-------------------------------------+-------------------------+-------
{@literalliteral}      | Denotes literal text. The enclosed  | Field, Method           |
                       | text is interpreted as not          |                         |
                       | containing HTML markup or nested    |                         |
                       | javadoc tags.                       |                         |
-----------------------+-------------------------------------+-------------------------+-------
[[}]]

<pre zoom id="testing_summary"
  labels="101.qa.101,_doc_has.comparative,01_PM.WiP" >

● Junit
• (test scoped) dependencies:
   org.junit.jupiter:junit-jupiter-api:${junit_version}
   org.junit.jupiter:junit-jupiter-engine:${junit_version}

• JUnit test summary:
  @org.junit.jupiter.api.Test

  @DisplayName("Display name Class Level")
  @DisplayNameGeneration(ReplaceCamelCase.class)
  class JUnitAPISummaryTest {
                          // testing Life-Cycle methods:
    @BeforeEach { ... } // ← executed before each @Test in class
    @AfterEach  { ... } // ← executed after  each @Test in class
    @BeforeAll  { ... } // ← executes before all tests.
    @AfterAll   { ... } // ← executes after  all tests.



    @org.junit.jupiter.api.Test
    @DisplayName("Test parameters with nice names")
    @ParameterizedTest(name = "Use the value {0} for test")
    @ValueSource(insts = { -1, -4 })
    void test01( int number ) {
      Assumptions.assumeTrue (...);            // ← failed assumption aborts test
      Assumptions.assumeFalse(...);            //   Continuing execution will fail.
                                               //   Example: Initial state is not expected one

                                               // Frequently Used:
      Assertions.assertTrue   (param1);        // or assertFalse
      Assertions.assertNull   (param1);        // or assertNotNull
      Assertions.assertEquals (param1,param2); // or assertNotEquals
      Assertions.assertNotSame(param1,param2);
      Assertions.fail         ("code must not be reached");

      assertAll("check ...",                   //  grouped
        () -> assertEquals(..),
        () -> assertEquals(..),
        () -> assertEquals(..)
      );

                                               // Collections:
      Assertions.assertArrayEquals   (array1, array2, "...");
      Assertions.assertIterableEquals(list1, list2);


      Assertions.assertTimeout(                // Timeouts:
        Duration.ofMillis(100), () -> {
          Thread.sleep(50);
          return "result";
        });

      Throwable exception =                    // Assert exception thrown
         Assertions.assertThrows(
           IllegalArgumentException.class,
           () -> {
             throw new IllegalArgumentException("...");
           });
    }

    @Test @Disabled   ...                      // Conditional execution
    @Test @EnabledOnOs({ OS.LINUX }) ...
    @Test @DisabledIfSystemProperty(named = "ci-server", matches = "true")
    @Test @EnabledIfEnvironmentVariable(named = "ENV", matches = "test-env")

   @RepeatedTest(
      value = 9,
      name = "{displayName}-{currentRepetition}/{totalRepetitions}")
   void valuesCannotPassTen(RepetitionInfo info) {
       ...info.getCurrentRepetition() ...
   }

   @ParameterizedTest(
    name = "Test fruit \"{0}\" with rank {1}")
   @CsvSource({
           "'string1', 1",         // ← Repeat test with different input
           "'string2', 2",
           ...
   })
   void testWithCsvSource(String fruit, int rank) {
       assertNotNull(fruit);
       assertNotEquals(0, rank);
   }
  }

• Testsuites: run tests in multiple test classes and/or different packages.
  @RunWith(JUnitPlatform.class)
  @SelectPackages("com.myComp.junit5.package01")
  public class JUnit5TestSuiteExample
  { }

• See also: @[https://www.infoq.com/news/2018/01/VSCodeJunit]

• AsserJ (Fluent Assertions) is composed of several modules:  [TODO]
  - core      module: assertions for JDK types (String, Iterable, Stream, Path, File, Map...)
  - Guava     module: assertions for Guava types (Multimap, Optional...)
  - Joda Time module: assertions for Joda Time types (DateTime, LocalDateTime)
  - Neo4J     module: assertions for Neo4J types (Path, Node, Relationship...)
  - DB        module: assertions for relational database types (Table, Row, Column...)
  - Swing     module provides a simple and intuitive API for functional testing of Swing user interfaces

  import static org.assertj.core.api.Assertions.*;
  ...
  assertThat(frodo.getName()).isEqualTo("Frodo"); //  ← basic assertions
  assertThat(frodo).isNotEqualTo(sauron);

  assertThat(frodo.getName())                     // ← chaining string specific assertions
      .startsWith("Fro")
      .endsWith("do")
      .isEqualToIgnoringCase("frodo");

  assertThat(fellowshipOfTheRingList)            // ← collection specific assertions
     .hasSize(9)                                 //   (there are plenty more)
     .contains(frodo, sam)
     .doesNotContain(sauron);

  assertThat(frodo.getAge())
     .as("check %s's age", frodo.getName())     // ← as() used to describe the test
     .isEqualTo(33);                            //    will be shown before the error message

  assertThatThrownBy(() -> {                    // ← exception assertion ( standard style)
     throw new Exception("boom!"); })
  .hasMessage("boom!");
  Throwable thrown = catchThrowable(() -> {     // ← exception assertion  ( BDD style)
     throw new Exception("boom!");
  });
  assertThat(thrown).hasMessageContaining("boom");

  assertThat(fellowshipOfTheRingList)
      .extracting(TolkienCharacter::getName)    // ← 'extracting' feature on Collection
      .doesNotContain("Sauron", "Elrond");      //

  assertThat(fellowshipOfTheRingList)
     .extracting("name", "age", "race.name")    // extracting multiple values at once grouped in tuples
     .contains(
        tuple("Boromir",   37, "Man"   ),
        tuple("Sam"    ,   38, "Hobbit"),
        tuple("Legolas", 1000, "Elf"   ) );

  assertThat(fellowshipOfTheRingList)
    .filteredOn(                              // ← filtering before asserting
      fellow -> fellow.getName().contains("o")
    )
    .containsOnly(aragorn, frodo);

  assertThat(fellowshipOfTheRingList)
    .filteredOn(                              // combining filtering and extraction
      fellow -> fellow.getName().contains("o")
    )
    .containsOnly(aragorn, frodo)
    .extracting(
       fellow -> fellow.getRace().getName())
    .contains("Hobbit", "Elf");

  // and many more assertions:
  // iterable, stream, array, map, dates, path, file, numbers, predicate, optional ...

<hr/>
● Property Testing
• A property testing is just something like:

  for all (x, y, ...)
  such as precondition(x, y, ...) holds
  property(x, y, ...) is true

  It checks that a function/program/whatever is under test
  abides by a property.  Most of the time, properties do not
  have to go into too much details about the output, they
  just have to check for useful characteristics that must be
  seen in the output.

• Property based testing has become quite famous in the functional
  world. Mainly introduced by QuickCheck framework in Haskell, it
  suggests another way to test software. IT TARGETS ALL THE SCOPE
  COVERED BY EXAMPLE BASED TESTING: (UNIT TESTS TO INTEGRATION TESTS).

• Available automated test technics:
 @[https://medium.com/criteo-engineering/introduction-to-property-based-testing-f5236229d237]

          △ • Random
     full ┆   - Fuzzing
       △  ┆   - Monkey testing
       ┆  ┆
    Input ┆ • Static Analysis
    scope ┆   - Mem. leaks        • Example based
  covered ┆   - Unitialized mem.    - Unit tests
       ┆  ┆   - Nulls.              - QA test
       ▽  ┆   - Threading issues    - UI tests
   partial┆   - ...
         ─┼─╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶╶▷
            Low  ← Feature compliance →    High


• Extracted from @[https://en.wikipedia.org/wiki/QuickCheck].
  List of Java libs for property testing :
  "FunctionalJava's QuickCheck module". FunctionalJava.  2015-08-14
  "Quickcheck for Java". Quickcheck.dev.java.net.        2011-12-09
  "JCheck". JCheck.                                      2011-12-09
  "junit-quickcheck". junit-quickcheck.                  2013-07-03
  "jqwik for the JUnit5 Platform". jqwik.                2017-06-19
  "Quick Theories property tests Java 8"                 2017-10-30
  "jetCheck prop.-based tests    Java 8" (JetBrains)     2018-07-10


• e.g. test using 'jqwik':
  """ fizzBuzz() must return "Fizz"
      for every divisible-by-3 input """
  →  PRECONDITION: Consider inputs in [1 ... 100] divisible by 3
  → POSTCONDITION: fizzBuzz() returns "Fizz"

  import java.util.*;
  import java.util.stream.*;
  import net.jqwik.api.*;

  class FizzBuzzTests {

      String fizzBuzz(int i) {               // ← function to test
         boolean div3 = (i % 3 == 0),
                 div5 = (i % 5 == 0);
         if (div3⅋⅋ div5) return "FizzBuzz";
         if (div3) return "Fizz";
         if (div5) return "Buzz"
         return String.valueOf(i);
      }

      @Provide
      Arbitrary<Integer> divisibleBy3() {    // ← Precondition
        return Arbitraries.integers()        //   input to function
          .between(1, 100)                   //   divides by 3.
          .filter(i -> i % 3 == 0);
      }

      final List<String> IN_OUT =
        IntStream.range(1, 100)
          .mapToObj((int i) -> )
          .collect(Collectors.toList());

      @Property                              // ← Test to execute
      boolean divBy3_starts_with_Fizz(
        @ForAll("divisibleBy3") int i) {     // ← "inject" precondition
        return IN_OUT
               .get(i - 1)
               .startsWith("Fizz");          // ← check Postcondition
      }
  }
[[}]]

[[{]]qa.testing,cloud.aws,devops,01_PM.backlog">
● Amazon CodeGuru
- Powered by IA.
- CodeGuru consists of two components
– Amazon CodeGuru Profiler:
helps developers find an application’s most expensive lines
of code along with specific visualizations and recommendations
on how to improve code to save money.
- Amazon CodeGuru Reviewer:
helps enhance the quality of code by scanning for critical issues,
identifying bugs, and recommending how to remediate them.

  ┌→ Write Code
  |    |
  |    v
  |  Review Code  ← CodeGuru Reviewer
  |    |
  |    v
  |  Test App     ← CodeGuru Profiler
  |    |
  |    v
  |  Deploy App
  |    |
  |    v
  |  Run App      ← CodeGuru Profiler
  |    |
  └----┘

- Profiler supports application written
in Java virtual machine (JVM) languages such as Clojure,
JRuby, Jython, Groovy, Kotlin, Scala, and Java.
- Reviewer’s bug-fixing recommendations currently support
Java code stored in GitHub, AWS CodeCommit, or Bitbucket.
[[}]]
[[$div}]]

[[{$div]]
[[{]]java_lang.101,qa.error_control,java_lang.debugging,qa.billion_dolar_mistake">
<span xsmall bgorange>Exceptions
- (compiler) checked vs unchecked (Error, RuntimeException and their subclasses).
- Checked: All except Error, RuntimeException and their subclasses
- Error: Exceptional conditions external to the application.
java.lang.Object
│
└─ java.lang.Throwable   ← Only instances of this (sub/)class are thrown
│                       in JVM, can be thrown in throw statement or can
│                       be an argument in catch clause.
│
├─   java.lang.Exception
│    │
│    ├─  java.lang.RuntimeException (non─checked)  ← Most common error raised by
│    │                                               developer code
│    │
│    └─  java.lang.Exception        (checked ─A)   ←  Don't use . checked exceptions end up
│                                                     being converted to Runtime Excep.
│                                                     and bloats the code.
│
└─   java.lang.Error                (non─checked)  ← serious problems that app code
                                                    should not try to catch.
                                                    ThreadDeath error, though a "normal" condition,
                                                    is also a subclass of Error because most apps
                                                    should not try to catch it.

 Dump Exception stack trace to STDERR:
StringWriter writer = new StringWriter();
PrintWriter printWriter = new PrintWriter( writer );
e.printStackTrace( printWriter );
printWriter.flush();
System.err.println(writer);


● "Optional": Avoid Nulls
<a href="http://files.zeroturnaround.com/pdf/zt_java8_best_practices.pdf">REF</a>
import java.util.Optional;
Optional<Sgtring> optional = Optional.ofNullable(a); // ← Create an optional
optional.map ( s -> "RebelLabs:" + s);               // ← Process the optional
optional.flatMap( s -> Optional.ofNullable(s));      // ← map a function that retunrs Optional
optional.ifPresent(System.out::println);             // ← run if the value is ther

optional.get();                                      // ← Alt 1: get the value or throw an exception
optional.orElse("Hello world!");                     // ← Alt 2: get the value or default

optional.filter( s -> s.startsWith("RebelLabs"));    // ← return empty Optional if not satisfied

[[}]]

● FailSafe [[{qa.error_control,architecture.distributed,01_PM.WiP]]
@[https://github.com/failsafe-lib/failsafe]
• Fault tolerance and resilience patterns for the JVM
• lightweight, zero-dependency library for handling failures
  in Java 8+.
• It works by wrapping executable logic with one or more
  resilience policies, which can be combined and composed
  as needed.
• Current policies include:
  · Retry
  · CircuitBreaker
  · RateLimiter
  · Timeout
  · Fallback.

• Current features include:
  · Async Execution
  · Event Listeners
  · Execution Context
  · Execution Cancellation
  · Standalone Execution
  · Strong Typing
  · Extension Points
[[}]]

[[{]]qa.error_control,qa.billion_dolar_mistake" >
● JSR Annotations for Defect Detection
@[https://stackoverflow.com/questions/1476757/jsr305-vs-jsr308-java-type-anotations-which-is-going-to-be-the-standard]
[[}]]

[[{]]qa.billion_dolar_mistake,01_PM.TODO">
<a xsmall href='https://blogs.oracle.com/java-platform-group/entry/java_8_s_new_type'>Type Annotations</a>
( TODO: Compare how it compares/overlaps CheckerFramework )

  @NonNull      compiler can determine cases where a      │ @(Un)Tainted          Identity types of data that should
                code path might receive a null value,     │                       not be used together, such as remote
                without ever having to debug a            │                       user input being used in system
                NullPointerException. The compiler        │                       commands, or sensitive information in
                just print a warning, but it              │                       log streams
                continues to compile!!!                   │
                                                          │ @                     Units of measure ensures that numbers
  @ReadOnly     compiler will flag any attempt to         │                       used for measuring objects are used
                change the object. This is similar to     │                       and compared correctly, or have
                Collections.unmodifiableList, but         │                       undergone the proper unit
                more general and verified at compile time.│                       conversion.
                                                          │
  @Regex        Provides compile-time verification        │ @FunctionalInterface  indicates that the type declaration
                that a String intended to be used as      │                       is intended to be a functional
                a regular expression is a properly        │                       interface, as defined by the Java
                formatted regular expression.             │                       Language Spec.

└  Examples :
  Annotation
  @NonNull List<String>                              ← A non-null list of Strings.
  List<@NonNull String>                              ← A list of non-null Strings.
  @Regex String validation = "(Java|JDK) [7,8]"      ← Check at compile time that this String is a valid regular expression.
  private String getInput(String parameterName){     ← The object assigned to retval is tainted and not for use in sensitive operations.
    final String retval =
      @Tainted request.getParameter(parameterName);
    return retval;
  }

  private void runCommand(@Untainted String… commands){            Each command must be untainted. For example, the previously
    ProcessBuilder processBuilder = new ProcessBuilder(command);   tainted String must be validated before being passed in here.

    Process process = processBuilder.start();
  }
[[}]]

[[{]]qa.testing.bdd,01_PM.TODO">
● JBehave
• testing framework for Behaviour-Driven Development (BDD).
• BDD is an evolution of test-driven development (TDD) and acceptance-test
  driven design, and is intended to make these practices more
  accessible and intuitive to newcomers and experts alike. It shifts
  the vocabulary from being test-based to behaviour-based, and
  positions itself as a design philosophy.

• BDD Summary:
  1) Write story
    Scenario: A trader is alerted of status
    Given a stock and a threshold of 15.0
    When stock is traded at 5.0
    Then the alert status should be OFF
    When stock is traded at 16.0
    Then the alert status should be ON

  2) Map to java

  3) Configure Stories

  4) Run Stories
[[}]]

● OpenAPI: contract-driven Dev [[{standards.openapi,architecture.api_management]]
                               [[vertx.*,01_PM.low_code,qa.documentation,01_PM.backlog]]
@[https://developers.redhat.com/devnation/tech-talks/develop-openapi-vertx]
- "Contract Driven Development" (or API Design First approach) is a methodology
  that uses declarative API Contracts to enable developers to efficiently design,
  communicate, and evolve their HTTP APIs, while automating API implementation
  phases where possible.
[[}]]


[[$div}]]
[[$div}]]<!-- qa -->



● JDepend [[{qa.reporting,qa.versioning,security.auditing]]
@[https://github.com/clarkware/jdepend]
@[https://htmlpreview.github.io/?https://github.com/clarkware/jdepend/blob/master/docs/JDepend.html]
- JDepend traverses Java class and source file directories and
  generates design-quality-metrics for each Java package
  in terms of its extensibility, reusability, and maintainability
  to effectively manage and control package dependencies.
[[}]]



[[{$div]]
● DDBB/persistence:
[[{$div]]
[[{persistence.sql,qa.data,01_PM.low_code,cloud.*,spring.*,persistence.jpa,01_PM.TODO]]
● Flyway: SQL schema versioning
• tool providing version control for database (SQL) schemas
  and automated schema (tables, columns, sequences), data, views, procedures
  and packages evolution.
• Single source of truth for DDBB versioning.
• highly reliable
• Supports for many different SQL databases, including        [cloud]
  cloud ones (Amazon RDS, Azure Database, Google Cloud SQL).

  ##########
  # HOW-TO #
  ##########
• PRESETUP: The target database to manage and user with update privileges be created first,
            "outside" of flyway.

• Database changee are called   Migrations . They can be:
  · Versioned  migrations: identified by a version number, applied in order exactly once.
                           An optional revert migration version can be provided to roolback
                           changes in case of error.
  · Repeatable migrations:

• Flyway used an internal flyway_schema_history ddbb to keep track of migrations applied .

• SQL and JAVA  migrations in src/main/resources/db/migration/ are automatically      [spring]
  applied in Spring Boot when  'org.flywaydb:flyway-core' compile dependency is
  detected.
  src/main/resources/db/migration/
  └ V1__Initial_schema.sql   ← Flyway expected file name
                               "Verssion"__"Prefix".sql
    CREATE TABLE table01 (
     id      BIGSERIAL PRIMARY KEY NOT NULL,
     column1 BIGINT NOT NULL,
     column2 FLOAT8 NOT NULL,
     column3 INTEGER NOT NULL,
     column4 VARCHAR(255) UNIQUE NOT NULL,
    );

  └ V2__Add_column5.sql
    ALTER TABLE table01
      ADD COLUMN column5 VARCHAR(255);

● Obevo: DDBB change manager
@[https://github.com/goldmansachs/obevo]
- Obevo: ddbb deployment tool handling enterprise scale schemas and complexity.
- By Goldman Sachs.
- Obevo is a database deployment tool that helps teams manage database
  changes in their Software Development Life Cycle (SDLC) process. In
  addition to handling production deployments, Obevo aids the
  development phase by defining a clean structure to maintain DB object
  code, and helps the testing phase with features such as in-memory
  database conversion. Notably, Obevo was designed for systems of
  enterprise scale and complexity and can manage hundreds of DB objects
  in a schema, while still handling new schemas in a simple manner.
  “We feel our ability to onboard a large and long-lived system to a
  clean SDLC process is a key differentiator in the open source
  space,” said Shant, a vice president in the Technology Division.
  “By publishing this to the open source community, we hope to aid
  others in their own DB deployment estates while growing a strong
  community around the tool.”


  """ Deploying tables for a new application?
    Or looking to improve the DB Deployment of a years-old system with
    hundreds (or thousands) of tables, views, stored procedures, and
    other objects?

    Obevo has your use case covered.

    Supported platforms: DB2, H2, HSQLDB, Microsoft SQL Server, MongoDB,
    Oracle, PostgreSQL, Redshift (from Amazon), Sybase ASE, Sybase IQ
  """
• Alternatives to Flyway include LiquidBase, ... [TODO]
[[}]]


● Jooq: SQL made simple [[{persistence.sql,vertx.*,async/reactive.*,01_PM.low_code,qa.data,01_PM.TODO]]
@[https://www.jooq.org/]

● Vertx+Jooq
@[https://github.com/jklingsporn/vertx-jooq]
  jOOQ-CodeGenerator to create vertxified DAOs and POJOs.
  Now with JDBC, async and reactive support!
@[https://github.com/jklingsporn/vertx-jooq]

[[}]]

● Hibernate/JPA Summary [[{persistence.jpa,01_PM.troubleshooting,01_PM.TODO]]
@[https://quarkus.io/guides/hibernate-orm-panache-guide]

- Hibernate Gotchas:
  https://github.com/theotherian/hibernate-gotchas
  http://www.theotherian.com/2013/07/hibernate-joins-maxresults.html
  hibernate, joins, and max results: a match made in hell

- Common Hibernate Exceptions Every Developer Must Know
  https://thorben-janssen.com/hibernate-exceptions/
[[}]]

● speedment: SQL as Streams [[{persistence.sql,01_PM.low_code,qa.data,java_lang.functional]]
@[https://github.com/speedment/speedment]
- Stream ORM toolkit and runtime.
- The toolkit analyzes the metadata of an existing SQL database and
  automatically creates a Java representation of the data model.
- The powerful ORM enables you to create scalable and efficient Java
  applications using standard Java streams with no need to type SQL or
  use any new API.

  SQL                                    JAVA 8 Stream Equivalent
 --------------------------------------------------------------------
  FROM                                   stream()
 --------------------------------------------------------------------
  COUNT                                  count()
 --------------------------------------------------------------------
  LIMIT                                  limit()
 --------------------------------------------------------------------
  DISTINCT                               distinct()
 --------------------------------------------------------------------
  SELECT                                 map()
 --------------------------------------------------------------------
  WHERE                                  filter() (before collecting)
 --------------------------------------------------------------------
  HAVING                                 filter() (after  collecting)
 --------------------------------------------------------------------
  JOIN                                   flatMap()
 --------------------------------------------------------------------
  UNION                                  concat(s0, s1).distinct()
 --------------------------------------------------------------------
  ORDER BY                               sorted()
 --------------------------------------------------------------------
  OFFSET                                 skip()
 --------------------------------------------------------------------
  GROUP BY                               collect(groupingBy())
 --------------------------------------------------------------------
       SEARCH FILMS WITH LENGTH > 120 MINUTES:
  SELECT                             ←   final
   `film_id`,`title`,`description`,      Optional<Film>longFilm =
   `release_year`, `language_id`,          films.stream()
   `original_language_id`,                .filter(
   `rental_duration`,`rental_rate`,          Film.LENGTH.greaterThan(120)
   `length`,`replacement_cost`,            )
   `rating`,`special_features`,           .findAny();
   `last_update`
  FROM                                    Searches optimized in background!
       `sakila`.`film
  WHERE
      (`length` > 120)
[[}]]

[[{]]persistence.sql,01_PM.low_code,01_PM.TODO" >
<span xsmall TODO>reladomo
(by Goldman Sachs)
@[https://github.com/goldmansachs/reladomo]
enterprise grade (ORM) object-relational mapping framework for Java with
the following enterprise features:

- Strongly typed   compile-time  checked query language
- Bi-temporal chaining
- Transparent multi-schema support
- Full support for unit-testable code
[[}]]

● c3p0 [[{persistence.sql,qa.*,scalability.persistence,01_PM.TODO]]
@[https://www.mchange.com/projects/c3p0/#what_is]
• c3p0: easy-to-use library for making traditional JDBC drivers
        "enterprise-ready" augmenting them with jdbc3 functionality,
        , optional jdbc2 extensions and jdbc4 (v 0.9.5+).
• It provides for:
  - A class which adapt traditional DriverManager-based JDBC drivers to the
    newer javax.sql.DataSource scheme for acquiring database Connections.
  - Transparent pooling of Connection and PreparedStatements behind DataSources
    which can "wrap" around traditional drivers or arbitrary unpooled DataSources.
• The library tries hard to get the details right:
  - c3p0 DataSources are both Referenceable and Serializable, and are thus
    suitable for binding to a wide-variety of JNDI-based naming services.
  - Statement and ResultSets are carefully cleaned up when pooled Connections
    and Statements are checked in, to prevent resource- exhaustion when clients use
    the lazy but common resource-management strategy of only cleaning up their
    Connections. (Don't be naughty.)
  - The library adopts the approach defined by the JDBC 2 and 3 specification
    (even where these conflict with the library author's preferences). DataSources
    are written in the JavaBean style, offering all the required and most of the
    optional properties (as well as some non-standard ones), and no-arg
    constructors. All JDBC-defined internal interfaces are implemented
    (ConnectionPoolDataSource, PooledConnection, ConnectionEvent-generating
    Connections, etc.) You can mix c3p0 classes with compliant third-party
    implementations (although not all c3p0 features will work with external
    implementations of ConnectionPoolDataSource).
[[}]]
[[$div}]]
[[{$div]]
● Snappy Fast de/compressor [[{persistence.fs,scalability.persistence,01_PM.TODO]]
@[https://github.com/xerial/snappy-java]
- Java port of the snappy @[http://code.google.com/p/snappy/]
[[}]]

● Cache
● JCache [[{scalability.cache,01_PM.TODO]]
- Map-Like API optimized for caching.
- 1.0 drawbacks:
  - No async operations.
- Implemented by Hazelcast and others
[[}]]

● JSON
● JSON-P /JSR-374 [[{persistence.JSON,security.TLS/X509,security.aaa]]
- TODO: Patterns of JSON Matching:
  Streaming based, binding based, expression based.
@[https://dzone.com/articles/patterns-of-reading-json?edition=598293]
- REF:JSON processing public review
  @[https://www.infoq.com/news/2017/03/json-processing-public-review]

- JSR 374, API for JSON Processing (JSON-P) version 1.1.
  - Java 8 streams and lambdas alternative to Gson and Jackson.
  - expected to be included in J2EE 8 .
  - compatible with JSON IETF standards.
  - It includes support for:
    - JSON Pointer
    - JSON Patch
    - JSON Merge Patch
    - Query and transformation operations
  - Designed to parse/generate/query standard JSON documents.
─────────────────────────────────────────────────────────────
● JSON-B / JSR-367
  @[https://itsallbinary.com/jackson-vs-gson-vs-json-b-vs-json-p-vs-org-json-vs-jsonpath-java-json-libraries-features-comparison/]
- B stands for Ojbect binding
  - Standard binding layer for converting
    Java objects to/from JSON messages, defining a default mapping algorithm
    for converting existing Java classes to JSON, while enabling developers
    to customize it through annotations.

- Real World REST APIT Example:
  package com.mycomp.project1;

  import java.io.BufferedReader;
  import java.io.DataOutputStream;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.net.HttpURLConnection;
  import java.net.URL;
  import java.security.KeyManagementException;
  import java.security.NoSuchAlgorithmException;

  import javax.net.ssl.HttpsURLConnection;
  import javax.net.ssl.SSLContext;
  import javax.net.ssl.SSLSocketFactory;
  import javax.net.ssl.HostnameVerifier;
  import javax.net.ssl.SSLSession;
  import javax.net.ssl.TrustManager;
  import javax.net.ssl.X509TrustManager;                    [security.aaa]
  import java.security.cert.X509Certificate;

  import org.json.JSONObject; ←··············· https://github.com/stleary/JSON-java/
                                               - reference implementation demonstrating:
                                                 - how to parse    JSON docs to Java objects
                                                 - how to generate JSON documents from the Java objects.
                                               - Project goals include:
                                                 - Adherence to the JSON spec.
                                                 - No external dependencies
                                                 - Fast execution and low memory footprint
                                               - It can also convert to/from:
                                                 JSON, XML, HTTP headers, Cookies, Comma Delimited Text
                                                 (org.json.CDT or CSV).
  import java.util.Date;
  import java.util.Scanner;

  public class TestAPI<JSONArray> {
      static String userpass = "operator1:ecllqy";
      private static SSLSocketFactory sslSocketFactory = null;

      private JSONObject sendPost(String url, String post_body, String token) throws Exception
      {
          URL obj = new URL(url);
          String basicAuth = "Basic " +
              javax.xml.bind.DatatypeConverter.printBase64Binary(userpass.getBytes());

          HttpsURLConnection con = (HttpsURLConnection) obj.openConnection();

          setAcceptAllVerifier((HttpsURLConnection)con); // TODO: WARN Add certificate validation.

          con.setRequestMethod("POST"); //add request header
          con.setRequestProperty("Content-Type", "application/json");
          con.setRequestProperty("Cache-Control", "no-cache");
          if (token.isEmpty()) { con.setRequestProperty("Authorization", basicAuth);
          } else               { con.setRequestProperty("Authorization", "Bearer "+token);
          }
          con.setDoOutput(true);
          DataOutputStream wr = new DataOutputStream(con.getOutputStream());
          wr.writeBytes(post_body);
          wr.flush();
          wr.close();
          int responseCode = con.getResponseCode();

          BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));
          StringBuffer response = new StringBuffer();
          String inputLine; while ((inputLine = in.readLine()) != null) { response.append(inputLine); }
          in.close();
          return new JSONObject(response.toString()); //String myJSONStr
      }


      /*                                                                              */
      /**
       * Overrides the SSL TrustManager and HostnameVerifier to allow
       * all certs and hostnames.
       * WARNING: This should only be used for testing, or in a "safe" (i.e. firewalled)
       * environment.
       *
       * @throws NoSuchAlgorithmException
       * @throws KeyManagementException
       */
      protected static void setAcceptAllVerifier(HttpsURLConnection connection) throws NoSuchAlgorithmException, KeyManagementException {
          // Create the socket factory.
          // Reusing the same socket factory allows sockets to be
          // reused, supporting persistent connections.
          if( null == sslSocketFactory) {
              SSLContext sc = SSLContext.getInstance("SSL");
              sc.init(null, ALL_TRUSTING_TRUST_MANAGER, new java.security.SecureRandom());
              sslSocketFactory = sc.getSocketFactory();
          }

          connection.setSSLSocketFactory(sslSocketFactory);

          // Since we may be using a cert with a different name, we need to ignore
          // the hostname as well.
          connection.setHostnameVerifier(ALL_TRUSTING_HOSTNAME_VERIFIER);
      }

      private static final TrustManager[] ALL_TRUSTING_TRUST_MANAGER = new TrustManager[] {
          new X509TrustManager() {
              public X509Certificate[] getAcceptedIssuers() {
                  return null;
              }
              public void checkClientTrusted(X509Certificate[] certs, String authType) {}
              public void checkServerTrusted(X509Certificate[] certs, String authType) {}
          }
      };

      private static final HostnameVerifier ALL_TRUSTING_HOSTNAME_VERIFIER  = new HostnameVerifier() {
          public boolean verify(String hostname, SSLSession session) {
              return true;
          }
      };
  }
[[}]]

● RESTAssured: REST API testing [[{qa.testing.REST_API,persistence.json]]
 FULL JOURNEY == Simulate full (REST) API in expected order
└ Pre-Setup:
  <dependency>
      <groupId>io.rest-assured</groupId>
      <artifactId>scala-support</artifactId>
      <version>3.0.6</version>
      <scope>test</scope>
  </dependency>
  <dependency>
      <groupId>io.rest-assured</groupId>
      <artifactId>json-schema-validator</artifactId>
      <version>3.0.6</version>
      <scope>test</scope>
  </dependency>

└ Ussage Example:
  package com.mycompany.myproject.mymodule;

  import static junit.framework.TestCase.assertTrue;
  import static org.hamcrest.Matchers.*;

  import static io.restassured.RestAssured.given;

  import io.restassured.RestAssured;
  import io.restassured.config.HttpClientConfig;
  import io.restassured.path.json.JsonPath;
  import io.restassured.response.Response;
  import io.restassured.specification.RequestSpecification;
  import junit.framework.TestCase;
  import org.apache.http.client.HttpClient;
  import org.apache.http.impl.client.SystemDefaultHttpClient;
  import org.apache.http.params.HttpConnectionParams;
  import org.apache.http.params.HttpParams;
  import org.eclipse.jetty.http.HttpStatus;
  import org.junit.Ignore;
  import org.junit.Test;
  import org.junit.BeforeClass;

  import org.hamcrest.BaseMatcher;
  import org.hamcrest.Description;

  import java.util.Base64;
  import java.util.Map;

  public class FullJourneyTest {

      // Custom regex matcher for RestAssured Framework
      public static classB RegexMatcher extends BaseMatcher<Object> {
          private final String regex;
          public   RegexMatcher (String regex){ this.regex = regex; }
          @Override public boolean matches (Object o){ return ((String)o).matches(regex); }
          @Override public void describeTo (Description description){
              description.appendText("matches regex=");
          }
          public staticB RegexMatcher  matches(String regex){ return newB RegexMatcher (regex); }
      }

       public static classG Base64Matcher extends BaseMatcher<Object> {
          public Base64Matcher(){}
          @Override public boolean matches (Object o){
              try {
                  Base64.getDecoder().decode((String)o);
                  return true;
              }catch (Exception e){
                  return false;
              }
          }

          @Override public void describeTo (Description description){
              description.appendText("can be parsed as Base64");
          }

          public static Base64Matcher isBase64Encoded(){
              return new Base64Matcher();
          }
      }
      private static final String AUTH_HEADER_VALUE = "Bearer " + ServerConfig.apiKey;

      protected static RequestSpecification setupCommonHeaders() {
          return given().header("Authorization", AUTH_HEADER_VALUE)
                        .header("Accept"       , "application/json")
                        .header("content-type" , "application/json;charset=utf-8")
          .log().all();
      }


      final String
          NAME="COMMUNITY_1", SYMBOL="SY1";

      Response response;
      @BeforeClass
      public static void setup() {
          RestAssured.port     = ServerConfig.serverPort;
          RestAssured.basePath = "/";
          RestAssured.baseURI  = "http://localhost";

          HttpClientConfig clientConfig = RestAssured.config().getHttpClientConfig();
          clientConfig = clientConfig.httpClientFactory(new HttpClientConfig.HttpClientFactory() {
              @Override
              public HttpClient createHttpClient() {
                  HttpClient rv =  new SystemDefaultHttpClient();
                  HttpParams httpParams = rv.getParams();
                  //  Wait 5s max for a connection
                  HttpConnectionParams.setConnectionTimeout(httpParams, 5 * 1000);
                  // Default session is 60s
                  HttpConnectionParams.setSoTimeout(httpParams, 60 * 1000);
                  return rv;
              }
          });
          // This is necessary to ensure, that the client is reused.
          clientConfig = clientConfig.reuseHttpClientInstance();
          RestAssured.config = RestAssured.config().httpClient(clientConfig);
      }

      @Test
      public void A010_PutNewCommunityAndNewUserForPendingToMineCommunity() {
          String jsonBody =
              "{ " +
                  " \"name\": \""+NAME+"\", " +
                  " \"symbol\": \"" + SYMBOL + "\","
              "}";
          response = setupCommonHeaders().body(jsonBody).when(). post("/Route/To/REST/API/01") ;
          System.out.println(response.body().prettyPrint());
          response.then()
              /*  get sure JSON serializer do not include extra (maybe sensitive) infO  */
              .body("size()",   is(5)                           )
              .body("id"    ,   not(isEmptyString())            )
              .body("pubkey",   not(isEmptyString())            )
              .body("pubkey",   RegexMatcher   .matches("^{65}$") )
              .body("pubkey",   Base64Matcher.isBase64Encoded() )
              .body("name"  ,   equalTo(NAME)                   )
              .body("symbol",   equalTo(SYMBOL)                 )
              .statusCode(HttpStatus.ACCEPTED_202);
          String   NEW_ID = response.getBody().jsonPath().get("id") ;

          // Next related test to execute synchronously after fetching NEW_ID
          String jsonBody =
              "{ " +
                  B*" \"FK_ID\": \""+NEW_ID+"\", " +*
                  ...
              "}";

          response = setupCommonHeaders().body(jsonBody).when(). post("/Route/To/REST/API/02") ;
          ...
      }
  }
[[}]]

● BDD Serenity Testing [[{qa.testing.bdd,01_PM.TODO]]
@[https://serenity-bdd.github.io/theserenitybook/latest/index.html]

- Serenity BDD is an open source library that aims to make the idea of living
  documentation a reality.

- write cleaner and more maintainable automated acceptance and
  regression tests faster. Serenity also uses the test results to
  produce illustrated, narrative reports that document and describe
  what your application does and how it works. Serenity tells you not
  only what tests have been executed, but more importantly, what
  requirements have been tested.

- One key advantage of using Serenity BDD is that you do not have to invest time
  in building and maintaining your own automation framework.

- Serenity BDD provides strong support for different types of automated acceptance testing, including:
  - Rich built-in support for web testing with Selenium.
  - REST API testing with RestAssured.
  - Highly readable, maintainable and scalable automated testing with the
    Screenplay pattern.

- The aim of Serenity is to make it easy to quickly write well-structured,
  maintainable automated acceptance criteria, using your favourite BDD or
  conventional testing library. You can work with Behaviour-Driven-Development
  tools like Cucumber or JBehave, or simply use JUnit. You can integrate with
  requirements stored in an external source (such as JIRA or any other test cases
  management tool), or just use a simple directory-based approach to organise
  your requirements.

<hr/>
● JBehave
- framework for Behaviour-Driven Development (BDD). BDD is an
  evolution of test-driven development (TDD) and acceptance-test driven
  design, and is intended to make these practices more accessible and
  intuitive to newcomers and experts alike. It shifts the vocabulary
  from being test-based to behaviour-based, and positions itself as a
  design philosophy.

  STEP 1) Write story
    Scenario: A trader is alerted of status
    Given a stock and a threshold of 15.0
    When stock is traded at 5.0
    Then the alert status should be OFF
    When stock is traded at 16.0
    Then the alert status should be ON

  STEP 2) Map to java

  STEP 3) Configure Stories

  STEP 4) Run Stories
[[}]]

● JAVA FlameGraph Profiling [[{JVM,java_lang.profiling.101,java_lang.profiling.flamegraph,architecture.real-time]]

UPDATE (Aug 2015): See the Java in Flames Netflix Tech Blog post for the latest
and best method for Java flame graphs, which uses Linux perf_events to show Java
and system code paths together.
https://netflixtechblog.com/java-in-flames-e763b3d32166

(I also describe the steps in Java CPU Flame Graphs.
 https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html#Java)


Java in Flames

Java mixed-mode flame graphs (complete visualization of CPU usage)
 have just been made possible by new JDK option: -XX:+PreserveFramePointer. (max +3%CPU increase)

It allows to identify all profiling issues, including
THOSE THAT ARE HIDDEN FROM OTHER PROFILERS by showing CPU consumption
by a Java process both in user and kernel-level.

eg.:
- kernel code peaks performing TCP sends, (which often leads to a TCP receive
  while handling the send) with Java code responsible.
- Java code compilation vs code cache vs other system libraries,
  differences in kernel code execution for different frameworks, ...

 All of these CPU consumers were invisible to other Java profilers, which only
 focus on the execution of Java methods.


Flame Graph Interpretation:

- y axis is stack depth
- x axis spans the sample population.
- Each rectangle is a stack frame (a function), where the width shows how often
  it was present in the profile.
  ordering from left to right is unimportant (stacks are sorted alphabetically).

- You can read the flame graph from the bottom up, which follows the flow of
  code from parent to child functions.
- Another way is top down, as the top edge shows the function running on CPU,
  and beneath it is its ancestry.

- KEY-POINT: Focus on the widest functions, which were present in the profile the most.

- There have historically been two types of profilers used on Java:  [[02_doc_has.comparative]]
  - System profilers: eg: Linux perf_events, profiling system code paths, including libjvm
                         internals, GC, and the kernel, but not Java methods.
  - JVM profilers: such as hprof, Lightweight Java Profiler (LJP), and commercial profilers.
    showing Java methods, but not system code paths.

- KEY-POINT: In 2009, Linux perf_events added JIT symbol support, so that symbols from
  language virtual machines like the JVM could be inspected.
  To use it:
  - application creates a /tmp/perf-PID.map text file, which lists symbol addresses
    (in hex), sizes, and symbol names.
    Java can create this file using perf-map-agent, an open source JVMTI agent written by
    Johannes Rudolph. The first version needed to be attached on Java startup, but
    Johannes enhanced it to attach later on demand and take a symbol dump.
    That way, we only load it if we need it for a profile.
  - perf_events looks for this file by default and, if found, uses it for symbol translations.

  NOTE: symbols can change slightly during the profile session (around 30-60 secs) a symbol
      dump may include stale symbols.

Fixing Frame Pointers
- For many years the gcc compiler has reused the frame pointer as a compiler optimization,
  breaking stack traces. Some applications compile with the gcc option -fno-omit-frame-pointer,
  to preserve this type of stack walking, however, the JVM had no equivalent option.

PRESETUP:
 - linux perf
 - JDK
 - perf-map-agent: JVMTI agent providing Java symbol translation for perf_events
   $ apt-get install cmake
   $ export JAVA_HOME=/path-to-your-new-jdk8
   $ git clone --depth=1 https://github.com/jrudolph/perf-map-agent
   $ cd perf-map-agent
   $ cmake .
   $ make

 - perl software generating flamegraphs:
   $ git clone --depth=1 https://github.com/brendangregg/FlameGraph

USSAGE:
- taking a 30-second profile at 99 Hertz (samples per second) of all processes
  then caching symbols for Java PID 1690, then generating a flame graph:

  $ sudo perf record -F 99 -a -g -- sleep 30
  $ java -cp \
    attach-main.jar:$JAVA_HOME/lib/tools.jar \             <- attach-main.jar from perf-map-agent
    net.virtualvoid.perf.AttachOnce 1690                   <- run as same user as java
  $ sudo chown root /tmp/perf-*.map
  $ sudo perf script | stackcollapse-perf.pl | \
  $     flamegraph.pl --color=java --hash > flamegraph.svg


- With jmaps: automating symbol files.

  $ sudo perf record -F 99 -a -g -- sleep 30; sudo jmaps
  $ sudo perf script | stackcollapse-perf.pl | \
  $     flamegraph.pl --color=java --hash > flamegraph.svg

   jmaps creates symbol files for all Java processes, with root ownership.

  REMEMBER: lean up the /tmp symbol files when you no longer need them!

- EG: Generate By-Process Flame Graphs:

  $ sudo perf record -F 99 -a -g -- sleep 30; sudo jmaps
  $ sudo perf script -f comm,pid,tid,cpu,time,event,ip,sym,dso,trace | \
        stackcollapse-perf.pl --pid | \
        flamegraph.pl --color=java --hash > flamegraph.svg

  stackcollapse-perf.pl output formats each stack as a single line, and is great
  food for grep/sed/awk.

- Missing Frames:
  you’ll notice that many Java frames (methods) are missing compared to jstack(1)
  command line tool. This is because of inlining, combined with this type of profiling
  (frame pointer based) which only captures the final executed code.
  This hasn’t been much of a problem so far: even when many frames are missing, enough
  remain that we can figure out what’s going on.
   We’ve also experimented with reducing the amount of inlining, eg, using
   -XX:InlineSmallCode=500, to increase the number of frames in the profile. In some     [[performance]]
  cases this even improves performance slightly, as the final compiled instruction size
  is reduced, fitting better into the processor caches (we confirmed this using
  perf_events separately).


[[$div}]]
[[$div}]]


