#  Apropos:
- Visit next Web site for a great experience:
  https://earizon.github.io/txt_world_domination/viewer.html?payload=../JAVA/gradle.txt

- If you want to contribute to the great gistory of this
  document you can take the next flight to:
@[https://www.github.com/earizon/JAVA]
  Your commits and pull-request will be immortalized
  in the Pantheon of the Unicode Gods.
────────────────────────────────────────────────────────────────────────────────

[[{devops.gradle]]

# Gradle Summary [[{devops.gradle.101,devops.gradle.troubleshooting]]
  • TLDR

                           ● SETUP TASKS
    $ gradle init            <- Initializes a new Gradle build.
    $ gradle wrapper         <- Generates Gradle wrapper files.

                           ● BUILD TASKS
    $ gradle build           <- Compile package
                                -x {{test}} : Exclude test task:
                                --offline   : offline mode (prevent network access/updates)
    $ gradle clean           <- Clear build directory

    $ gradle assembleRelease <- Build Android Package (APK) in release mode

                           ● HELP TASKS
    $ gradle tasks           <- List main tasks
                                $ gradle tasks --all  <- List all tasks
    $ buildEnvironment       <- show all buildscript dependencies declared in root project 'JAVA'.
    $ components             <- show components produced by root project 'JAVA'.
    $ dependencies           <- show all deps. declared in root project 'JAVA'.
    $ dependencyInsight      <- show insight into a specific dep. in root project 'JAVA'.
    $ dependentComponents    <- show dependent components of components in root project 'JAVA'. [incubating]
    $ help                   <- show a help message.
                                $ gradle help --task $task for detailed info
    $ model                  <- show configuration model of root project 'JAVA'. [incubating]
    $ projects               <- show sub-projects of root project     'JAVA'.
    $ properties             <- show properties of root project       'JAVA'.
    $ tasks                  <- show tasks runnable from root project 'JAVA'.


# GRADLE CORE MODEL  [[{gradle.101.core_model]]                    [[{02_doc_has.diagram.UML.ER]]
                                                      ┌>1┃Plugin┃ packaging way to distribute
                                                      v           standard,community&custom tasks.
  ┃ Settings        ┃                                 1
  ┃(settings.gradle)┃ ┌···>1┃ProjectDescriptor┃   ┌·>0+┃Task┃(Task==Unit of work!) N <···········> 1┃Plugin┃
    ^           ◆     v      └───┬──1────────┘    ·  ┌───┴────────────────────────┐              ┌────┴───────────────────┐
    │           │     1          ·  ^             ·   Inputs  : Optional (values,files/dirs)     Java/Android/C++/... plugins
    │           └>1+┃Project┃    ·  └>1+┃Build┃1<·┘  Actions : Optional (compile, cp, ... )      "feed" gradle with Task-types
  ┌─┴──────────────────────────┐ ·   (build.gradle) Outputs : Optional (files/dirs)              for projects of different nature.
  + root-project always present  ·         ^        *action customization:
  + Other projects can be added  ·         ·         Task.doLast  {}
    in hierarchy of build deps.  ·         ·         Task.doFirst {}
    with include*(...)           ·         ·         eg: standard-lifecycle-task don't even have any actions.
  (settings.gradle is optional   ·         ·             It simply aggregate multiple tasks together.
   for single project builds)    · ┌───────┴─────────────────────────────┐
  - Place to register build      ·  A new Build instances executes build.gradle
    life-cycle (script) hooks    ·  to configure and wire build-tasks
  - A new gradle build creates   ·  and, based on their dependencies, create
    a single "Settings" instance ·  the directed acyclic build graph (DAGs)
    that executes this file to   ·  used to determine tasks run-order.
    further execute itself.      ·  - the task code can be defined through:
                                 ·    · plugins
                                 ·    · custom build scripts (WARN: Delegate complex logic to plugins)
                                 ·
 ┌|ProjectDescriptor|────────────┴───────────────┐
 │                                               │ ┌ GRADLE FIXED BUILD PHASES ────────────────────────┐
 ├─ READONLY PROPS                               │ │ · INITIALIZATION: setup projects included in build│
 │ · gradle        instance reference            │ │ · CONFIGURATION : Configures DAG (on every build) │
 │ · PluginManager instance reference            │ │ · EXECUTION     : Runs tasks                      │
 │ · Settings      instance injected from:       │ └───────────────────────────────────────────────────┘
 │                 1) ${PROJCT}/gradle.properties│  WARN: [[{02_doc_has.comparative]]
 │                 2) ~/.gradle/gradle.properties│  Gradle’s build phases != Maven’s phases [[}]]
 │                                               │
 ├─ READ/WRITE PROPS  ────────────────────────   │
 │ · startParameter: StartParameter (param.set used to invoke this gradle instance)
 │ · buildCache    : BuildCacheConfiguration     │
 │ · extensions    : ExtensionContainer          │
 │ · plugins       : PluginContainer (applied to this object)
 │                    not deprecated but prefer equivalent methods
 │                    in ProjectDescriptor | PluginAware.getPluginManager()
 │ · rootProject   : ProjectDescriptor (of build)│
 │ · rootDir       : File (of project)           │
 │ · settingsDir   : File (of build)             │
 │                                               │
 ├─ Methods: ────────────────────────            │
 │                                               │
 │  Method	               Description           │
 │  ------------------    -----------            │
 │  apply(closure)        Applies 0+ plugins|scripts
 │  apply(options)        Applies plugin|script using options (injected as map)
 │  apply(action)         Applies 0+ plugins|scripts
 │  buildCache(action)    Configures build cache │
 │  findProject(prjDir)   Returns project with given 'prjDir'
 │  findProject(path)     Returns project with given 'path'
 │  include(projectPaths) Adds projects to build (Build Project Dependency Tree)
 │  includeBuild(rootPrj) Includes build at path │
 │  includeBuild(rootPrj, configuration)         │
 │  includeFlat(prjNames) Adds project list to build
 │  project(projectDir)   Returns project with given prj.dir.
 │  project(path)         Returns the project with given path.
 │                                               │
 │ (REF: https://docs.gradle.org/5.6/dsl/org.gradle.api.initialization.Settings.html)
 └───────────────────────────────────────────────┘              [[02_doc_has.diagram.UML.ER}]]

# GRADLE CORE MODEL CUSTOMIZATION:
  - Custom properties can be added to projects and tasks.

  - Custom models to represent  concepts (other than tasks, files and dependencies)
    can be created adding the concept of "source-sets" to a build.
    [[{KEYPOINT]]: Appropriate modeling of a build process can greatly improve
    a build's ease of use and its efficiency. [[}]]

    Logic must be delegated to plugins and custom models  [[{qa.BEST_PATTERN]]
    (vs build scripts)                                    [[}]]

• Project Coordinates: Help to univocally identify a project and its versions.
  'group   :module     :version' <- gradle terminology [[{02_doc_has.comparative]]
  'groupId :artifactId :version' <- maven  terminology [[}]]

  [[gradle.101.core_model}]]


REF: @[https://docs.gradle.org/current/userguide/gradle_wrapper.html]

  $ gradle init \                       <·· ● STEP 1) SET UP A NEW GRADLE PROJECT
    --type java-application                <· Java|Scala|Kotlin|C++|Android|Swift apps|libs
  ^                       ^
  └┬──────────────────────┘
  Next layout will added to FS:         [[{02_doc_has.diagram]]

  ├ ┃build.gradle┃ (== Makefile like script) ·······························
  │ · plugins {
  │ ·     id 'java'        // <- Apply java plugin: build Java    support
  │ ·     id 'application' // <- Apply app. plugin: build cli app support
  │ · }
  │ ·
  │ · repositories {
  │ ·     jcenter()        // Use jcenter (Maven/Ivy/file repos
  │ · }                                    can be declared)
  │ ·
  │ · application {
  │ ·     mainClassName = 'tmp.App'
  │ · }
  │ ·
  │ · task customTask01 {  // <·· run ··> $ gradle -q customTask01
  │ ·     doLast {
  │ ·         println 'Hello Baeldung!'
  │ ·     }
  │ · }
  │ ·
  │ · dependencies {
  │ ·     implementation     'com.google.guava:guava:28.0-jre'
  │ ·     testImplementation 'junit:junit:4.12'
  │ ·     └──────┬─────────┘
  │ · }    compileOnly    : used only at compile time (eg. transpiler).
  │ └····· implementation : dep. used for compilation and runtime
  │                         (most dependencies fall in this category).
  │                         (supersedes deprecated 'compile' that failed to distinguish
  │                          among deps. impacting the public API of a Java lib)
  │        runtimeOnly    : (supersedes runtime), used only at runtime (vs compilation)
  │                         (e.g.: JDBC drivers needed only at runtime)
  │        api, compileOnlyApi : dependencies required for compiling both
  │                         the module and transitive module dependencies
  │        (plus testCompileOnly, testImplementation, testRuntimeOnly)
  │
  ├ ┃settings.gradle┃ (◆───> 1+│Project│1 <··> 1│ProjectDescriptor
  │  rootProject.name = 'demo'
  │  include  project1 project2
  │  (docs.gradle.org/5.6/dsl/org.gradle.api.initialization.Settings.html)
  │
  ├─ gradle/                            <····  generated dir. TO BE ADDED TO GIT
  │  └ wrapper/
  │    ├─ gradle-wrapper.jar            <···· code for downloading a given gradle version
  │    └─ gradle-wrapper.properties
  ├ gradlew      <┬·························· [[{KEYPOINT]]  once in place, replace OS
  ├ gradlew.bat  <┘                           system-wide gradle (with random version) with
  ├                                           $ ./gradlew build  (gradlew.bat in Windows)
  └ src                                       - This ensures reproducible builds using a
    ├ main/java/project01/App.java              well defined version of gradle. [[}]]
    │ └ resources
    └ test/java/project01/AppTest.java
      └ resources                       [[02_doc_has.diagram}]]

  $ gradle wrapper             \        <···· STEP 2) SETUP GRADLE VERSION (Repeat to update Version)
      --gradle-version 5.1     \              <· optional (def.: local installed one)
      --distribution-type bin  \              <· optional (def.: 'bin' -no sample code,docs,...-)
      --gradle-distribution-url ...           <· optional. Ej https://services.gradle.org/distributions/gradle-5.5.1-bin.zip
      --gradle-distribution-sha256-sum        <· optional. Check SHA-256 sum
    └──────────────┬─────────────────┘
    ./gradle/wrapper/gradle-wrapper.properties  is updated with the information
    about the Gradle distribution:

  $ git add \                           <···· STEP 3) Commit gradle artifacts to git.
    build.gradle gradle* settings.gradle &&
    git commit -m "Adding graddle support"
                                              STEP 4) Test setup:
  $ ./gradlew run                       <···· Test running App::main @App.java
  $ ./gradlew build                     <···· Test build (bundling jar)
  $ ./gradlew build --scan              <···· Publish a build-scan
  ...
  Publishing build scan...
  https://gradle.com/s/5u4w3gxeurtd2    <···· Browse link to explore tasks executed, dependencies
  ^                                           downloaded,...
  Click the link and explore which tasks where executed,
  which dependencies where downloaded and many more details!

[[devops.gradle.101}]]

# Configuring projects with "gradle.properties" [[{gradle.properties]]
  REF: https://dev.to/jmfayard/configuring-gradle-with-gradle-properties-211k

  NOTE: 'gradle.propeties' is NOT created by default during '$ gradle init ...'
  '$ gradle refreshVersions' can be used to generate an initial one
  with depedencies versions and available updates looking similar to:
  ┌─ gradle.properties ─────────────────
  │ version.org.jetbrains.kotlin=1.3.31
  │ ##              #  available=1.3.4
  │ ...
  └─────────────────────────────────────

   gradle.properties is just a normal java key=value properties file that different
   plugins and graddle components will interpret or ignore in different ways.
   It can be used to:
   - you custom build/project settings
   - Customize Gradle components runtime behaviour.
   - Customize Kotlin/Android/Java/... builds.

   You should not add a setting to gradle.propeties before                 [[{KEY-POINT]]
   having read the docs to understand what any (collateral/direct) effect. [[}]]

   Properties can also be defined in build.gradle or as parameters on
   the command line but 'gradle.properties' helps keeping them separate.

· Example ussage:
  - Android project build customization using properties:

    ┌─ gradle.properties ───────
    │ # Common Android settings
    │ android.compileSdkVersion=28
    │ android.applicationId=com.example
    │ android.targetSdkVersion=28
    │ android.minSdkVersion=21
    │ android.versionCode=2
    │ android.versionName=1.2
    └─^─────────────────────────
      └··· Reuse in build.gradle like ···┐
    ┌─ build.gradle ───────────          ·
    │ android {                          v
    │   compileSdkVersion  ┌─────────────┴─────────────────────────┐
    │        rootProject
    │                     .findProperty("android.compileSdkVersion") as Integer
    │   defaultConfig {
    │     applicationId    findProperty("android.applicationId"    )
    │     targetSdkVersion findProperty("android.targetSdkVersion" ) as Integer
    │     minSdkVersion    findProperty("android.minSdkVersion"    ) as Integer
    │     versionName      findProperty("android.versionName"      )
    │     versionCode      findProperty("android.minSdkVersion"    ) as Integer
    │   }
    │ }
    └───────────────────────────

• 'gradle.properties' to customize Gradle build-runtime settings:

   org.gradle.caching=true                    [[{gradle.performance]]
   org.gradle.parallel=true                   [[}]]
   org.gradle.caching.debug=false
   org.gradle.configureondemand=false
   org.gradle.daemon.idletimeout= 10800000
   org.gradle.console=auto
   # org.gradle.java.home=(path to JDK home)
   # org.gradle.warning.mode=(all,none,summary)
   # org.gradle.workers.max=(max # of worker processes)
   # org.gradle.priority=(low,normal)
   org.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m \
                      -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
   https://docs.gradle.org/current/userguide/build_environment.html#sec:configuring_jvm_memory

• 'gradle.properties' to customize the Gradle Project object itself:

   org.gradle.project.rootProject=....
   org.gradle.project.settingsDir=....
   ....
  [[gradle.properties}]]

# Example Multi-module Deployer: [[{gradle.multimodule,02_doc_has.code_snippet]]
@[https://github.com/FlamingTuri/multi-module-deployer]
  - library built to speed up deployment of microservice based applications.
  - build and run each application module.
  - configure deployment dependencies between modules
    by just creating and running a simple application.

  INSTALLATION)
    1) Add to your build.gradle the following function:
       def downloadLibFromUrl(String libSaveDir, String libName, String libUrl) {
           def folder = new File(libSaveDir)
           if (!folder.exists()) { folder.mkdirs() }
           def file = new File("$libSaveDir/$libName")
           if (!file.exists()) { ant.get(src: libUrl, dest: file) }
           getDependencies().add('compile', fileTree(dir: libSaveDir, include: libName))
       }

    2) Add the following code to your dependencies declaration:
       dependencies {
           /* ... */
           def libSaveDir = "${System.properties['user.home']}/.gradle/caches/modules-2/files-2.1"
           def version = '1.1.1'
           def libName = "multi-module-deployer-${version}.jar"
           def url = "https://github.com/FlamingTuri/multi-module-deployer/releases/download/v$version/$libName"
           downloadLibFromUrl(libSaveDir, libName, url)
       }

  USAGE EXAMPLE)

  import multi.module.deployer.MultiModuleDeployer;
  import multi.module.deployer.moduleconfig.ModuleConfig;
  import multi.module.deployer.moduleconfig.ModuleConfigFactory;

  public class App {
    public static void main(String[] args) {
        final MultiModuleDeployer multiModuleDeployer = new MultiModuleDeployer();
        String linCmd, winCmd;
        // ─ Add 1st config to deployment list ──────────
        linCmd = "linux   commands to deploy first module";
        winCmd = "windows commands to deploy first module";
        final ModuleConfig firstModuleConfig =
           ModuleConfigFactory.httpModuleConfig(
              linCmd, winCmd, 8080, "localhost", "/api/...");
        multiModuleDeployer.add(firstModuleConfig);

        // ─ Add 2nd config to deployment list ──────────
        // (started ONLY AFTER first one "finishes")
        linCmd = "linux   commands to deploy second module";
        winCmd = "windows commands to deploy second module";
        final ModuleConfig secondModuleConfig =
           ModuleConfigFactory.httpModuleConfig(
              linCmd, winCmd, 3000, "localhost", "/api/...");

        multiModuleDeployer.add(secondModuleConfig);

        // ──────────────────────────────────────────────
        multiModuleDeployer.deploy(); // deploys the modules
    }
  }
[[gradle.multimodule}]]

• What's New [[{01_PM.WHATS_NEW]]
- Gradle v6:
@[https://www.infoq.com/news/2020/01/gradle-releases-version-6/]
[[}]]

# Building Java & JVM projects [[{gradle.java_projects]]

  JAVA LIBRARY PLUGIN:

  build.gradle      (simplest build applying Java Lib Plugin)

  plugins {
      id 'java-library'
  }

  java {
    withJavadocJar()
    withSourcesJar()
    toolchain {
        languageVersion = JavaLanguageVersion.of(11)
    }
  }

  tasks.register('uberJar', Jar) {      <···· Create FAT / Uber jar.
    archiveClassifier = 'uber'
    from sourceSets.main.output
    dependsOn configurations.runtimeClasspath
    from {
      configurations.runtimeClasspath.findAll {
        it.name.endsWith('jar') }.collect { zipTree(it) }
    }
  }

  jar {                      <····· customize MANIFEST.MF in jar/war/ear
    manifest {
       attributes(
         "Implementation-Title": "Gradle",
         "Implementation-Version": archiveVersion)
    }
  }

  version = '1.2.1'

  TASK PROVIDED:
  TASK           | INPUT                 | ACTION                      | OUTPUT
  ---------------+-----------------------+-----------------------------+-----------
  compileJava    | src/main/java         |                             | build/???
  *1             | compilation Classpath |                             |
                 | ^^^^^^^^^^^^^^^^^^^^^ |                             |
                 | + sourceSetCompileOnly   (configuration)            |
                 | + sourceSetImplementation(configuration)            |
  ---------------+-----------------------+-----------------------------+-----------
  compileTestJava| src/test/java         |                             | build/???
  JUnit 3/4/5    | source set actually   |                             |
  ---------------+-----------------------+-----------------------------+-----------
  test           |                       | runs test in src/test/java  |
  ---------------+-----------------------+-----------------------------+-----------
  jar            | compiled classes      | package into                |
                 | src/main/resources    | <project>-<version>.jar     |
                 | source set actually   |                             |
  ---------------+-----------------------+-----------------------------+-----------
  javadoc        | src/main/java         |                             | Javadoc
  ---------------+-----------------------+-----------------------------+-----------

  The Java Library Plugin also integrates the above tasks into the
  standard Base Plugin lifecycle tasks:
  - jar is attached to assemble [1]
  - test is attached to check

  SOURCE SETS tie toghether:
  - source file type/roles (app code, unit test, ...) with location in FS.
  - compilation classpath, including any required dependencies
    (via Gradle configurations)
  - where the compiled class files are placed

  *1: Java Library Plugin creates a compilation task for every source set defined.

   - Most language plugins, Java included, automatically create a source
     set called main, which is used for the project's production code.


• Customizing default source-sets (Not recomended except for compatibility
  with old projects). At build.gradle added something like:
  sourceSets {
      main { java { srcDirs = ['src'] } } <··· Alt 1: Complete override defaults
      main { java { srcDir 'src'      } } <··· Alt 2: Add to defaults.
      test { java { srcDirs = ['test'] } }     common convention in Gradle:
  }                                            - setting a property   replaces values.
                                               - corresponding method appends values.

• Changing compiler options
compileJava {
    options.incremental = true   <··· incremental compilation
    options.fork = true          <··· use new JVM process for compiler
    options.release = 7          <··· Defaults to that of that of JVM of Gradle.
    ...                          <··· compiler verbosity, enable/disable debug output in byte code,
}                                     location for annotation processors used by compiler ...
                                      compiler can find .

• when should you define a custom source set?
  - source need to be compiled with a unique classpath
  - Generate classes handled differently from the main/test ones
  - Form a natural part of the project

• Java properties files and reproducible builds
  WriteProperties TASK:
  - fixes well-known problem:
    - Properties.store() -standard Java API-
      produces a unique file every time breaking usefulness
      of incremental builds.
  - WriteProperties fix the problem.

• Reusing shared Manifests:
  (merging manifests into a single new one is also possible)
  ext.sharedManifest = manifest {              <···· Create standalone (shared) Manifest
      attributes("Implementation-Title": "Gradle",
                 "Implementation-Version": version)
  }
  tasks.register('fooJar', Jar) {
      manifest = project.manifest {
          from sharedManifest                 <······ Reuse in jar build
      }
  }


• ex: use Asciidoc  in Javadoc comments.   [[{qa.documentation.asciidoc]]
  NOTE: This configuration is optional (but elegant)
  · configurations { asciidoclet }
  · dependencies {
  ·     asciidoclet 'org.asciidoctor:asciidoclet:1.+'
  · }
  ·
  · tasks.register('configureJavadoc') {
  ·   doLast {                          <········· Customize Task.Action with doLast
  ·     javadoc {
  ·       options.doclet = 'org.asciidoctor.Asciidoclet'
  ·       options.docletpath = configurations.asciidoclet.files.toList()
  ·     }
  ·   }
  · }
  ·
  · javadoc {
  ·   dependsOn configureJavadoc
  · }

  [[}]]

• The Java Library Plugin (on top of Java Plugin) allows gradle to
distinguish between two different types of dependencies: those
requiring the library at compile and those that are also required to
compile the consumer and have task to create the POM file.


• War Plugin (on top of Java Plugin) adds an extra packaging step to:
  - Copies static resources from src/main/webapp into root of WAR
  - Copies the compiled production classes into a WEB-INF/classes
  - Copies lib.dependencies into WEB-INF/lib subdirectory

[[gradle.java_projects}]]

# TODO/Non-classified [[{01_PM.TODO]]
• CUSTOMIZING THE WRAPPER
  The built-in wrapper task exposes numerous options to customize the runtime behavior.
  -   build.gradle.kts:
      build.tasks.wrapper {
        distributionType = Wrapper.DistributionType.ALL
      }

  - HTTP Basic Authentication (  WARN : use only with TLS connections)
    alt 1: ENV.VARS:
    systemProp.gradle.wrapperUser=username
    systemProp.gradle.wrapperPassword=password
    alt 2: gradle/wrapper/gradle-wrapper.properties
    distributionUrl=https://username:password@somehost/path/to/gradle-distribution.zip

  -  Verifying download
    @gradle/wrapper/gradle-wrapper.properties:
    distributionSha256Sum=371cb9fbebbe9880d147f59bab36d61eee122854ef8c9ee1ecf12b82368bcf10

• https://scans.gradle.com/ [[{troubleshooting]]
   Build Scan™: shareable record of a build providing insights into
   what happened and why. You can create a Build Scan at
   scans.gradle.com for the Gradle and Maven build tools for free.
    Publishing a Build Scan to scans.gradle.com transmits information
   about your Gradle and Maven builds and their environment to Gradle's
   servers. The information is only accessible via a randomly generated
   link, printed at the end of the build. You can delete the
   Build Scan when you are finished. [[}]]

• Groovy DSL:
• https://dev.to/jmfayard/how-kotlin-makes-editing-your-gradle-build-less-frustrating-232l
• Kotlin DSL:

• https://docs.gradle.org/current/userguide/core_dependency_management.html#dependency_management_in_gradle
[[01_PM.TODO}]]

• https://docs.gradle.org/current/userguide/java_testing.html#java_testing


• https://kotlinlang.org/docs/ksp-overview.html
  Kotlin Symbol Processing (KSP) API allows to create
  lightweight compiler plugins.
  Compared to kapt, annotation processors run up to x2 times faster.

• JAVA PLUGIN Tasks: ???
  Kotlin PLUGIN Tasks ???
  assemble, check, build, jar, javadoc, clean ,...
  Gradle command to list available plugins???
  Gradle command to list tasks in a plugin???

• Further reading:
  https://docs.gradle.org/current/userguide/building_java_projects.html
  https://docs.gradle.org/current/userguide/declaring_repositories.html#sub:flat_dir_resolver
  https://docs.gradle.org/current/userguide/dynamic_versions.html#sub:declaring_dependency_with_changing_version
  https://docs.gradle.org/current/userguide/dynamic_versions.html#sub:declaring_dependency_with_dynamic_version
  https://docs.gradle.org/current/userguide/declaring_dependencies.html#sub:project_dependencies
  https://docs.gradle.org/current/userguide/dependency_constraints.html#dependency-constraints
  https://docs.gradle.org/current/userguide/composite_builds.html#composite_builds
  https://docs.gradle.org/current/userguide/declaring_repositories.html#sub:maven_local
[[devops.gradle}]]

# Dependencies among (multimodule) Subprojects
  https://docs.gradle.org/current/userguide/declaring_dependencies_between_subprojects.html

  • buildSrc/
  ├ settings.gradle <··· + include 'api', 'shared', 'services:person-service'
  │
  ├ shared
  │ ├── src
  │ │   └──...
  │ └── build.gradle
  ├ api
  │ ├ src
  │ │ └──...
  │ └ build.gradle
  │   ^^^^^^^^^^^^        ┌─··············  special form of execution dependency causing
  │ + dependencies {   ┌──┴──┐              the other project to be built first and adding
  │ +   implementation project(':shared')   the jar to the classpath.
  │ + }                                     $ gradle :api:compile # build "shared" then "api"
  │
  ├ services
  │ └─ person-service    <·· has dependency on shared,api
  │    ├─ build.gradle
  │    .. ^^^^^^^^^^^^
  │     + dependencies {
  │     +   implementation project(':shared')
  │     +   implementation project(':api')
  │     + }

