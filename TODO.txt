* https://dev.java/

Get Started                Go Deeper                    Resources
-------------------------  -------------------------    ------------------------------
Getting Started with Java  Lambda Expressions           Java News
Java Language Basics       The Stream API               Official Java Podcast and More
Downloading Java           The Collections Framework    JavaOne Conference 2022


* https://inside.java/

* https://www.infoq.com/presentations/openjdk-containers/

Something important, on top you have a custom OpenJDK 13 with one 
module. OpenJDK 13 from the build that are done by Oracle, it weighs 
50 MBs. Then at the bottom, the same custom runtime image, one 
module, using the Debian OpenJDK 13 build, it weighs nearly 500 MBs. 
About 10 times the size for the same exact custom runtime. Why? 
Because the Debian one is embedding the debug symbols. If you're 
concerned about the size of your Java Runtime layer, you need to 
clearly remove those symbols. In Java 13, we have added these new 
capabilities to JLink strip-native-debug-symbols that you can use to 
basically remove those symbols. If you do that, you will go from 499 
MBs to 51 MBs. That's something that you should clearly look at.
...
There are these new trends, where it's a good idea to run rootless 
containers. Basically, we want to give as less privilege to the 
container as we can. It's a bit tricky to do. Docker, they have a 
rootless mode. The last time I checked it was still in experimental 
features. If you want to do pure rootless containers, you need to use 
Podman. For that Podman, use cgroups v2, which is not something new. 
Cgroups v2 has been added in the Linux kernel six years ago. It was 
not enabled by default. It's now enabled by default on Fedora. Fedora 
is the first major distribution that enables cgroups v2 support by 
default. With that, you can easily do rootless container. On the JDK 
side, you need JDK 15. JDK 15, we had support for cgroups v2. I put a 
little asterisk, remember the first slide the disclaimer slide that 
basically says that it's there, the day is there, but that's really 
JID. JDK 15 would support cgroups v2. If cgroups v2 are not supported 
on the platform, it will automatically fall back to cgroups v1 as 
today.

* Remove java_lang.debugging, ...

* Replace with troubleshooting.debugging, ...

## Create zipped summary of java.util.concurrent:  [[{concurrency.101,PM.TODO]]

  - Inmmutable Objects are faster and thread-safe:
   https://docs.oracle.com/javase/tutorial/essential/concurrency/immutable.html

  - Concurrency Classes Video
@[https://www.youtube.com/watch?v=8yD0hHAz3cs&list=PLw8RQJQ8K1ySGcb3ZP66peK4Za0LKf728&index=4]

  - java.util.concurrent.locks.ReentrantLock vs synchronized { ... } block

  - example stack trace (extracted from Vert.X):
    at jdk.internal.misc.Unsafe.park(Native Method)
    at java.util.concurrent.locks.LockSupport.park
    at java.util.concurrent.LinkedTransferQueue.awaitMatch
    at java.util.concurrent.LinkedTransferQueue.xfer
    at java.util.concurrent.LinkedTransferQueue.take
    at java.util.concurrent.ThreadPoolExecutor.getTask
    at java.util.concurrent.ThreadPoolExecutor.runWorker
    at java.util.concurrent.ThreadPoolExecutor$Worker.run
[[}]]



[[{java,01_PM.TODO]]

## [[{]]
  @[https://www.programcreek.com/2013/03/hashmap-vs-treemap-vs-hashtable-vs-linkedhashmap/]
  @[https://www.programcreek.com/2015/12/top-10-java-utility-classes/]      @ma
  @[https://www.programcreek.com/2013/09/top-9-questions-for-java-map/]
  @[https://www.programcreek.com/2013/09/top-10-questions-for-java-collections/]
  @[https://www.programcreek.com/2013/09/top-8-diagrams-for-understanding-java/]
  @[https://www.programcreek.com/2013/09/top-10-faqs-of-java-strings/]
  @[https://www.programcreek.com/2013/09/top-10-methods-for-java-arrays/]
  @[https://www.programcreek.com/2013/09/top-10-websites-for-advanced-level-java-developers/]
  @[https://www.programcreek.com/2013/08/top-books-for-advanced-level-java-developers/]
[[}]]


## https://blog.frankel.ch/jvm-security/4/ [[{jvm,security}]]


## SPARTA (anti-malware)
  - Aimed at preventing malware from appearing in an app store.
  - provides an information-flow type-checker customized to Android
    but can also be applied to other domains.
  @[https://checkerframework.org/sparta/]
    The paper "Collaborative verification of information flow for a
    high-assurance app store" appeared in CCS 2014.

## Java 9 to 13 in a Nutshell!!!: @ma
  https://bentolor.github.io/java9to13/#/_preview_features_preview_12

## Guava Collections [[{data_structures,qa.data]]
- Widely used Google Core Libraries for Java 6+.
  with as advanced collection types
  https://www.baeldung.com/guava-sets?
[[}]]
######################################################
## Is Java 17 a Glass Half Full?
  https://www.infoq.com/news/2021/07/java-17-glass/

  Overall, the features present in Java 17 are broadly following the
  expected pattern, as InfoQ previously reported on. The unfortunate
  truth is that of the major projects that have been the major areas of
  JDK development in the last three years (Loom, Valhalla, Amber and
  Panama) - none are complete as of the release of Java 17.

  This means that the feature set of Java 17 will be more modest than
  many developers hoped.

  For example, The Algebraic Data Types feature (comprising Records and
  Sealed Types) is complete as of 17. This is a major step forward in
  terms of data modeling and enhancing the OO capabilities of the Java
  language. However, the Pattern Matching feature which complements and
  builds upon algebraic data types is only present as a Preview feature
  in Java 17 (and only in a fairly rudimentary form at that).

## Architecture of a Geospatial Application with Java
  https://www.baeldung.com/java-geospatial-applications

## Eclipse Memory Analyzer Open Source Project
  https://www.eclipse.org/mat/
  - fast and feature-rich Java heap analyzer that helps you find
    memory leaks and reduce memory consumption.
  - Use the Memory Analyzer to analyze productive heap dumps with
    hundreds of millions of objects, quickly calculate the retained sizes
    of objects, see who is preventing the Garbage Collector from
    collecting objects, run a report to automatically extract leak
    suspects.

## Java 17, the Next Long-Term Support Release, is Now Available
  https://www.infoq.com/news/2021/09/java17-released/

## JDK Mission Control 8.1.0 Released!
  https://foojay.io/today/jdk-mission-control-8-1-0-released/

## https://github.com/topics/snippets-collection

## Scala 3 Overhauls Language for Better Developer Experience
  https://www.infoq.com/news/2021/06/scala-3-overhaul/

 1) Another significant difference between ReentrantLock and the
synchronized keyword is fairness. The synchronized keyword doesn't
support fairness. Any thread can acquire lock once released, no
preference can be specified, on the other hand, you can make
ReentrantLock fair by specifying fairness property while creating an
instance of ReentrantLock. Fairness property provides a lock to the
longest waiting thread, in case of contention.

 2) The second difference between synchronized and Reentrant lock is
tryLock() method. ReentrantLock provides a convenient tryLock()
method, which acquires lock only if its available or not held by any
other thread. This reduces the blocking of thread waiting for lock-in
Java applications.

 3) One more worth noting the difference between ReentrantLock and
synchronized keyword in Java is, the ability to interrupt Thread
while waiting for Lock. In case of a synchronized keyword, a thread
can be blocked waiting for a lock, for an indefinite period of time
and there was no way to control that. ReentrantLock provides a method
called lockInterruptibly(), which can be used to interrupt thread
when it is waiting for lock. Similarly, tryLock() with timeout can be
used to timeout if the lock is not available in certain time period. [[}]]

## JAVA DONT's:
  https://dzone.com/articles/we-should-write-java-code-differently?edition=598293#

## Complete how to write files in Guava

## aborted compilation of a multi-module (like AbsisParentPom)  [[{maven]]
  can be restarted (from the last failed module) with '--resume-from' option like:
$ $ mvn --resume-from=com.myCompany.myModule:MyArtifact \
$   $ clean install -P myProfile -DskipTests=true            [[}]]


## Java Erasure
  Type Erasure is a technique employed the Java compiler to support the use of Generics.
@[https://developer.ibm.com/recipes/tutorials/java-language-type-erasure/]

## High Perf Persistence
  https://www.reddit.com/r/linux/comments/ajkfs0/github_trimstraythepracticallinuxhardeningguide/

## Kryo serialization lib [[{]]
  - Object graph serialization library:
   @[https://github.com/EsotericSoftware/kryo]
    Kryo is a fast and efficient binary object graph serialization
    framework for Java. The goals of the project are high speed, low
    size, and an easy to use API. The project is useful any time objects
    need to be persisted, whether to a file, database, or over the
    network.

     Kryo can also perform automatic deep and shallow copying/cloning.
    This is direct copying from object to object, not object to bytes to
    object.  [[}]]

## java_lang.101,qa.billion_dolar_mistake:
  Optional (1.8+)

  Optional<Integer> highestNumber
      = itemList.stream()
        .reduce((int1, int2) ->               ← Reduce returns Optional
                (int1 > int2) ? int1 : int2);

  Optional Evolution
  https://dzone.com/articles/java-optional-api-evolution?edition=699391

[[{01_PM.TODO]]
# Secomp JVM Integration
@[https://docs.sonarqube.org/latest/requirements/requirements/]
https://en.wikipedia.org/wiki/Seccomp
http://people.apache.org/~rmuir/es-coverage/post-query-refactoring/org.elasticsearch.bootstrap/Seccomp.java.html
seccomp filter  Non-portable linux/amd64 only security protection, preventing non
                authorized calls to kernel.


By default, Elasticsearch uses seccomp filter. On most distribution
this feature is activated in the kernel. If  distributions without
this featur you have to explicitly deactivate this security layer
by updating sonar.search.javaAdditionalOpts in
$SONARQUBEHOME/conf/sonar.properties_:

sonar.search.javaAdditionalOpts=-Dbootstrap.system_call_filter=false

You can check if seccomp is available on your kernel with:

$ grep SECCOMP /boot/config-$(uname -r)

If your kernel has seccomp, you will see:

CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
CONFIG_SECCOMP_FILTER=y
CONFIG_SECCOMP=y
[[}]]

## Clean JSON Notes.
## @[https://www.baeldung.com/java-json-binding-api]

## Compact monitoring notes: jcmd, Visual Recorder,  CRaSH shell
  Eclipse Mem.Analizer

## https://eclipse-ee4j.github.io/jakartaee-tutorial/ @ma
  https://www.uml-diagrams.org/java-ejb-uml-profile-diagram-example.html
  https://www.uml-diagrams.org/java-ejb-state-machine-diagram-example.html

## https://www.uml-diagrms.org/java-7-api-uml-package-diagram-example.html
  https://www.uml-diagrams.org/examples/java-servlet-25-api-package-diagram-example.html
  https://www.uml-diagrams.org/examples/java-servlet-30-api-package-diagram-example.html
  https://www.uml-diagrams.org/java-thread-uml-state-machine-diagram-example.html

## https://www.uml-diagrams.org/tomcat-server-uml-composite-structure-diagram-example.html
  https://www.uml-diagrams.org/web-application-clusters-uml-deployment-diagram-example.html


## https://github.com/google/re2j
  linear time regular expression matching in Java
  If you use regular expression patterns with a high degree of
  alternation, your code may run faster with RE2/J. In the worst case,
  the java.util.regex matcher may run forever, or exceed the available
  stack space and fail; this will never happen with RE2/J.

## weekly Inside Java Newscast:
  https://www.youtube.com/playlist?list=PLX8CzqL3ArzX8ZzPNjBgji7rznFFiOr58

## Who-is-Who:
  https://nipafx.dev/nicolai-parlog/
  Java developer advocate at Oracle

## plans for Java in 2022.
  https://www.youtube.com/watch?v=4Y3LijiBxRA
  focus on the four main Java projects:
  · https://openjdk.java.net/projects/amber
  · https://openjdk.java.net/projects/loom
  · https://openjdk.java.net/projects/panama/
  · https://openjdk.java.net/projects/valhalla
    The goal of Project Valhalla is to explore and incubate advanced
    Java VM and Language feature candidates such as:
    · Value types
    · Generic specialization
    · Enhanced volatiles
    · and possibly othe related topics, such as reified generics

## https://openjdk.java.net/jeps/0


## Testing add notes:    @ma
  • mockito,
    https://github.com/mockito/mockito/wiki/Features-And-Motivations
    "...Mockito has very slim API, almost no time is needed to start mocking.
      There is only one kind of mock, there is only one way of creating
      mocks. Just remember that stubbing goes before execution,
      verifications of interactions go afterwards... "

## Add notes on JUnit parameterized tests.
  https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests

## Apple has open-sourced GCGC, a tool for Java Garbage Collector (GC)
  logs visualization based on Python 3 and pandas.
  https://www.infoq.com/news/2022/01/apple-gcgc-java/
  https://github.com/apple/GCGC

## GCGC uses a Jupyter notebook to analyze and visualize GC log files. A
  notebook is provided for the analysis and it generates plots and
  tables from collected GC information.

## https://theboreddev.com/understanding-java-streams @ma?

## Data Oriented Programming in Java
   https://www.infoq.com/articles/data-oriented-programming-java/

## cache2k - Java Caching –https://cache2k.org/

## Java 18
  https://www.infoq.com/news/2022/03/java18-released/
## Failsafe 3.2 Released with New Resilience Policies
  https://www.infoq.com/news/2022/02/failsafe-resilience-3/

## 101: Six Features From Java 12 to 17 to Get Excited About!
  https://www.infoq.com/articles/six-features-jdk12-to-jdk17/

## log4j, Log4Shell: A new fix, details of active attacks, and risk mitigation recommendations
  https://www.helpnetsecurity.com/2021/12/15/log4shell-mitigation/

## E-book Collection Page | Red Hat DeveloperLot of books about quarkus!!!
  https://developers.redhat.com/e-books
## Introducing the KivaKit Framework
  https://www.infoq.com/articles/introducing-kivakit/

## concurrency, 101? Measuring ForkJoinPool Parallelism
  https://www.javaspecialists.eu/archive/Issue297-Measuring-ForkJoinPool-Parallelism.html

## Why SOLID principles are still the foundation for modern software architecture [[{]]
https://stackoverflow.blog/2021/11/01/why-solid-principles-are-still-the-foundation-for-modern-software-architecture/ 
  - Single responsibility principle Original definition: “There should
    never be more than one reason for a class to change.”If you write a
    class with many concerns, or “reasons to change”, then you need
    to change the same code whenever any of those concerns has to change.
    This increases the likelihood that a change to one feature will
    accidentally break a different feature.
  - Open-closed principle Original definition: “Software entities should
    be open for extension, but closed for modification.”This is part of
    the design of languages like Java—you can create classes and extend
    them (by creating a subclass), but you can’t modify the original
    class. One reason for making things “open for extension” is to
    limit the dependency on the author of the class—if you need a
    change to the class, you’d constantly need to ask the original
    author to change it for you, or you’d need to dive into it to
    change it yourself. What’s more, the class would start to
    incorporate many different concerns, which breaks the single
    responsibility principle.The reason for closing classes for
    modification is that we may not trust any and all downstream
    consumers to understand all the “private” code we use to get our
    feature working, and we want to protect it from unskilled hands

  - Liskov substitution principle Original definition:
   “If S is a subtype of T, then objects of type T may be replaced with
    objects of type S without altering any of the desirable properties of the program.”
  - Interface segregation principle Original Definition:
    “Many client-specific interfaces are better than one
    general-purpose interface.”In OO, you can think of this as
    providing a “view” into your class. Rather than giving your full
    implementation to all your clients, you create interfaces on top of
    them with just the methods relevant to that client, and ask your
    clients to use those interfaces. 
  - Dependency inversion principle Original definition:
   “Depend upon abstractions, not concretions.”In OO, this means
    that clients should depend on interfaces rather than concrete classes
    as much as possible. This ensures that code is relying on the
    smallest possible surface area—in fact, it doesn’t depend on code
    at all, just a contract defining how that code should behave. As with
    other principles, this reduces the risk of a breakage in one place
    causing breakages elsewhere accidentally.
[[}]]

## persistence: No More MultipleBagFetchException Thanks to Multiset Nested Collections SQL and jOOQ.
  https://blog.jooq.org/no-more-multiplebagfetchexception-thanks-to-multiset-nested-collections/
______________________________
## Troubleshooting Java Applications with Eclipse Jifa [[{]]
  https://www.infoq.com/news/2022/02/eclipse-jifa/ 
The analytic engine currently has two parts: the Heap Dump Analysis
service based on Eclipse Memory Analyzer (MAT) and the GC Log
Analysis service which supports the G1, Parallel GC, Serial GC, CMS
and ZGC garbage collection algorithms. The GC Log Analysis Service
can process logs from Java 8 and 11, while support for Java 17 is
under development

Eclipse Jifa’s heap dump analysis, based on Eclipse MAT, provides
detailed documentation about analyzing heap dumps

Vue 2.0 and Vert.x are used for the frontend and backend, respectively.

There are several ways to deploy Eclipse Jifa: only one worker, one
master and several workers or the Kubernetes model.

[[}]]

## Azul Launches Java Cloud Compiler
  https://www.infoq.com/news/2022/02/azul-cloud-compiler/ 
  Azul Intelligence Cloud introduces a third option that bridges the
  benefits of JIT (peak performance) with the benefits of AOT (fast
  startup time). As teams often run the same code across many systems,
  the JRE communicates with an organization’s shared JIT server so
  that each JRE does not need to do the same observation and
  optimization cycle. The cloud compiler can then also perform deeper
  analysis, using CPU resources that are isolated from the running
  application. Resulting applications can reach peak performance in the
  network time needed to transfer this information and run with the
  improved code. In tests described at QCon, the time to peak
  performance was faster and throughput was between 25 to 100%
  faster.
https://www.baeldung.com/java-weekly-425


## Java, quarkus + neo4j,...:
  https://www.infoq.com/news/2021/10/java-news-roundup-oct04-2021/

## Security: Detect and block Log4j exploitation attempts with CrowdSec
  The OOSS & collaborative IPS
https://crowdsec.net/blog/detect-block-log4j-exploitation-attempts/

## https://github.com/JakeWharton/RxRelay
  Subjects and Relays allow to bridge non-Rx APIs into Rx easily, and without
  the worry of accidentally triggering a terminal state.

## JAVA Example Architecute:
  In the case of Java, we may add new libraries (with all its
  transitive dependencies) for each of the “microservicilitities”,
  such as Resiliency4J for resiliency, Jaeger for tracing, or
  Micrometer for monitoring.

## JAVA JDK version, JVM version, javac -source/-target/-release/ ... related info: [[{java,01_PM.TODO}]]
  https://stackoverflow.com/questions/43102787/what-is-the-release-flag-in-the-java-9-compiler

# JVM Journey to Cloud-native [[{cloud.101,01_PM.TODO]]
(by BellSoft)
```
## JDK 9 : Compact Strings, HTTP/2 client.
## JDK 10: Docker awareness.
## JDK 11: ZGC.
## JDK 12: Return unused memory, Shenandoah GC.
## JDK 13: Uncommit unused memory for ZGC.
## JDK 14: JFR Event Streaming.
## JDK 15: Reimplement Datagram Socker API, Hidden Classes.
## JDK 16: Elastic metaspace, Alpine Linux port
```
[[}]]

# JPA Summary [[{01_PM.TODO]]
## Java: Migrating from JPA 2.x to 3.0
  https://thorben-janssen.com/migrating-jpa-2-x-to-3-0/?ck_subscriber_id=935368299
## https://www.javacodegeeks.com/2015/02/jpa-tutorial.html
[[}]]


# JDeps [[{devops.101,java_lang.debugging,01_PM.TODO]]
## JDeps: dependency analysis tool for Java bytecode (class files and JARs).
@[https://nipafx.dev/jdeps-tutorial-analyze-java-project-dependencies/]

$ $ jdeps sh-2.6.3.jar       ←  -verbose:class will list dependencies between classes
  sh-2.6.3.jar → java.base      (vs aggregating them to package level)
  sh-2.6.3.jar → java.datatransfer
  sh-2.6.3.jar → java.desktop
  sh-2.6.3.jar → java.logging
  sh-2.6.3.jar → java.prefs
  sh-2.6.3.jar → java.sql
  sh-2.6.3.jar → java.xml
  sh-2.6.3.jar → not found
     edu.udo.sh → com.beust.jcommander  not found
     edu.udo.sh → edu.udo.sh.data       sh-2.6.3.jar
     edu.udo.sh → edu.udo.sh.gui        sh-2.6.3.jar
     edu.udo.sh → edu.udo.sh.gui.util   sh-2.6.3.jar
     edu.udo.sh → edu.udo.sh.util       sh-2.6.3.jar
     edu.udo.sh → java.io               java.base
     edu.udo.sh → java.lang             java.base
     edu.udo.sh → javax.swing           java.desktop
     edu.udo.sh → org.slf4j             not found
  [... truncated many more package dependencies ...]
[[}]]



# Quarkus (GraalVM) Framework [[{jvm.graalvm,devops.k8s,scalability.jvm,01_PM.TODO]]
@[https://quarkus.io/guides/]
@[https://quarkus.io/guides/kogito-guide]
@[https://marketplace.visualstudio.com/items?itemName=kie-group.vscode-extension-kogito-bundle]
..
@[https://www.infoq.com/news/2019/03/redhat-release-quarkus]

Extracted from "Hibernate with Panache" by Emmanuel Bernard.
""" Quarkus is Supersonic Subatomic Java. extremely fast with low memory footprint""".
@[https://quarkus.io/guides/hibernate-orm-panache-guide]
Hibernate ORM is the de facto JPA implementation and offers you the full
breadth of an Object Relational Mapper. It makes complex mappings possible,
but it does not make simple and common mappings trivial. Hibernate ORM with
Panache focuses on making your entities trivial and fun to write in Quarkus.

  Panache example:
  @Entity
  public class Person extends PanacheEntity {
      public String    name;
      public LocalDate birth;
      public Status    status;

      public static Person      findByName(String name) {
        return find("name", name).firstResult();
      }
      public static List<Person> findAlive           () {
        return list("status", Status.Alive);
      }
      public static void       deleteStefs           () {
        delete("name", "Stef");
      }
  }
[[}]]

# AsyncAPI.org [[{async/reactive.101,standards.openapi,qa.*,01_PM.TODO]]
@[https://www.asyncapi.org/]
- Building the future of event-driven architectures.
- Open source tools to easily build and maintain your event-driven architecture.
- All powered by the AsyncAPI specification, the industry standard for defining
  asynchronous APIs.
[[}]]

# Sign/Verify JARs [[{devops,security.cryptography,01_PM.TODO]]
@[https://docs.oracle.com/javase/9/tools/jarsigner.htm]

$ $ jarsigner file01.jar $keystore_alias   ← Sign Jar. use flag -sigalg ... to set sign. algorithm

$ $ jarsigner -verify file01.jar           ← Verify jar
[[}]]

# Guava VisibleForTesting[qa] [[{data_structures.*,concurrency.*,qa.testing,01_PM.TODO]]
[[{data_structures.*,concurrency.*,qa.testing,01_PM.TODO]]
REF: @[https://stackoverflow.com/questions/6913325/annotation-to-make-a-private-method-public-only-for-test-classes]
@[https://guava.dev/releases/19.0/api/docs/com/google/common/annotations/VisibleForTesting.html]
[[}]]

# Javalin: Kiss Kotlin/Java web framework [[{01_PM.radar]]
@[https://javalin.io]
- Inspired by Javascript KOA.js framework

- Ex: Declare server and API in the same place
  | import io.javalin.ApiBuilder.*;
  | import io.javalin.Javalin;
  |
  | Javalin app = Javalin.create(config -> {
  |     config.defaultContentType = "application/json";
  |     config.addStaticFiles("/public");
  |     config.enableCorsForAllOrigins();
  | }).routes(() -> {
  |     path("users", () -> {
  |         get(UserController::getAll);
  |         post(UserController::create);
  |         path(":user-id", () -> {
  |             get(UserController::getOne);
  |             patch(UserController::update);
  |             delete(UserController::delete);
  |         });
  |         ws("events", userController::webSocketEvents);
  |     });
  | }).start(port);
[[}]]

[[{]]scalability.native_code" >
# JNR(JNI/UNIX friendly)
( used by Netty and others...)
-@[https://github.com/jnr/jnr-ffi]
   load native libraries without writing JNI code by hand, or using tools such as SWIG.
-@[https://github.com/jnr/jnr-unixsocket]
   jnr-unixsocket: UNIX domain sockets (AF_UNIX) for Java
-@[https://github.com/jnr/jnr-enxio]
   Java Native Runtime Enhanced X-platform I/O
-@[https://github.com/jnr/jnr-x86asm]
   Pure java x86 and x86_64 assembler
-@[https://github.com/jnr/jnr-a64asm]
  AArch64 assembler for the Java Native Runtime
-@[https://github.com/jnr/jnr-process]
  A ProcessBuilder look-alike based entirely on native POSIX APIs
-...
[[}]]


# JAAS [[{security.aaa,01_PM.TODO]]
@[https://en.wikipedia.org/wiki/Java_Authentication_and_Authorization_Service]
- In UNIX, by default we authenticate against /etc/passwd, but the
  (P)lugable (A)uthentication (M)odule (PAM), allows to check against other sources.
  JAAS is similar to PAM for Java, allowing to offer a common AAA front-end to
  file/ddbb/LDAP/... backends.
[[}]]

# Eclipse Microprofile [[{standards.jee.microprofile,01_PM.TODO]]
@[https://dzone.com/articles/microprofile-5-things-you-need-to-know]

- launched at JavaOne 2016 to address the shortcomings in the Enterprise Java microservices space.

- MicroProfile specifies a collection of Java EE APIs and technologies which together
  form a core baseline microservice that aims to deliver application portability across multiple runtimes.

- MicroProfile 1.0 spec includes a subset of the 30+ Java Enterprise specifications:
  - JAX-RS 2.0 for RESTful endpoints
  - CDI 1.1 for extensions and dependency injection
  - JSON-P 1.0 for processing JSON messages.

- MicroProfile 1.2  (September 2017) include:
  - Configuration 1.1
  - Fault Tolerance
  - JWT
  - Metrics
  - Health Check

- MicroProfile 2.0 (Future). It is expected it will align all APIs to Java EE 8.

- vendors runtime support:
  - WebSphere Liberty IBM
  - TomEE from Tomitribe
  - Payara
  - RedHat's WildFly Swarm
  - KumuluzEE.

- Community support:
  - London Java Community
  - SOUJava
  - ...

- key code sample consists of four microservices and a front-end application.
  Vendor            |     JAR |      StartUp
                    | size/Mb | Time in Secs
  WebSphere Liberty |   35    |            7
  WildFly Swarm     |   65    |            6
  Payara            |   33    |            5
  TomEE             |   35    |            3
  KumuluzEE*        |   11    |            2

- CDI-Centric Programming Model
  - Context and Dependency Injection specification
  - Two of its most powerful features are interceptors and observers.
    - Interceptors perform cross-cutting tasks that are orthogonal to business logic
      such as auditing, logging, and security
    - The baked-in event notification model implements the observer
      pattern to provide a powerful and lightweight event notification system
      that can be leveraged system-wide.
[[}]]

# JavaPoet [[{java_lang,01_PM.TODO]]
@[https://github.com/square/javapoet]
- Library/API for generating .java source files.
- Useful for things like:
  - annotation processing
  - interacting with metadata files (e.g., database schemas, protocol formats).
  - Transpiler (language A → Java Src ).
    keeping a single source of truth for the metadata .
[[}]]

# R2DBC API [[{async/reactive,persistence.sql,01_PM.TODO]]
@[https://www.infoq.com/news/2018/10/springone-r2dbc]
## Project initiated by Pivotal to provide an async/reactive alternative to JDBC.

  WARN : Since Spring Data R2dbc evolved very quickly, thre are plenty
         of breaking changes introduced since Spring 5.2 and Spring
         Data R2dbc 1.2.
         breaking changes (Compared to Spring Data R2dbc 1.1):
           · Spring Data R2dbc 1.1 DatabaseClient was split into two parts.
             a simple new DatabaseClient is part of Spring framework, as an
             alternative of Jdbc.
           · Another part of the old DatabaseClient is reorganized into a new
             class R2dbcEntityTemplate which acts as the role of JdbcTemplate.
  Ex:
  connectionFactory.create()
    .flatMapMany ( conn ->
       conn.createStatement ( "SELECT value FROM test" )
          .execute()
            .flatMap (result ->
              result.map(( row, metadata -→ row.get("value"))))

  spring:
    r2dbc:                 ← ... (src/main/resources/)application.yml  example:
      username: XXX
      password: XXX
      url: r2dbc:postgresql://...:5432/ddbb_app01
      pool:
        max-create-connection-time: 5s
        initial-size: 5        ←················ probably much lower numbers than
        max-size: 10                             those used for JDBC.
[[}]]

# Nailgun [[{devops.containarization,scalability.jvm,01_PM.TODO]]
- Nailgun is a client, protocol, and server for running Java programs
  from the command line without incurring the JVM startup overhead.

- Programs run in the server (which is implemented in Java), and are
  triggered by the client (written in C), which handles all I/O.

@[https://github.com/facebook/nailgun]
[[}]]

# 9 Profiling tools [[{java_lang.profiling,01_PM.TODO]]
@[https://blog.idrsolutions.com/2014/06/java-performance-tuning-tools/]
[[}]]

# A Year with Java 11 in Production!  [[{01_PM.TODO]]
@[https://www.infoq.com/presentations/java-11-production-story/?itm_source=www.oficina24x7.com]
Andrzej Grzesik talks about Revolut’s experience in running Java 11
in production for over a year. He talks about the doubts they had,
some pain points and gains, as well as surprises that surprised them.
He discusses tools, alternative JVM languages, and some 3rd party
products.
[[}]]

# Aviam:Light Weight JVM [[{jvm,01_PM.TODO]]
https://readytalk.github.io/avian/  ("Embedded java")
Avian is a lightweight virtual machine and class library designed to
provide a useful subset of Java’s features, suitable for building
self-contained applications.

From Mike's blog: https://blog.plan99.net/kotlin-native-310ffac94af2
  | Enter Avian
  |
  |     “Avian is a lightweight virtual machine and class library
  |    designed to provide a useful subset of Java’s features, suitable
  |    for building self-contained applications.”
  |
  | So says the website. They aren’t joking. The example app demos
  | use of the native UI toolkit on Windows, MacOS X or Linux. It’s not
  | a trivial Hello World app at all, yet it’s a standalone
  | self-contained binary that clocks in at only one megabyte. In
  | contrast, “Hello World” in Go generates a binary that is 1.1mb in
  | size, despite doing much less.
  |
  | Avian can get these tiny sizes because it’s fully focused on
  | doing so: it implements optimisations and features the standard
  | HotSpot JVM lacks, like the use of LZMA compression and ProGuard to
  | strip the standard libraries. Yet it still provides a garbage
  | collector and a JIT compiler.
[[}]]

# R2DBC [[{persistence.sql,async/reactive,01_PM.radar]]
https://www.infoq.com/news/2018/10/springone-r2dbc
  Experimental Reactive Relational Database Connectivity Driver, R2DBC, Announced at SpringOne
[[}]]
# jEnv [[{devops,01_PM.TODO]]
@[http://www.jenv.be/]

 command line tool to help you forget how to set the JAVA_HOME environment variable:

  Configuration:
 $ jenv add /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home
   oracle64-1.6.0.39 added
 $ jenv add /Library/Java/JavaVirtualMachines/jdk17011.jdk/Contents/Home
   oracle64-1.7.0.11 added

  Ussage:
  List managed JDKs

  $ jenv versions
    system
    oracle64-1.6.0.39
    * oracle64-1.7.0.11 (set by /Users/hikage/.jenv/version)

  $ jenv global oracle64-1.6.0.39 Configure global version
  $ jenv local oracle64-1.6.0.39 Configure local version (per directory)
  $ jenv shell oracle64-1.6.0.39 Configure shell instance version
[[}]]

# SmallRye Mutiny [[{async/reactive.rxjava,async/reactive,doc_has.comparative,qa,01_PM.TODO]]
@[https://smallrye.io/smallrye-mutiny/]

## SmallRye Mutiny is a reactive programming library. Wait? Another one?  Yes!
## Mutiny is designed after having experienced many issues with other
  Reactive programming libraries and having seen many developers lost
  in an endless sequence of flatMap. Mutiny takes a different approach.
  First, Mutiny does not provide as many operators as the other famous
  libraries, focusing instead on the most used operators. Furthermore,
  Mutiny provides a more guided API, which avoids having classes with
  hundreds of methods that cause trouble for even the smartest IDE.
  Finally, Mutiny has built-in converters from and to other reactive
  programing libraries, so you can always pivot.
[[}]]



# Netty [[{async/reactive.io.network,doc_has.comparative,01_PM.radar,01_PM.backlog]]
- One Framework to rule them all by Norman Maurer
@[https://www.youtube.com/watch?v=DKJ0w30M0vg]
──────────────────────────────────────────────
# Apache MINA:Netty Alt.
## Apache MINA vs Netty: https://www.youtube.com/watch?v=A2pWsxPWJuc
## network application framework which helps users develop high
  performance and high scalability network applications easily. It provides an
  abstract event-driven asynchronous API over various transports such as TCP/IP
  and UDP/IP via Java NIO.

## Apache MINA is often called:
  - NIO framework library
  - client server framework library, or
  - a networking socket library

## Apache MINA comes with many subprojects :
  - Asyncweb : An HTTP server build on top of MINA asynchronous framework
  - FtpServer : A FTP server
  - SSHd : A Java library supporting the SSH protocol
  - Vysper : An XMPP server
[[}]]
[[}]]


# SwarmCache [[{scalability.distributed,scalability.cache,persistence.jpa,01_PM.low_code,01_PM.TODO]]
SwarmCache is a simple but effective distributed cache. It uses IP
multicast to efficiently communicate with any number of hosts on a
LAN. It is specifically designed for use by clustered,
database-driven web applications. Such applications typically have
many more read operations than write operations, which allows
SwarmCache to deliver the greatest performance gains. SwarmCache uses
JavaGroups internally to manage the membership and communications of
its distributed cache.

Wrappers have been written that allow SwarmCache to be used with the
Hibernate and JPOX persistence engines.
[[}]]

# bytes java [[{01_PM.backlog]]
@[https://github.com/patrickfav/bytes-java]
- utility library that makes it easy to create, parse, transform,
  validate and convert byte arrays in Java
[[}]]

# 3 NIO ways to read files [[{async/reactive.io,persistence.fs,01_PM.TODO]]
@[https://howtodoinjava.com/java7/nio/3-ways-to-read-files-using-java-nio/]
- read small file using ByteBuffer and RandomAccessFile
- FileChannel and ByteBuffer to read large files
- Example 3: Reading a file using memory-mapped files in Java
[[}]]

# JLink [[{devops.containarization,01_PM.TODO]]
@[https://docs.oracle.com/javase/9/tools/jlink.htm]
- You can use the jlink tool to assemble and optimize a set of modules
  and their dependencies into a custom runtime image

TODO:
@[https://medium.com/azulsystems/using-jlink-to-build-java-runtimes-for-non-modular-applications-9568c5e70ef4]
[[}]]

[[{java_lang.configuration,standards.JSR330,qa,doc_has.comparative,Spring,standards.JSR330]]
# Spring vs Google Guice
@[https://www.baeldung.com/guice-spring-dependency-injection]
────────────────────────
# Dependency injection
@[http://www.theserverside.com/feature/Spring-vs-Guice-The-Clash-of-the-IOC-Containers]
A: t's important to realize that Dagger was created after Guice, by one
of Guice's creators ("Crazy Bob" Lee) after his move to Square:
- Spring was originally released in October 2002.
- Google originally publicly released Guice in March 2007.
- JSR-330 formalized javax.inject annotations in October 2009,
  with heavy input from Google (Bob Lee), Spring, and other industry
  players.
- Square originally released Dagger 1 publicly in May 2013.
- Google originally released Dagger 2 publicly in April 2015.
- Square marked Dagger 1 as deprecated 10 days ago,
  on September 15, 2016.
# JSR-330: Provider<MyTargetBean>
@[http://javax-inject.github.io/javax-inject/]

FROM https://github.com/google/guice/wiki/JSR330
- JSR-330 standardizes annotations like @Inject and the Provider
  interfaces for Java platforms.
- It doesn't currently specify how applications are configured, so it
  has no analog to Guice's modules.
[[}]]

# Crypto.API(JCA) [{security.cryptography,security.secret_mng,security.aaa,01_PM.TODO]]
  WARN : Prefer a high level cryptographic API like Google Tink
         when possible.

  - See also:
    - Cryptography map:
    @[../General/cryptography_map.html]

    - Bounce Castle FIPS JCA provider
    @[https://www.bouncycastle.org/fips-java/BCFipsIn100.pdf]
    - Jipher (OpenSSL 3.0 based JCA provider)

    PKCS#11 Ref.guide : [TODO]
  @[https://docs.oracle.com/javase/7/docs/technotes/guides/security/p11guide.html]
  About PCKS#11: @[http:./../General/cryptography_map.html?topics=pkcs]
[[}]]

# Loading properties [[{java_lang.configuration,01_PM.low_code,01_PM.TODO]]
NOTE: Probably is better to use ENV.VARs to simplify compatibility
      with container deployments.

Config properties files located in .../src/main/resources/db_config.properties

InputStream is = getClass().getResurceAsStream("/db_config.properties");
Properties props = new Properties();
props.load(is);
is.close();

└ How to add comments to properties file:
  https://www.tutorialspoint.com/how-to-read-write-data-from-to-properties-file-in-java
[[}]]

# XML Stream parsing [[{persistence.xml,01_PM.TODO]]
[TODO]: Write summary of best XML libraries.
@[https://github.com/FasterXML/aalto-xml]
@[http://www.studytrails.com/java/xml/aalto/java-xml-aalto-stax-async-basic/]
@[https://docs.oracle.com/javase/tutorial/jaxp/stax/why.html]
@[https://gist.github.com/shvalb/38cc8f454ee84a2032d2b341a9b8aeae]
@[http://www.studytrails.com/java/xml/aalto/java-xml-aalto-introduction/]
@[https://gist.github.com/shvalb/38cc8f454ee84a2032d2b341a9b8aeae]
[[}]]

# CGLIB library [[{JVM.101,01_PM.TODO]]
- CGLIB library: Used for bytecode generation/method injection (Used by
  Spring Framework for example).
[[}]]

# Spring Reactor/Spring-Async [[{async/reactive.rxjava,async/reactive,doc_has.comparative,01_PM.TODO]]
@[https://ordina-jworks.github.io/reactive/2016/12/12/Reactive-Programming-Spring-Reactor.html]
@[https://spring.io/blog/2013/05/13/reactor-a-foundation-for-asynchronous-applications-on-the-jvm]
@[https://spring.io/guides/gs/async-method/]
## Q:"Why Reactor when there's already RxJava2?"
   - RxJava2 is java 6 while for Reactor the Spring team decided to go all in
     and focus only on Java 8. This means that you can make use of all the new
     and fancy Java 8 features.
     - If you are going to use Spring 5, Reactor might be the better option.
     - But if you are happy with your RxJava2, there is no direct need to migrate to Reactor."""

[[}]]

# Example JVM config.  [[{jvm,scalability.jvm,01_PM.TODO]]
Server version:        Apache Tomcat/8.x
Server built:          unknown
Server number:         8.0.x
OS Name:               Linux
OS Version:            3.10.0-1062.9.1.el7.x86_64
Architecture:          amd64
Java Home:             /ec/local/appserver/u000/app/java/jdk1.8.0_121-strong/jre
JVM Version:           1.8.0_121-b13
JVM Vendor:            Oracle Corporation
Command line argument: -Djava.util.logging.config.file=.../logging.properties
Command line argument: -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager
Command line argument: -Djdk.tls.ephemeralDHKeySize=2048
Command line argument: -Djava.protocol.handler.pkgs=org.apache.catalina.webresources
Command line argument: -Xms1536m
Command line argument: -Xmx1536m
Command line argument: -XX:MetaspaceSize=512m
Command line argument: -XX:MaxMetaspaceSize=512m
Command line argument: -XX:MaxDirectMemorySize=1G
Command line argument: -XX:+UseParallelGC
Command line argument: -XX:ParallelGCThreads=4
Command line argument: -XX:+UseParallelOldGC
Command line argument: -XX:LargePageSizeInBytes=4m
Command line argument: -XX:-BindGCTaskThreadsToCPUs
Command line argument: -Djava.awt.headless=true
Command line argument: -Dsun.net.inetaddr.ttl=60
Command line argument: -Dsun.net.inetaddr.negative.ttl=5
Command line argument: -Djava.io.tmpdir=/_tmp
Command line argument: -Dfile.encoding=UTF-8
Command line argument: -XX:ErrorFile=./logs/fatal_error/hs_err_pid%p.log
Command line argument: -Dcom.sun.management.jmxremote=true
Command line argument: -Dcom.sun.management.jmxremote.login.config=Tomcat
Command line argument: -Djava.security.auth.login.config=..../login.config
Command line argument: -Dcom.sun.management.jmxremote.access.file=.../jmxremote.access
Command line argument: -Dcom.sun.management.jmxremote.ssl=false
Command line argument: -Djava.rmi.server.hostname=tcsn0201.cc.cec.eu.int
Command line argument: -Dcom.sun.management.jmxremote.ssl.need.client.auth=false
Command line argument: -verbose:gc
Command line argument: -Xloggc:....API_TEST-gc.log
Command line argument: -XX:+PrintGCDetails
Command line argument: -XX:+PrintGCTimeStamps
Command line argument: -XX:+PrintTenuringDistribution
Command line argument: -XX:+PrintGCApplicationConcurrentTime
Command line argument: -XX:+PrintGCApplicationStoppedTime
Command line argument: -Djava.endorsed.dirs=.../tomcat8/endorsed
Command line argument: -Dcatalina.base=...
Command line argument: -Dcatalina.home=...
Command line argument: -Djava.io.tmpdir=.../temp
[[}]]

# mvn: Default Wrapper in 3.7 [[{DevOps.maven,01_PM.TODO]]
https://www.infoq.com/news/2020/04/maven-wrapper/
<hr/>
# Java on VC.Studio
https://devblogs.microsoft.com/java/java-on-visual-studio-code-update-february-2020/?WT.mc_id=social-reddit-marouill
[[}]]

# JHSDB [[{java_lang.debugging,monitoring.forensic,01_PM.TODO]]
https://docs.oracle.com/en/java/javase/12/tools/jhsdb.html
- You use the jhsdb tool to attach to a Java process or to a core dump
  from a crashed Java Virtual Machine (JVM).

- jhsdb is a Serviceability Agent (SA) tool. Serviceability Agent (SA)
  is a JDK component used to provide snapshot debugging, performance
  analysis and to get an in-depth understanding of the Hotspot JVM and
  the Java application executed by the Hotspot JVM.

- Even though native debuggers like gdb are available for examining the
  JVM, unlike jhsdb, these native debuggers do not have an inbuilt
  understanding of the data structures in Hotspot and hence, are not
  able to throw insights on the Java application being executed. jhsdb
  knows about the locations and address ranges of crucial components of
  the JVM like the Java heap, heap generations, regions, code cache,
  etc.
[[}]]

# Async Servlets 3.0+: [[{async/reactive.servlets,standards.jee.servlets,01_PM.TODO]]
https://www.infoworld.com/article/2077995/java-concurrency-asynchronous-processing-support-in-servlet-3-0.html
[[}]]

# Real-World Java 9 [[{async/reactive.101,java_lang.flow_api,java_lang.101,01_PM.TODO]]
@[https://www.infoq.com/presentations/java9-flow-stream-api/?utm_source=oficina24x7.com]

## Real-World Java 9:
  Trisha Gee shows via live coding how we can use the new Flow API to
  utilize Reactive Programming, how the improvements to the Streams API
  make it easier to control real-time streaming data and how the
  Collections convenience methods simplify code. She talks about other
  Java 9 features, including some of the additions to interfaces and
  changes to deprecation.
[[}]]

# Deplo WAR to k8s with JKube [[{devops.containarization,standards.jee.war,devops.k8s]]
@[https://developers.redhat.com/blog/2020/07/27/deploy-your-java-web-application-into-the-cloud-using-eclipse-jkube/]

## JKube Maven  converts war (dependent of a container) into cloud-native app.

  - pom.xml:
    <!-- ... -->
    <packaging>war</packaging>
    <!-- ... -->
    <properties>
      <maven.compiler.source>11</maven.compiler.source>
      <maven.compiler.target>11</maven.compiler.target>
      <failOnMissingWebXml>false</failOnMissingWebXml>  ← configure maven-war-plugin so
                                                          that it won't fail due
      <!-- ... -->                                        to a missing web.xml file.

      <jkube.enricher.jkube-service.type>NodePort</jkube.enricher.jkube-service.type>
      └────────────────────────────────┬────────────────────────────────────────────┘
      configure JKube to create service-resource manifest using NodePort as the spec.type.

    </properties>
    <dependencies>
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>${version.spring}</version>
      </dependency>
      <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>4.0.1</version>
        <scope>provided</scope>
      </dependency>
    </dependencies>
    <build>
      <plugins>
        <plugin>
          <groupId>org.eclipse.jkube</groupId>
          <artifactId>kubernetes-maven-plugin</artifactId> ← Alt: openshift-maven-plugin.
          <version>${version.jkube}</version>
        </plugin>
        <!-- ... -->
      </plugins>
    </build>

## example project contains three Java classes:
  └ ExampleInitializer: replaces standard WEB-INF/web.xml
    registering Spring's DispatcherServlet directly.

       final AnnotationConfigWebApplicationContext context
              = new AnnotationConfigWebApplicationContext();
       context.register(ExampleConfiguration.class);
       context.setServletContext(servletContext);
       final ServletRegistration.Dynamic dsr
              = servletContext.addServlet("dispatcher",
                new DispatcherServlet(context));
       dsr.setLoadOnStartup(1);
       dsr.addMapping("/");

  └ ExampleConfiguration: Spring-specific config enabling Spring MVC.

  └ ExampleResource: standard Spring @RestController.

- Deploy to Kubernetes:
    $ mvn clean package    ← generate war in target/
    $ mvn k8s:build        ← Build OCI image (webapp/example:latest)
                             using jkube/jkube-tomcat9-binary-s2i by default.
                             Alternatives like Jetty can be used
    $ mvn k8s:resource     ← create required cluster config resource manifests
    $ mvn k8s:apply        ← apply to (kubectl configured) cluster
    $ kubectl get pod      ← Verify that app is running
    $ mvn k8s:log          ← Retrieve app Logs
[[}]]


# Conclave [[{security.secret_mng,01_PM.TODO]]
https://medium.com/corda/conclave-beta-3-graalvm-mail-more-5038bd6d50da
Today we’re announcing a new beta release of Conclave, a platform
that makes it easy to use secure hardware enclaves with Java. You can
use enclaves to:
- Solve complex multi-party data problems, by running programs on a
  computer that prevents the hardware owner from seeing the
  calculations.
- Protect sensitive data from the cloud.
- Make your hosted service auditable and trustworthy.
- Upgrade privacy on distributed ledger platforms like Corda.
[[}]]

# Checkpointing outside the JVM [[{scalability.JVM,DevOps,01_PM.TODO]] #[jvm_app_checkpoint]
@[https://developers.redhat.com/blog/2020/10/15/checkpointing-java-from-outside-of-java/]
When OpenJDK‘s Java virtual machine (JVM) runs a Java application,
it loads a dozen or so classes before it starts the main class.

  STANDARD JVM START "WARM-UP"  vs   NEW APPROACH: WARM UP ONCE
  ----------------------------       ---------------------------
 - runs method several hundred       - 1st  run : WARM Up once and checkpoint
   times before optimizing it.       - Next runs: restore checkpointed app.
  cost of long startup times.          Start time seconds → millisecs!!!

  Checkpoint inside JVM HOW-TO:  [TODO]
@[https://www.jfokus.se/jfokus19-preso/Checkpointing-Java.pdf]

  Checkpoint Outside JVM HOW-TO:
        - Under the hood it uses Linux Checkpoint/Restore in Userspace (CRIU).
        @[https://www.criu.org/Main_Page]

  $ CONSOLE 1                              CONSOLE
  $ $ setsid java -XX:-UsePerfData \     $ $ sudo criu dump -t $pid \    ← stops and checkpoint
  $     -XX:+UseSerialGC Scooby          $    --shell-job -o dump.log      app

                                         $ $ sudo restore --shell-job \  ← Restore app
                                         $    -d -vvv -o restore.log
[[}]]

# Jrpip: Low code RMI [[{architecture.distributed,01_PM.low_code,01_PM.TODO]] #[jrpip]
  Let developers concentrate on logic vs network plumbing and TCP errors.
- Jrpip mplements remote interface method invocation which allows different
  Java processes to interact with one another.
- designed to increase developer efficiency by providing useful features, such as
  the ability to deploy in any servlet container, interface
  implementation that doesn’t require RemoteException and automatic
  retries with once-execute semantics.
- efficient binary protocol that is streamed, reducing memory
  consumption and garbage collector issues.

- See also notes on gRPC:
  @[./java_map.html?query=grpc]
  @[../WebTechnologies/map.html?topics=grpc&showSearchMenu=false]
[[}]]

# SMTP: Sending mail [[{messaging.mail.smtp,security.notifications]]
- Based on AWS guide @[https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-using-smtp-java.html]
  but applies to any standard SMTP e-mail server.

  - pom coordinates:
    <dependency>
        <groupId>com.sun.mail</groupId>
        <artifactId>javax.mail</artifactId>
        <version>1.6.2</version>
    </dependency>

  import java.util.Properties;

  import javax.mail.Message;
  import javax.mail.Session;
  import javax.mail.Transport;
  import javax.mail.internet.InternetAddress;
  import javax.mail.internet.MimeMessage;

  public class SendMailThroughSMTP {

      static final String
          FROM     = "...", // ← in AWS this address must be verified
          FROMNAME = "...", // ← Human readable FROM
          TO       = "...", // ← in AWS if sending account is still in the
                            //   sandbox this address must be  case-sensitive  verified.

          CONFIGSET = "ConfigSet", // ← Configuration Set name used for this message.
                                   //  If commented out remove header below.   *
          BODY      = String.join( "\n",
              "<h1>header</h1>", "html line2", "html line3", "..." ),
          SMTP_HOST = "email-smtp.us-west-2.amazonaws.com",
          SMTP_USERNAME = "..." , //  *
          SMTP_PASSWORD = "...";
          // SMTP_HOST REF: https://docs.aws.amazon.com/ses/latest/DeveloperGuide/regions.html#region-endpoints

      static final int PORT = 587; // The port you will connect to on the Amazon SES SMTP endpoint.


      public static void main(String[] args) throws Exception {
          final Properties props = System.getProperties();
          props.put("mail.smtp.port"           , PORT  );
          props.put("mail.transport.protocol"  , "smtp");
          props.put("mail.smtp.starttls.enable", "true");
          props.put("mail.smtp.auth"           , "true");
          Session session = Session.getDefaultInstance(props); // ← represents mail session

          final MimeMessage
              msg = new MimeMessage(session);    // ← Build message
              msg.setFrom(new InternetAddress(FROM,FROMNAME));
              msg.setRecipient(
                     Message.RecipientType.TO,
                     new InternetAddress(TO));
              msg.setSubject(MAIL_SUBJECT);
              msg.setContent(HTML_BODY,"text/html");
              msg.setHeader(                     // Remove if not using a configuration set
                     "X-SES-CONFIGURATION-SET",
                     CONFIGSET);

          final Transport transport =            // ← Create transport
              session.getTransport();

          try { // Send the message.
              transport.connect(SMTP_HOST, SMTP_USERNAME, SMTP_PASSWORD); // Connect to SMTP using username/pass
              transport.sendMessage(msg, msg.getAllRecipients());    // Send email.
          } catch (Exception ex) {
              // process and rethrow
          }
          finally { transport.close(); }
      }
  }

   *  : More info at
       https://docs.aws.amazon.com/ses/latest/DeveloperGuide/using-configuration-sets.html

   *  : AWS note, SMTP credentials are different to AWS credentials.
        SMTP username credential is 20-chars (letters and numbers)
[[}]]

# jFleet [[{scalability.persistence,persistence.jpa,persistence.sql,01_PM.TODO]]
@[https://github.com/jerolba/jfleet]
· JFleet is a Java library which persist in database large collections
  of Java POJOs as fast as possible, using the best available technique
  in each database provider, achieving it with alternate persistence
  methods from each JDBC driver implementation.

· Its goal is to store a large amount of information in a single table
  using available batch persistence techniques.

· despite being able to use JPA annotations to map Java objects to
  tables and columns, JFleet is not an ORM.
[[}]]

# JVM Anatomy [[{jvm.101,01_PM.TODO]]
https://shipilev.net/jvm-anatomy-park/
https://shipilev.net/jvm-anatomy-park/22-safepoint-polls/
[[}]]

# Java Class Library (JCL, rt.jar) [[{java_lang.101,01_PM.TODO]]
rt.jar contains the Java Class Library (JCL)
https://en.wikipedia.org/wiki/Java_Class_Library

- The Java Class Library (JCL) is a set of dynamically loadable
  libraries that Java applications can call at run time. Because the
  Java Platform is not dependent on a specific operating system,
  applications cannot rely on any of the platform-native libraries.
  Instead, the Java Platform provides a comprehensive set of standard
  class libraries, containing the functions common to modern operating
  systems.

- Java Class Library (JCL) is almost entirely written in Java, except
  for the parts that need direct access to the hardware and operating
  system (such as for I/O or bitmap graphics). The classes that give
  access to these functions commonly use Java Native Interface wrappers
  to access operating system APIs.

- The Java Class Library (rt.jar) is located in the default bootstrap
  classpath[1] and does not have to appear in the classpath declared
  for the application. The runtime uses the bootstrap class loader to
  find the JCL.

  The Java Module System (part of the Java 9 release) broke the
  monolithic "rt.jar" JAR file and modularized the JCL itself in
  several modules with specified dependencies.
[[}]]

# Java Threading resources [[{concurrency,01_PM.TODO]]
@[https://avaldes.com/?s=java+thread]

- Java Thread, Concurrency and Multithreading Tutorial
- Java Threads and Concurrent Locks with Examples
  https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html
- Java Thread Deadlock Example and Thread Dump Analysis using VisualVM
- Java Thread Starvation and Livelock with Examples
- Examining Volatile Keyword with Java Threads
- Java Threads Wait, Notify and NotifyAll Example
[[}]]

# JIMFS [[{async/reactive.io,persistence.fs,01_PM.TODO]]
@[https://github.com/google/jimfs]
- Jimfs supports almost all the APIs under java.nio.file:
  - Create/delete/move/Copy  files/dirs.
  - Read/write files with FileChannel/SeekableByteChannel/InputStream/OutputStream/...
  - Symbolic links.
  - Hard links to regular files.
  - SecureDirectoryStream, for operations relative to an open directory.
  - Glob and regex path filtering with PathMatcher.
  - Watching for changes to a directory with a WatchService.
  - Built-in (file) attribute views that can be supported include
    "basic", "owner", "posix", "unix", "dos", "acl" and "user".
- Simple ussage:
  import com.google.common.jimfs.Configuration;
  import com.google.common.jimfs.Jimfs;
  ...

  // For a simple file system with Unix-style paths and behavior:
  final FileSystem fs = Jimfs.newFileSystem(Configuration.unix());
  final Path foo = fs.getPath("/foo");
  Files.createDirectory(foo);
  final Path hello = foo.resolve("hello.txt");
  Files.write(hello, ImmutableList.of("hello world"), StandardCharsets.UTF_8);


[[}]]

# Java Poet [[{01_PM.backlog]]
@[https://github.com/square/javapoet]
## Java API for generating .java source files.
## useful for:
  - transpiling: Custom language to java.
  - annotation processing
  - interacting with metadata files (database schemas, protocol formats,...).

## Avoid boilerplate while also keeping a  single source of truth .
[[}]]

# Storing HttpSessions to Redis [[{persistence.session,scalability.cache,architecture.distributed]]
@[https://github.com/AmadeusITGroup/HttpSessionReplacer]
AmadeusITGroup/HttpSessionReplacer: Store JEE Servlet HttpSessions in Redis
[[}]]

# Dekorate k8s annotations [[{devops.k8s,01_PM.backlog]]
@[https://developers.redhat.com/blog/2021/03/17/using-dekorate-to-generate-kubernetes-manifests-for-java-applications/]
## ex:
  JAVA ANOTATION INPUT
  ====================
  @KubernetesApplication(
     name = "hello-world-fwless-k8s",
     ports = @Port(name = "web", containerPort = 8080),
     expose = true,
     host = "fw-app.127.0.0.1.nip.io",
     imagePullPolicy = ImagePullPolicy.Always
  )

  Kubernetes Output:
  ====================
  · target/classes/META-INF/dekorate/kubernetes.yml
    Use like:
  $ $ kubectl create ns demo
  $ $ kubectl apply -f kubernetes.yml -n demo
  · target/classes/META-INF/dekorate/kubernetes.json

## Integration with Jib to generate OCI images is also available.
[[}]]

# Servlet servers Arch [[{01_PM.TODO,standards.jee.servlets]]
embedded servers usually comprise two logical components:

┌───────────────────────────────────┬────────────────────────────────
│  LOGICAL COMPONENT                │  TOMCAT equivalent
├───────────────────────────────────┼────────────────────────────────
│  a web server component           │  Coyote
│  listening for HTTP requests and  │
│  returning HTTP responses         │
├───────────────────────────────────┼────────────────────────────────
│  an execution context to make     │  Catalina, based on Servlet API
│  a Java web application interact  │  (usually called the Servlet
│  with the web server.             │  Container)
└───────────────────────────────────┴────────────────────────────────
[[}]]

# Yourkit profiler [[{java_lang.profiling,01_PM.radar]]
@[https://www.yourkit.com/java/profiler/features/]
## Yourkit: commercial (non OOSS) profiler with advanced features
## Tight integration with your IDE
## "Smart what if"  allows to evaluate performance gains of supposed optimizations
  without re-profiling the application.
## CPU call tree
## Flame graphs
## Database queries and web requests:
  - display slow SQL queries and web requests.
  (support for MongoDB, Cassandra, HBase,...)

## Memory profiling: object heap, traversing of object graph.
  The Profiler chooses the best way to show you a content of a HashMap, String, ... ).
  For each object you can see how much memory it retains, and what happens when
  particular reference in object graph does not exist.
  This saves time, and lets you estimate the expected memory leak fix without changing the code.

## Memory profiling:

## 40+ comprehensive inspections are waiting to make your code faster and more efficient.

## Profiler knows a lot about typical issues in Java applications and automatically finds them.

## Report inefficient collections and I/O operations.

## Find/Resolve thread synchronization issues.
  It is possible to combine thread states with HTTP requests and SQL queries to get
  the full picture how the requests are processed by your applications.

## Exception profiling: Massive exception throwing is a common but often hidden
  performance problem.

## Deobfuscate the code on the fly restoring original class, method and field names of
  applications obfuscated with ProGuard, yGuard, Zelix KlassMaster, Allatori, and other
  popular Java obfuscators.

## control profiling overhead up to production profiling.

## Extensible API to create custom probes.

## Command line support. (UI free).

## free licenses for non-commercial open source projects.
  Special offers for educational and scientific organizations.
[[}]]

## LMAX Disruptor: High Perf Inter-Thread Messaging Library [[{concurrency,01_PM.radar]]
@[https://lmax-exchange.github.io/disruptor/]

See also:
@[https://www.infoq.com/articles/High-Performance-Java-Inter-Thread-Communications/]

@[https://www.infoq.com/news/2013/05/lmax-zing]
LMAX Exchange Getting Up To 50% Improvement in Latency From Azul's Zing JVM
Interesting points about GC tunning.
[[}]]

## Tribe: reliable multicast [[{java_lang.io.multicast,architecture.distributed,scalability.distributed]]
                            [[doc_has.comparative,qa,01_PM.low_code,01_PM.radar]]
REF: @[http://tribe.ow2.org/]
- Unlike JGroups, Tribe only targets reliable multicast
 (no probabilistic delivery) and is optimized for cluster
 communications.

## JGroups multicast
@[http://www.jgroups.org/]
- toolkit for reliable multicast communication.
- point-to-point FIFO communication channels (basically TCP)
- Targets high performance cluster environments.

- Unlike JGroups, Tribe only targets reliable multicast
  (no probabilistic delivery) and is optimized for
  cluster communications.
[[}]]

# OSV.io [[{scalability.unikernel,security,devops,01_PM.backlog]]
- @[http://osv.io/]
  versatile modular unikernel designed to run unmodified Linux
  applications securely on micro-VMs in the cloud. Built from the ground up for
  effortless deployment and management of micro-services and serverless apps,
  with superior performance. (Includes CRaSH shell)
[[}]]

# Excellent Java Blog (spanish)
  @[https://picodotdev.github.io/blog-bitix/tags/java/">Excellent Java Blog (spanish)

# @[https://github.com/akullpp/awesome-java] Awesome Java

# Amazon CodeGuru [[{qa.testing,cloud.aws,devops,01_PM.backlog]]
- Powered by IA.
- CodeGuru consists of two components
– Amazon CodeGuru Profiler:
  helps developers find an application’s most expensive lines
  of code along with specific visualizations and recommendations
  on how to improve code to save money.
- Amazon CodeGuru Reviewer:
  helps enhance the quality of code by scanning for critical issues,
  identifying bugs, and recommending how to remediate them.
  ```
  ┌> Write Code
  ·    |
  ·    v
  ·  Review Code  ← CodeGuru Reviewer
  ·    |
  ·    v
  ·  Test App     ← CodeGuru Profiler
  ·    |
  ·    v
  ·  Deploy App
  ·    |
  ·    v
  ·  Run App      ← CodeGuru Profiler
  ·    |
  └····┘
  ```

- Profiler supports application written
in Java virtual machine (JVM) languages such as Clojure,
JRuby, Jython, Groovy, Kotlin, Scala, and Java.
- Reviewer’s bug-fixing recommendations currently support
Java code stored in GitHub, AWS CodeCommit, or Bitbucket.
[[}]]

# Java, Soft. Arch: E.C.S. Dominon favors composition over inheritance
https://www.reddit.com/r/java/comments/z5yj0i/dominion_vs_artemis_the_missing_benchmarks_link/
Entity Component System (ECS) architecture promotes data-oriented
programming. It’s all about data (components) andfirst-class
functions (systems) that operate on data.This means that, unlike OOP,
data and operations are not encapsulated together in objects, which
are called entities inECS.Entities model the business objects of the
user application, and the entity promotes “composition over
inheritance” bygrouping a dynamic list of components to define its
specific features.

# Spring Batch 5.0GA
  https://www.reddit.com/r/java/comments/z3vmb2/spring_batch_50_goes_ga/

# What's New in Spring Framework 6.x
 · spring-projects/spring-framework Wiki · GitHub
https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-6.x/
Juergen Hoeller edited this page Nov 11, 2022 · 27 revisions s
Entire framework codebase based on Java 17 source code level
now.Migration from javax to jakarta namespace for Servlet, JPA,
etc.Runtime compatibility with Jakarta EE 9 as well as Jakarta EE 10
APIs.Compatible with latest web servers: Tomcat 10.1, Jetty 11,
Undertow 2.3.Early compatibility with virtual threads (in preview as
of JDK 19).General Core RevisionUpgrade to ASM 9.4 and Kotlin
1.7.Complete CGLIB fork with support for capturing CGLIB-generated
classes.Comprehensive foundation for Ahead-Of-Time
transformations.First-class support for GraalVM native images (see
related Spring Boot 3 blog post).Core ContainerBasic bean property
determination without java.beans.Introspector by default.AOT
processing support in GenericApplicationContext
(refreshForAotProcessing).Bean definition transformation based on
pre-resolved constructors and factory methods.Support for early proxy
class determination for AOP proxies and configuration
classes.PathMatchingResourcePatternResolver uses NIO and module path
APIs for scanning, enabling support for classpath scanning within a
GraalVM native image and within the Java module path,
respectively.DefaultFormattingConversionService supports ISO-based
default java.time type parsing.Data Access and TransactionsSupport
for predetermining JPA managed types (for inclusion in AOT
processing).JPA support for Hibernate ORM 6.1 (retaining
compatibility with Hibernate ORM 5.6).Upgrade to R2DBC 1.0 (including
R2DBC transaction definitions).Removal of JCA CCI support.Spring
MessagingRSocket interface client based on @RSocketExchange service
interfaces.Early support for Reactor Netty 2 based on Netty 5
alpha.Support for Jakarta WebSocket 2.1 and its standard WebSocket
protocol upgrade mechanism.General Web RevisionHTTP interface client
based on @HttpExchange service interfaces.Support for RFC 7807
problem details.Unified HTTP status code handling.Support for Jackson
2.14.Alignment with Servlet 6.0 (while retaining runtime
compatibility with Servlet 5.0).Spring MVCPathPatternParser used by
default (with the ability to opt into PathMatcher).Removal of
outdated Tiles and FreeMarker JSP support.Spring WebFluxNew PartEvent
API to stream multipart form uploads (both on client and server).New
ResponseEntityExceptionHandler to customize WebFlux exceptions and
render RFC 7807 error responses.Flux return values for non-streaming
media types (no longer collected to List before written).Early
support for Reactor Netty 2 based on Netty 5 alpha.JDK HttpClient
integrated with WebClient.ObservabilityDirect Observability
instrumentation with Micrometer Observation in several parts of the
Spring Framework. The spring-web module now requires
io.micrometer:micrometer-observation:1.10+ as a compile
dependency.RestTemplate and WebClient are instrumented to produce
HTTP client request observations.Spring MVC can be instrumented for
HTTP server observations using the new
org.springframework.web.filter.ServerHttpObservationFilter.Spring
WebFlux can be instrumented for HTTP server observations using the
new
org.springframework.web.filter.reactive.ServerHttpObservationFilter.In
tegration with Micrometer Context Propagation for Flux and Mono
return values from controller methods.TestingSupport for testing
AOT-processed application contexts on the JVM or within a GraalVM
native image.Integration with HtmlUnit 2.64+ request parameter
handling.Servlet mocks (MockHttpServletRequest, MockHttpSession) are
based on Servlet API 6.0 now.

# https://www.reddit.com/r/java/comments/z1s58l/spring_6_migration_guide/

# Porting Million Lines of Code from Java to Kotlin at Meta
  https://www.infoq.com/news/2022/11/meta-port-java-kotlin/

# Getting Ready for Spring Framework 6 - Spring Framework Guru
  https://springframework.guru/getting-ready-for-spring-framework-6/

# BellSoft Introduces Alpaquita Linux
  https://www.infoq.com/news/2022/10/java-news-roundup-sep26-2022/
  BellSoft has introduced Alpaquita Linux, an operating system tailored
  for the Java programming language. Based on Alpine Linux, this new
  operating system: enables the effective containerization of Java
  applications developed with Liberica JDK; improves security; contains
  new features for better performance; and allows developers to take
  advantage of native image technology through the Liberica Native
  Image Kit. InfoQ will follow up with a more detailed news story.

# Project Loom: Revolution in Java Concurrency or Obscure Implementation Detail?
  https://www.infoq.com/presentations/loom-java-concurrency/
    Project Loom: Revolution in Java Concurrency or Obscure
  Implementation Details Summary Tomasz Nurkiewicz explores what Loom
  is, how it's implemented, what problems it solves, its shortcomings,
  and will it make reactive programming obsolete? Bio Tomasz Nurkiewicz
  works in the e-commerce sector. Involved in open-source, DZone’s
  Most Valuable Blogger, used to be very active on StackOverflow.
  Author, trainer, conference speaker, technical reviewer, runner.
  Claims that code not tested automatically is not a feature but just a
  rumor. Wrote a book on RxJava for O’Reilly. About the conference
  QCon Plus is a virtual conference for senior software engineers and
  architects that covers the trends, best practices, and solutions
  leveraged by the world's most innovative software organizations.
  				INFOQ EVENTS

  	Oct 24-28 (In-Person, San Francisco)

# Nurkiewicz: I'd like to talk about Project Loom, a very new and
exciting initiative that will land eventually in the Java Virtual
Machine. Most importantly, I would like to briefly explain whether
it's going to be a revolution in the way we write concurrent
software, or maybe it's just some implementation detail that's going
to be important for framework or library developers, but we won't
really see it in real life. The first question is, what is Project
Loom? The question I give you in the subtitle is whether it's going
to be a revolution or just an obscure implementation detail. My name
is Tomasz Nurkiewicz.First of all, we would like to understand how we
can create millions of threads using Project Loom. This is an
overstatement. In general, this will be possible with Project Loom.
As you probably know, these days, it's only possible to create
hundreds, maybe thousands of threads, definitely not millions. This
is what Project Loom unlocks in the Java Virtual Machine. This is
mainly possible by allowing you to block and sleep everywhere,
without paying too much attention to it. Blocking, sleeping, or any
other locking mechanisms were typically quite expensive, in terms of
the number of threads we could create. These days, it's probably
going to be very safe and easy. The last but the most important
question is, how is it going to impact us developers? Is it actually
so worthwhile, or maybe it's just something that is buried deeply in
the virtual machine, and it's not really that much needed?Before we
actually explain, what is Project Loom, we must understand what is a
thread in Java? I know it sounds really basic, but it turns out
there's much more into it. First of all, a thread in Java is called a
user thread. Essentially, what we do is that we just create an object
of type thread, we parse in a piece of code. When we start such a
thread here on line two, this thread will run somewhere in the
background. The virtual machine will make sure that our current flow
of execution can continue, but this separate thread actually runs
somewhere. At this point in time, we have two separate execution
paths running at the same time, concurrently. The last line is
joining. It essentially means that we are waiting for this background
task to finish. This is not typically what we do. Typically, we want
two things to run concurrently.This is a user thread, but there's
also the concept of a kernel thread. A kernel thread is something
that is actually scheduled by your operating system. I will stick to
Linux, because that's probably what you use in production. With the
Linux operating system, when you start a kernel thread, it is
actually the operating system's responsibility to make sure all
kernel threads can run concurrently, and that they are nicely sharing
system resources like memory and CPU. For example, when a kernel
thread runs for too long, it will be preempted so that other threads
can take over. It more or less voluntarily can give up the CPU and
other threads may use that CPU. It's much easier when you have
multiple CPUs, but most of the time, this is almost always the case,
you will never have as many CPUs as many kernel threads are running.
There has to be some coordination mechanism. This mechanism happens
in the operating system level.User threads and kernel threads aren't
actually the same thing. User threads are created by the JVM every
time you say newthread.start. Kernel threads are created and managed
by the kernel. That's obvious. This is not the same thing. In the
very prehistoric days, in the very beginning of the Java platform,
there used to be this mechanism called the many-to-one model. In the
many-to-one model. The JVM was actually creating user threads, so
every time you set newthread.start, a JVM was creating a new user
thread. However, these threads, all of them were actually mapped to a
single kernel thread, meaning that the JVM was only utilizing a
single thread in your operating system. It was doing all the
scheduling, so making sure your user threads are effectively using
the CPU. All of this was done inside the JVM. The JVM from the
outside was only using a single kernel thread, which means only a
single CPU. Internally, it was doing all this back and forth
switching between threads, also known as context switching, it was
doing it for ourselves.There was also this rather obscure
many-to-many model, in which case you had multiple user threads,
typically a smaller number of kernel threads, and the JVM was doing
mapping between all of these. However, luckily, the Java Virtual
Machine engineers realized that there's not much point in duplicating
the scheduling mechanism, because the operating system like Linux
already has all the facilities to share CPUs and threads with each
other. They came up with a one-to-one model. With that model, every
single time you create a user thread in your JVM, it actually creates
a kernel thread. There is one-to-one mapping, which means
effectively, if you create 100 threads, in the JVM you create 100
kernel resources, 100 kernel threads that are managed by the kernel
itself. This has some other interesting side effects. For example,
thread priorities in the JVM are effectively ignored, because the
priorities are actually handled by the operating system, and you
cannot do much about them.It turns out that user threads are actually
kernel threads these days. To prove that that's the case, just check,
for example, jstack utility that shows you the stack trace of your
JVM. Besides the actual stack, it actually shows quite a few
interesting properties of your threads. For example, it shows you the
thread ID and so-called native ID. It turns out, these IDs are
actually known by the operating system. If you know the operating
system's utility called top, which is a built in one, it has a switch
-H. With the H switch, it actually shows individual threads rather
than processes. This might be a little bit surprising. After all, why
does this top utility that was supposed to be showing which processes
are consuming your CPU, why does it have a switch to show you the
actual threads? It doesn't seem to make much sense.However, it turns
out, first of all, it's very easy with that tool to show you the
actual Java threads. Rather than showing a single Java process, you
see all Java threads in the output. More importantly, you can
actually see, what is the amount of CPU consumed by each and every of
these threads? This is useful. Why is that the case? Does it mean
that Linux has some special support for Java? Definitely not. Because
it turns out that not only user threads on your JVM are seen as
kernel threads by your operating system. On newer Java versions, even
thread names are visible to your Linux operating system. Even more
interestingly, from the kernel point of view, there is no such thing
as a thread versus process. Actually, all of these are called tasks.
This is just a basic unit of scheduling in the operating system. The
only difference between them is just a single flag, when you're
creating a thread rather than a process. When you're creating a new
thread, it shares the same memory with the parent thread. When you're
creating a new process, it does not. It's just a matter of a single
bit when choosing between them. From the operating system's
perspective, every time you create a Java thread, you are creating a
kernel thread, which is, in some sense you're actually creating a new
process. This may actually give you some overview like how
heavyweight Java threads actually are.First of all, they are Kernel
resources. More importantly, every thread you create in your Java
Virtual Machine consumes more or less around 1 megabyte of memory,
and it's outside of heap. No matter how much heap you allocate, you
have to factor out the extra memory consumed by your threads. This is
actually a significant cost, every time you create a thread, that's
why we have thread pools. That's why we were taught not to create too
many threads on your JVM, because the context switching and memory
consumption will kill us.This is where Project Loom shines. This is
still work in progress, so everything can change. I'm just giving you
a brief overview of how this project looks like. Essentially, the
goal of the project is to allow creating millions of threads. This is
an advertising talk, because you probably won't create as many.
Technically, it is possible, and I can run millions of threads on
this particular laptop. How is it achieved? First of all, there's
this concept of a virtual thread. A virtual thread is very
lightweight, it's cheap, and it's a user thread. By lightweight, I
mean you can really allocate millions of them without using too much
memory. There's a virtual thread. Secondly, there's also a carrier
thread. A carrier thread is the real one, it's the kernel one that's
actually running your virtual threads. Of course, the bottom line is
that you can run a lot of virtual threads sharing the same carrier
thread. In some sense, it's like an implementation of an actor system
where we have millions of actors using a small pool of threads. All
of this can be achieved using a so-called continuation. Continuation
is a programming construct that was put into the JVM, at the very
heart of the JVM. There are actually similar concepts in different
languages. Continuation, the software construct is the thing that
allows multiple virtual threads to seamlessly run on very few carrier
threads, the ones that are actually operated by your Linux system.I
will not go into the API too much because it's subject to change. As
you can see, it's actually fairly simple. You essentially say
Thread.startVirtualThread, as opposed to new thread or starting a
platform thread. A platform thread is your old typical user threads,
that's actually a kernel thread, but we're talking about virtual
threads here. We can create a thread from scratch. You can create it
using a builder method, whatever. You can also create a very weird
ExecutorService. This ExecutorService doesn't actually pull threads.
Typically, ExecutorService has a pool of threads that can be reused
in case of new VirtualThreadExecutor, it creates a new virtual thread
every time you submit a task. It's not really a thread pool, per se.
You can also create a ThreadFactory if you need it in some API, but
this ThreadFactory just creates virtual threads. That's very simple
API.The API is not the important part, I would like you to actually
understand what happens underneath, and what impact may it have on
your code bases. A virtual thread is essentially a continuation plus
scheduler. A scheduler is a pool of physical called carrier threads
that are running your virtual threads. Typically, a scheduler is just
a fork join pool with a handful of threads. You don't need more than
one to four, maybe eight carrier threads, because they use the CPU
very effectively. Every time a virtual thread no longer needs a CPU,
it will just give up the scheduler, it will no longer use a thread
from that scheduler, and another virtual thread will kick in. That's
the first mechanism. How does the virtual thread and the scheduler
know that the virtual thread no longer needs a scheduler?This is
where continuations come into play. This is a fairly convoluted
explanation. Essentially, a continuation is a piece of code that can
suspend itself at any moment in time and then it can be resumed later
on, typically on a different thread. You can freeze your piece of
code, and then you can unlock it, or you can unhibernate it, you can
wake it up on a different moment in time, and preferably even on a
different thread. This is a software construct that's built into the
JVM, or that will be built into the JVM.Let's look into a very simple
pseudo-code here. This is a main function that calls foo, then foo
calls bar. There's nothing really exciting here, except from the fact
that the foo function is wrapped in a continuation. Wrapping up a
function in a continuation doesn't really run that function, it just
wraps a Lambda expression, nothing specific to see here. However, if
I now run the continuation, so if I call run on that object, I will
go into foo function, and it will continue running. It runs the first
line, and then goes to bar method, it goes to bar function, it
continues running. Then on line 16, something really exciting and
interesting happens. The function bar voluntarily says it would like
to suspend itself. The code says that it no longer wishes to run for
some bizarre reason, it no longer wishes to use the CPU, the carrier
thread. What happens now is that we jump directly back to line four,
as if it was an exception of some kind. We jump to line four, we
continue running. The continuation is suspended. Then we move on, and
in line five, we run the continuation once again. Will it run the foo
function once more? Not really, it will jump straight to line 17,
which essentially means we are continuing from the place we left off.
This is really surprising. Also, it means we can take any piece of
code, it could be running a loop, it could be doing some recursive
function, whatever, and we can all the time and every time we want,
we can suspend it, and then bring it back to life. This is the
foundation of Project Loom. Continuations are actually useful, even
without multi-threading.Continuations that you see in here are
actually quite common in different languages. You have coroutines or
goroutines, in languages like Kotlin and Go. You have async/await in
JavaScript. You have generators in Python, or fibers in Ruby. All of
these are actually very similar concepts, which are finally brought
into the JVM. What difference does it make? Let's see how thread
sleep is implemented. It used to be simply a function that just
blocks your current thread so that it still exists on your operating
system. However, it no longer runs, so it will be woken up by your
operating system. A new version that takes advantage of virtual
threads, notice that if you're currently running a virtual thread, a
different piece of code is run.This piece of code is quite
interesting, because what it does is it calls yield function. It
suspends itself. It voluntarily says that it no longer wishes to run
because we asked that thread to sleep. That's interesting. Why is
that? Before we actually yield, we schedule unparking. Unparking or
waking up means basically, that we would like ourselves to be woken
up after a certain period of time. Before we put ourselves to sleep,
we are scheduling an alarm clock. This scheduling will wake us up. It
will continue running our thread, it will continue running our
continuation after a certain time passes by. In between calling the
sleep function and actually being woken up, our virtual thread no
longer consumes the CPU. At this point, the carrier thread is free to
run another virtual thread. Technically, you can have millions of
virtual threads that are sleeping without really paying that much in
terms of the memory consumption.This is our Hello World. This is
overblown, because everyone says millions of threads and I keep
saying that as well. That's the piece of code that you can run even
right now. You can download Project Loom with Java 18 or Java 19, if
you're cutting edge at the moment, and just see how it works. There
is a count variable. If you put 1 million, it will actually start 1
million threads, and your laptop will not melt and your system will
not hang, it will simply just create these millions of threads. As
you already know, there is no magic here. Because what actually
happens is that we created 1 million virtual threads, which are not
kernel threads, so we are not spamming our operating system with
millions of kernel threads. The only thing these kernel threads are
doing is actually just scheduling, or going to sleep, but before they
do it, they schedule themselves to be woken up after a certain time.
Technically, this particular example could easily be implemented with
just a scheduled ExecutorService, having a bunch of threads and 1
million tasks submitted to that executor. There is not much
difference. As you can see, there is no magic here. It's just that
the API finally allows us to build in a much different, much easier
way.Here's another code snippet of the carrier threads. The API may
change, but the thing I wanted to show you is that every time you
create a virtual thread, you're actually allowed to define a
carrierExecutor. In our case, I just create an executor with just one
thread. Even with just a single thread, single carriers, or single
kernel thread, you can run millions of threads as long as they don't
consume the CPU all the time. Because, after all, Project Loom will
not magically scale your CPU so that it can perform more work. It's
just a different API, it's just a different way of defining tasks
that for most of the time are not doing much. They are sleeping
blocked on a synchronization mechanism, or waiting on I/O. There's no
magic here. It's just a different way of performing or developing
software.There's also a different algorithm or a different initiative
coming as part of Project Loom called structured concurrency. It's
actually fairly simple. There's not much to say here. Essentially, it
allows us to create an ExecutorService that waits for all tasks that
were submitted to it in a try with resources block. This is just a
minor addition to the API, and it may change.The reason I'm so
excited about Project Loom is that finally, we do not have to think
about threads. When you're building a server, when you're building a
web application, when you're building an IoT device, whatever, you no
longer have to think about pooling threads, about queues in front of
a thread pool. At this point, all you have to do is just creating
threads every single time you want to. It works as long as these
threads are not doing too much work. Because otherwise, you just need
more hardware. There's nothing special here. If you have a ton of
threads that are not doing much, they're just waiting for data to
arrive, or they are just locked on a synchronization mechanism
waiting for a semaphore or CountDownLatch, whatever, then Project
Loom works really well. We no longer have to think about this low
level abstraction of a thread, we can now simply create a thread
every time for every time we have a business use case for that. There
is no leaky abstraction of expensive threads because they are no
longer expensive. As you can probably tell, it's fairly easy to
implement an actor system like Akka using virtual threads, because
essentially what you do is you create a new actor, which is backed by
a virtual thread. There is no extra level of complexity that arises
from the fact that a large number of actors has to share a small
number of threads.A few use cases that are actually insane these
days, but they will be maybe useful to some people when Project Loom
arrives. For example, let's say you want to run something after eight
hours, so you need a very simple scheduling mechanism. Doing it this
way without Project Loom is actually just crazy. Creating a thread
and then sleeping for eight hours, because for eight hours, you are
consuming system resources, essentially for nothing. With Project
Loom, this may be even a reasonable approach, because a virtual
thread that sleeps consumes very little resources. You don't pay this
huge price of scheduling operating system resources and consuming
operating system's memory.Another use case, let's say you're building
a massive multiplayer game, or a very highly concurrent server, or a
chat application like WhatsApp that needs to handle millions of
connections, there is actually nothing wrong with creating a new
thread per each player, per each connection, per each message even.
Of course, there are some limits here, because we still have a
limited amount of memory and CPU. Anyways, confront that with the
typical way of building software where you had a limited worker pool
in a servlet container like Tomcat, and you had to do all these fancy
algorithms that are sharing this thread pool, and making sure it's
not exhausted, making sure you're monitoring the queue. Now it's
easy, every time a new HTTP connection comes in, you just create a
new virtual thread, as if nothing happens. This is how we were taught
Java 20 years ago, then we realized it's a poor practice. These days,
it may actually be a valuable approach again.Another example. Let's
say we want to download 10,000 images. With Project Loom, we simply
start 10,000 threads, each thread per each image. That's just it.
Using the structured concurrency, it's actually fairly simple. Once
we reach the last line, it will wait for all images to download. This
is really simple. Once again, confront that with your typical code,
where you would have to create a thread pool, make sure it's
fine-tuned. There's a caveat here. Notice that with a traditional
thread pool, all you had to do was essentially just make sure that
your thread pool is not too big, like 100 threads, 200 threads, 500,
whatever. This was the natural limit of concurrency. You cannot
download more than 100 images at once, if you have just 100 threads
in your standard thread pool.With this approach with Project Loom,
notice that I'm actually starting as many concurrent connections, as
many concurrent virtual threads, as many images there are. I
personally don't pay that much price for starting these threads
because all they do is just like being blocked on I/O. In Project
Loom, every blocking operation, so I/O like network typically, so
waiting on a synchronization mechanism like semaphores, or sleeping,
all these blocking operations are actually yielding, which means that
they are voluntarily giving up a carrier thread. It's absolutely fine
to start 10,000 concurrent connections, because you won't pay the
price of 10,000 carrier or kernel threads, because these virtual
threads will be hibernated anyway. Only when the data arrives, the
JVM will wake up your virtual thread. In the meantime, you don't pay
the price. This is pretty cool. However, you just have to be aware of
the fact that the kernel threads of your thread pools were actually
just natural like limit to concurrency. Just blindly switching from
platform threads, the old ones, to virtual threads will change the
semantics of your application.To make matters even worse, if you
would like to use Project Loom directly, you will have to relearn all
these low level structures like CountDownLatch or semaphore to
actually do some synchronization or to actually do some throttling.
This is not the path I would like to take. I would definitely like to
see some high level frameworks that are actually taking advantage of
Project Loom.Do we have such frameworks and what problems and
limitations can we reach here? Before we move on to some high level
constructs, so first of all, if your threads, either platform or
virtual ones have a very deep stack. This is your typical Spring Boot
application, or any other framework like Quarkus, or whatever, if you
put a lot of different technologies like adding security, aspect
oriented programming, your stack trace will be very deep. With
platform threads, the size of the stack trace is actually fixed. It's
like half a megabyte, 1 megabyte, and so on. With virtual threads,
the stack trace can actually shrink and grow, and that's why virtual
threads are so inexpensive, especially in Hello World examples, where
all what they do is just like sleeping most of the time, or
incrementing a counter, or whatever. In real life, what you will get
normally is actually, for example, a very deep stack with a lot of
data. If you suspend such a virtual thread, you do have to keep that
memory that holds all these stack lines somewhere. The cost of the
virtual thread will actually approach the cost of the platform
thread. Because after all, you do have to store the stack trace
somewhere. Most of the time it's going to be less expensive, you will
use less memory, but it doesn't mean that you can create millions of
very complex threads that are doing a lot of work. It's just an
advertising gimmick. It doesn't hold true for normal workloads. Keep
that in mind. There's no magic here.Another thing that's not yet
handled is preemption, when you have a very CPU intensive task. Let's
say you have 4 CPU cores, and you create 4 platform threads, or 4
kernel threads that are doing very CPU intensive work, like crunching
numbers, cryptography, hashing, compression, encoding, whatever. If
you have 4 physical threads, or platform threads doing that, you're
essentially just maxing your CPU. If instead you create 4 virtual
threads, you will basically do the same amount of work. It doesn't
mean that if you replace 4 virtual threads with 400 virtual threads,
you will actually make your application faster, because after all,
you do use the CPU. There's not much hardware to do the actual work,
but it gets worse. Because if you have a virtual thread that just
keeps using the CPU, it will never voluntarily suspend itself,
because it never reaches a blocking operation like sleeping, locking,
waiting for I/O, and so on. In that case, it's actually possible that
you will only have a handful of virtual threads that never allow any
other virtual threads to run, because they just keep using the CPU.
That's the problem that's already handled by platform threads or
kernel threads because they do support preemption, so stopping a
thread in some arbitrary moment in time. It's not yet supported with
Project Loom. It may be one day, but it's not yet the case.There's
also a whole list of unsupported APIs. One of the main goals of
Project Loom is to actually rewrite all the standard APIs. For
example, socket API, or file API, or lock APIs, so lock support,
semaphores, CountDownLatches. All of these APIs are sleep, which we
already saw. All of these APIs need to be rewritten so that they play
well with Project Loom. However, there's a whole bunch of APIs, most
importantly, the file API. I just learned that there's some work
happening. There's a list of APIs that do not play well with Project
Loom, so it's easy to shoot yourself in the foot.One more thing. With
Project Loom, you no longer consume the so-called stack space. The
virtual threads that are not running at the moment, which is
technically called pinned, so they are not pinned to a carrier
thread, but they are suspended. These virtual threads actually reside
on heap, which means they are subject to garbage collection. In that
case, it's actually fairly easy to get into a situation where your
garbage collector will have to do a lot of work, because you have a
ton of virtual threads. You don't pay the price of platform threads
running and consuming memory, but you do get the extra price when it
comes to garbage collection. The garbage collection may take
significantly more time. This was actually an experiment done by the
team behind Jetty. After switching to Project Loom as an experiment,
they realized that the garbage collection was doing way more work.
The stack traces were actually so deep under normal load, that it
didn't really bring that much value. That's an important
takeaway.Another question is whether we still need reactive
programming. If you think about it, we do have a very old class like
RestTemplate, which is like this old school blocking HTTP client.
With Project Loom, technically, you can start using RestTemplate
again, and you can use it to, very efficiently, run multiple
concurrent connections. Because RestTemplate underneath uses HTTP
client from Apache, which uses sockets, and sockets are rewritten so
that every time you block, or wait for reading or writing data, you
are actually suspending your virtual thread. It seems like
RestTemplate or any other blocking API is exciting again. At least
that's what we might think, you no longer need reactive programming
and all these like WebFluxes, RxJavas, Reactors, and so on.Project
Loom addresses just a tiny fraction of the problem, it addresses
asynchronous programming. It makes asynchronous programming much
easier. However, it doesn't address quite a few other features that
are supported by reactive programming, namely backpressure, change
propagation, composability. These are all features or frameworks like
Reactor, or Akka, or Akka streams, whatever, which are not addressed
by Loom because Loom is actually quite low level. After all, it's
just a different way of creating threads.Should you just blindly
install the new version of Java whenever it comes out and just switch
to virtual threads? I think the answer is no, for quite a few
reasons. First of all, the semantics of your application change. You
no longer have this natural way of throttling because you have a
limited number of threads. Also, the profile of your garbage
collection will be much different. We have to take that into
account.When will Project Loom be available? It was supposed to be
available in Java 17, we just got Java 18 and it's still not there.
Hopefully, it will be ready when it's ready. Hopefully, we will live
into that moment. I'm experimenting with Project Loom for quite some
time already. It works. It sometimes crashes. It's not vaporware, it
actually exists.I leave you with a few materials which I collected,
more presentations and more articles that you might find interesting.
Quite a few blog posts that explain the API a little bit more
thoroughly. A few more critical or skeptic points of view, mainly
around the fact that Project Loom won't really change that much. It's
especially for the people who believe that we will no longer need
reactive programming because we will all just write our code using
plain Project Loom. Also, my personal opinion, that's not going to be
the case, we will still need some higher level abstraction.Cummins:
How do you debug it? Does it make it harder to debug? Does it make it
easier to debug? What tooling support is there? Is there more tooling
support coming?Nurkiewicz: The answer is actually twofold. On one
hand, it's easier, because you no longer have to hop between threads
so much, in reactive programming or asynchronous programming in
general. What you typically do is that you have a limited number of
threads, but you jump between threads very often, which means that
stack traces are cut in between, so you don't see the full picture.
It gets a little bit convoluted, and frameworks like Reactor try to
somehow reassemble the stack trace, taking into account that you are
jumping between thread pools, or some asynchronous Netty threads. In
that case, Loom makes it easier, because you can survive, you can
make a whole request just in a single thread, because logically,
you're still on the same thread, this thread is being paused. It's
being unpinned, and pinned back to a carrier thread. When the
exception arises, this exception will show the whole stack trace
because you're not jumping between threads. What you typically do is
that when you want to do something asynchronous, you put it into a
thread pool. Once you're in a thread pool, you lose the original
stack trace, you lose the original thread.In case of Project Loom,
you don't offload your work into a separate thread pool, because
whenever you're blocked your virtual thread has very little cost. In
some sense, it's going to be easier. However, you will still be
probably using multiple threads to handle a single request. That
problem doesn't really go away. In some cases, it will be easier but
it's not like an entirely better experience. On the other hand, you
now have 10 times or 100 times more threads, which are all doing
something. These aren't really like Java threads. You won't, for
example, see them on a thread dump. This may change but that's the
case right now. You have to take that into account. When you're doing
a thread dump, which is probably one of the most valuable things you
can get when troubleshooting your application, you won't see virtual
threads which are not running at the moment.If you are doing the
actual debugging, so you want to step over your code, you want to
see, what are the variables? What is being called? What is sleeping
or whatever? You can still do that. Because when your virtual thread
runs, it's a normal Java thread. It's a normal platform thread
because it uses carrier thread underneath. You don't really need any
special tools. However, you just have to remember on the back of your
head, that there is something special happening there, that there is
a whole variety of threads that you don't see, because they are
suspended. As far as JVM is concerned, they do not exist, because
they are suspended. They're just objects on heap, which is
surprising.Cummins: It's hard to know which is worse, you have a
million threads, and they don't turn up in your heap thread dump, or
you have a million threads and they do turn up in your heap
dump.Nurkiewicz: Actually, reactive is probably the worst here
because you have million ongoing requests, for example, HTTP
requests, and you don't see them anywhere. Because with reactive,
with truly asynchronous APIs, HTTP database, whatever, what happens
is that you have a thread that makes a request, and then absolutely
forgets about that request until it gets a response. A single thread
handles hundreds of thousands of requests concurrently or truly
concurrently. In that case, if you make a thread dump, it's actually
the worst of both worlds, because what you see is just a very few
reactive threads like Netty, for example, which is typically used.
These native threads are not actually doing any business logic,
because most of the time, they are just waiting for data to be sent
or received. Troubleshooting a reactive application using a thread
dump is actually very counterproductive. In that case, virtual
threads are actually helping a little bit, because at least you will
see the running threads.Cummins: It's probably like a lot of things
where when the implementation moves closer to our mental model,
because nobody has a mental model of thread pools, they have a mental
model of threads, and so then when you get those two closer together,
it means that debugging is easier.Nurkiewicz: I really love the quote
by Cay Horstmann, that you're no longer thinking about this low level
abstraction of a thread pool, which is convoluted. You have a bunch
of threads that are reused. There's a queue, you're submitting a
task. It stands in a queue, it waits in that queue. You no longer
have to think about it. You have a bunch of tasks that you need to
run concurrently. You just run them, you just create a thread and get
over it. That was the promise of actor systems like Akka, that when
you have 100,000 connections, you create 100,000 actors, but actors
reuse threads underneath, because that's how JVM works at the moment.
With virtual threads, you just create a new virtual thread per
connection, per player, per message, whatever. It's closer,
surprisingly, to an Erlang model, where you were just starting new
processes. Of course, it's really far away from Erlang still, but
it's a little bit closer to that.Cummins: Do you think we're going to
see a new world of problem reproduction ickiness, where some of us
are on Java 19 and taking advantage of threads, and some of us are
not. At the top level, it looks similar, but then once you go
underneath the behavior is really fundamentally different. Then we
get these non-reproducible things where it's the timing dependency
plus a different implementation means that we just spend all our time
chasing weird threading variations.Nurkiewicz: I can give you even a
simpler example of when it can blow up. We used to rely on the fact
that thread pool is the natural way of throttling tasks. When you
have a thread pool of 20 threads, it means you will not run more than
20 tasks at the same time. If you just blindly replace
ExecutorService with this virtual thread, ExecutorService, the one
that doesn't really pull any threads, it just starts them like crazy,
you no longer have this throttling mechanism. If you naively refactor
from Java 18 to Java 19, because Project Loom was already merged to
project 19, to the master branch. If you just switch to Project Loom,
you will be surprised, because suddenly, the level of concurrency
that you achieve on your machine is way greater than you expected.You
might think that it's actually fantastic because you're handling more
load. It also may mean that you are overloading your database, or you
are overloading another service, and you haven't changed much. You
just changed a single line that changes the way threads are created
rather than platform, then you move to the virtual threads. Suddenly,
you have to rely on these low level CountDownLatches, semaphores, and
so on. I barely remember how they work, and I will either have to
relearn them or use some higher level mechanisms. This is probably
where reactive programming or some higher level abstractions still
come into play. From that perspective, I don't believe Project Loom
will revolutionize the way we develop software, or at least I hope it
won't. It will significantly change the way libraries or frameworks
can be written so that we can take advantage of them.

# Web Tech, sof Arch:  Apache ShenYu: Java Responsive API Gateway Announced as Apache Top-Level Project
  https://www.infoq.com/news/2022/09/shenyu-gateway/ 

# JEP 429: Extent-Local Variables to Promote Immutability in Java
  https://www.infoq.com/news/2022/09/extent-local-variables-java/

# Announcing Conclave SDK 1.3 and Open Source
  https://www.conclave.net/blog/announcing-conclave-sdk-1-3-and-open-source
We are pleased to announce the release of version 1.3 of the Conclave
SDK. This is an important milestone for confidential computing as it
enables confidential workloads in the cloud with the KDS. You can
find out more about the KDS, what it is and how you can benefit from
it, in the release notes, along with all the other fixes and
improvements in 1.3.
However, that’s not all! 1.3 is also the first release of the core
SDK to be open source. We are pleased to announce the SDK code is
publicly available under Apache 2.0 and is available for you to
download or view at https://github.com/R3Conclave/conclave-core-sdk.
Before we explain why we’ve open sourced the Conclave SDK, perhaps
this is the first time you’re hearing of Conclave or confidential
computing.What is Conclave?
Conclave is R3’s privacy preserving platform enabling you to write
secure confidential applications with ease. With the core SDK you can
create Intel® SGX enclaves using high-level languages such as Java,
Kotlin, and JavaScript. It has a simple but powerful high-level API
which hides the low-level complexities of using SGX so that you can
spend more time concentrating on your enclave’s business logic. The
core SDK also powers Conclave Cloud, our privacy-preserving SaaS
platform for deploying confidential even-driven workloads in the
cloud.
Confidential computing protects data at rest and in transit as well
as during processing. Trusted Execution Environments (TEEs) such as
SGX use hardware to provide a secure region of the CPU, an enclave,
in which code and data are physically isolated and cannot be tampered
with, not even by the system or cloud administrator. It enables use
cases which were previously not possible, such as sharing of
confidential data for analysis or fraud detection.Why have we open
sourced Conclave?
Confidential computing is all about trust. It is about removing the
need to trust your cloud service provider, or your application
service provider, or any software stack in between. This includes
R3’s Conclave. We are open sourcing so that you can verify and
audit Conclave yourself and remove R3 from your trust model.
We also feel it’s vitally important that we build and grow a
community around Conclave, and that is best achieved when the product
is open source. By increasing transparency and allowing
accessibility, we want to foster collaboration within the ecosystem
to boost innovation and accelerate the adoption of confidential
computing technologies.  
Involving the community in the development of Conclave makes sure we
are building the right toolkit for our users. To that end, we would
love to hear your thoughts and suggestions and we can’t wait to see
your contributions to make Conclave even better. Hit us up on our
Discord or mailing list and share your ideas with us, and if you have
contributions you’d like to make then have a read of our
contribution guidelines.Next steps
If this is the first time you’re hearing of Conclave, then no
worries! Download our hello world sample and see how easy it is to
build enclaves in languages like Java and Kotlin. If you have already
used Conclave before, then you’ll be pleased to know that using
Conclave is now even easier. Have a read of our release notes and
learn about the improvements and new features we’ve added in 1.3.
Java and Kotlin are just the beginning. We want to expand the
Conclave API to other programming languages as well. If you like what
you see with Conclave but find it lacking due to it not supporting
your language of choice, then do let us know. Or if you find any bugs
or have suggestions for other improvements, then ping us on Discord
or GitHub.
Happy coding!

# spring: https://www.reddit.com/r/java/comments/zlnhbz/just_a_command_line_toolkit_for_developing_spring/

# Ver "Programmer's Guide to JDK Flight Recorder" en YouTubehttps://youtu.be/K1ApBZGiT-Y

# Resilience4j 2.0.0 Delivers Support for JDK 17
  https://www.infoq.com/news/2022/12/resilience4j-2-0-0/

# Consolidated JDK 19 Release Notes
  https://www.oracle.com/java/technologies/javase/19all-relnotes.html

# quartz alternatives, batch, schedule task runners "cron".
  https://www.reddit.com/r/java/comments/zariyv/is_quartz_abandoned/See alternatives

# JVM Options Explorer - OpenJDK11 HotSpot 101https://chriswhocodes.com/ 

# https://github.com/ben-manes/caffeine  [[{scalability.cache]]
  high performance, near optimal caching library.
  LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
      .maximumSize(10_000)
      .expireAfterWrite(Duration.ofMinutes(5))
      .refreshAfterWrite(Duration.ofMinutes(1))
      .build(key -> createExpensiveGraph(key));

  - Features:
    - automatic loading of entries into cache: optionally asynchronously
    - size-based eviction: when a maximum is exceeded based on frequency and recency
    - time-based expiration of entries, measured since last access or last write
    - asynchronously refresh when the first stale request for an entry occurs
    - keys automatically wrapped in weak references
    - values automatically wrapped in weak or soft references
    - notification of evicted (or otherwise removed) entries
    - writes propagated to an external resource
    - accumulation of cache access statistics

  - Community provided integration:
    - Play Framework: High velocity web framework
    - Micronaut: A modern, full-stack framework
    - Spring Cache: As of Spring 4.3 & Boot 1.4
    - Quarkus: Supersonic Subatomic Java
    - Scaffeine: Scala wrapper for Caffeine
    - ScalaCache: Simple caching in Scala
    - Camel: Routing and mediation engine
    - JHipster: Generate, develop, deploy
    - Aedile: Kotlin wrapper for Caffeine
  [[}]]


# Thorben Janssen  (newsletter)
  """
  Domain Driven Design (DDD) adoption has massively grown.
   One of the reasons is that the concept of "bounded-contexts" fits incredibly
  well with microservices-design .... You will soon recognize some of the
  DDD's design principles ovelaping with JPA:
    Both use entities, identifiers, and value objects.
  - Do they really mean the same in both contexts?
  - What about DDD's concept of an aggregate? (1+ entities):
     This might sound like you shouldn't use JPA if you want to follow DDD
     design principles. But that's not the case. They actually fit very
     well together if you follow a few simple rules when implementing your
     JPA entity mappings.
  """

# Spring Shell Reference Documentation
  https://docs.spring.io/spring-shell/docs/3.0.0/docs/index.html

# Eclipse Migration Toolkit for Java (EMT4J) [[{]]]
  Adoptium has introduced the Eclipse Migration Toolkit for Java
  (EMT4J), an open source Eclipse project capable of analyzing and
  upgrading applications from Java 8 to Java 11 and from Java 11 to
  Java 17. EMT4J will support upgrading to future LTS versions.

  https://www.infoq.com/news/2022/12/eclipse-migration-toolkit-java/
[[}]]

# Profiler in 240 Lines of Pure Java [[{JAVA_LANG.PROFILING]]
  https://foojay.io/today/writing-a-profiler-in-240-lines-of-pure-java/
  JVM safepoint: point in time where the JVM has a known defined
state, and all threads have stopped. JVM itself needs safepoints to
do major garbage collections, Class definitions, method
deoptimizations, and more. Threads are regularly checking whether
they should get into a safepoint, for example, at method entry, exit,
or loop backjumps. A profiler that only profiles at a safepoint have
an inherent bias because it only includes frames from the locations
inside methods where Threads check for a safepoint. The only
advantage is that the stack-walking at safepoints is slightly less
error-prone, as there are fewer mutations of heap and stack.
Further read: Java Safepoint and Async Profiling by Seetha Wenner,
the more technical one by JP Bempel, or the classic article
Safepoints: Meaning, Side Effects and Overheads by Nitsan Wakart. To
conclude: Safepoint-biased profilers don't give you a holistic view
of your application, but can still be helpful to analyze major
performance issues where you look at the bigger picture.This article
aims to develop a tiny Java profiler in pure Java code that everyone
can understand. Profilers are not rocket science, and ignoring
safepoint-bias, we can write a usable profiler that outputs a flame
graph in just 240 lines of code.You can find the whole project on
GitHub.
[[}]]
------------------------------------------------

# JEP 444: Virtual Threads Arrive in JDK 21 2023-05 [[{scalability.101]]
  Ushering a New Era of Concurrency
  https://www.infoq.com/news/2023/04/virtual-threads-arrives-jdk21/ [[scalability,concurrency]]

Virtual Threads, promoted from Candidate to Proposed to Target status for JDK 21.

finalize based on feedback from the previous two rounds of preview:
JEP 436, Virtual Threads (Second Preview), delivered in JDK 20;
JEP 425, Virtual Threads (Preview), delivered in JDK 19.

Java now has two types of threads:
- traditional threads, platform or OS "wrapper" threads
- virtual threads:  "many" virtual threads per OS thread.
  OFFERING COMPATIBILITY WITH EXISTING JAVA CODE
 path to benefit from enhanced performance and resource
utilization. Consider the following example:try (var executor =
Executors.newVirtualThreadPerTaskExecutor()) { IntStream.range(0,
10_000).forEach(i -> { executor.submit(() -> {
Thread.sleep(Duration.ofSeconds(1)); return i; }); });}The JDK can
now run up to 10,000 concurrent virtual threads on a small number of
operating system (OS) threads, as little as one, to execute the
simple code above that involves sleeping for one second.Virtual
threads are designed to work with thread-local variables and
inheritable thread-local variables, just like platform threads.
However, due to the large number of virtual threads that can be
created, developers should use thread-local variables with caution.
To assist with the migration to virtual threads, the JDK provides a
system property, jdk.traceVirtualThreadLocals, that triggers a stack
trace when a virtual thread sets the value of any thread-local
variable.The java.util.concurrent package now includes support for
virtual threads. The LockSupport API has been updated to gracefully
park and unpark virtual threads, enabling APIs that use LockSupport,
such as Locks, Semaphores, and blocking queues, to function
seamlessly with virtual threads. The
Executors.newThreadPerTaskExecutor(ThreadFactory) and
Executors.newVirtualThreadPerTaskExecutor() methods provide an
ExecutorService that creates a new thread for each task, facilitating
the migration and interoperability with existing code that uses
thread pools and ExecutorService.Networking APIs in the java.net and
java.nio.channels packages now support virtual threads, enhancing
efficiency in concurrent applications. Blocking operations on a
virtual thread free up the underlying platform thread, while I/O
methods in the Socket, ServerSocket and DatagramSocket classes have
been made interruptible. This update promotes consistent behavior and
improved performance for Java developers working with concurrent
applications.The java.io package, which provides APIs for streams of
bytes and characters, has been updated to avoid pinning when used in
virtual threads. Pinning in virtual threads refers to a lightweight
thread being "stuck" to a specific platform thread, limiting
concurrency and flexibility due to blocking operations.
BufferedInputStream, BufferedOutputStream, BufferedReader,
BufferedWriter, PrintStream, and PrintWriter now use an explicit lock
instead of a monitor when used directly. The stream decoders and
encoders used by InputStreamReader and OutputStreamWriter now use the
same lock as their enclosing InputStreamReader or
OutputStreamWriter.Java Native Interface (JNI) has introduced a new
function, IsVirtualThread, to test if an object is a virtual thread.
The JNI specification otherwise remains unchanged.The debugging
architecture, consisting of the JVM Tool Interface (JVM TI), the Java
Debug Wire Protocol (JDWP), and the Java Debug Interface (JDI), has
been updated to support virtual threads. All three interfaces now
support virtual threads, with new capabilities and methods added to
handle thread start and end events and bulk suspension and resumption
of virtual threads.JDK Flight Recorder (JFR) now supports virtual
threads with new events such as jdk.VirtualThreadStart,
jdk.VirtualThreadEnd, jdk.VirtualThreadPinned, and
jdk.VirtualThreadSubmitFailed. These events provide insight into the
behavior of virtual threads in the application.Java Management
Extensions (JMX) will continue to support only platform threads
through the ThreadMXBean interface. A new method in the
HotSpotDiagnosticsMXBean interface generates the new-style thread
dump to support virtual threads.While virtual threads bring
significant performance improvements, developers should be aware of
compatibility risks due to changes in existing APIs and their
implementations. Some of these risks include revisions to the
internal locking protocol in the java.io package and source and
binary incompatible changes that may impact code that extends the
Thread class.Virtual threads mark a significant milestone in Java's
journey to support highly concurrent and scalable applications. With
a more efficient and lightweight threading model, developers can now
handle millions of tasks with ease and better utilize system
resources. Developers can leverage more details on JEP 425, which can
be found in this InfoQ news story and this JEP Café screen cast by
José Paumard, Java developer advocate with the Java Platform Group
at Oracle.

[[}]]

# Billions of Messages Per Minute Over TCP/IP [[{io.serialization,io.scalability,scalability.network,JVM,]]
  https://www.infoq.com/articles/billions-messages-minute/ 
  Chronicle Wire library: provides high-performance transformations
  of state in Java objects between their internal JVM representation
  and a format that allows that state to be persisted or communicated
  to another Java process.  
  It grew from Chronicle Queue project, which offers single digit
  microsecond latencies for messaging between JVMs on the same machine,
  or stable latencies of tens of microseconds between machines,
  as throughput scales to millions of messages per second.
[[}]]

# Java's Collections Framework Gets a Makeover  [[{data_structures]]
  https://www.infoq.com/news/2023/03/collections-framework-makeover/
  New Sequenced Collection Types
[[}]]

# VertX Mutiny Zero by Julien Ponge
  Quarkus Insights 120
  https://www.linkedin.com/feed/update/activity:7038552356413693952

  latest developments around Mutiny, Mutiny Zero and switching from legacy Reactive Streams to JDK Flow.
  https://www.youtube.com/watch?v=RRs4DJJUSx8

#  gradle 8.0 GA release [[{DEVOPS.GRADLE]]
- enhancements to Kotlin DSL (alternative to Groovy DSL).
- upgrades to Kotlin 1.8 and JDK 11.
- improvements in buildSrc builds;
- configuration cache: incubating new feature
- improvements in Java toolchains.
- Shortly after the GA release, a patch release, Gradle 8.0.1,
  provides fixes for these issues:
[[}]]

# WireMock Spring Boot Simplifies WireMock Configuration [[{SPRING.testing]]
  https://www.infoq.com/news/2023/03/wiremock-spring-boot/
[[}]]
[[java,01_PM.TODO}]]


* Recheck tool Guides: java launcher, keytool

* java.lang.StrictMath

* Java poco a poco ha ido adoptando patrones funcionales  ...
  En el caso de los tipos algebraicos (ADT) casi en silencio,
  Primero fueron los records, después sealed class/interface 
  finalmente soporte completo en Java 21 con Pattern Matching y 
  Record Pattern. ...  explicaremos que son los tipos algebraicos,
  y el soporte en JAVA, la creación de DSLs, estructuras de
  datos inmutables como listas, o codificación de efectos de
  lado como Optionals, o Try.

_____________________________________________________________
Understanding class loadinghttps://docs.oracle.com/javase/tutorial/ext/basics/load.html
_________________________JAVA CrAC Project: Coordinate and Restore Checkpoin in JVMhttps://wiki.openjdk.org/display/crac [[{Performance}]]_______________________________Spring 3.2 add support for Virtual Threadshttps://www.infoq.com/news/2023/12/spring-boot-virtual-threads/

RestClient, a modern alternative to RestTemplate, is a synchronous HTTP client introduced in Spring Framework 6.1. Spring Boot will now create and pre-configure bean RestClient.Builder to create RestClient instances. It offers a functional style API like its counterpart, WebClient, in Spring WebFlux. One main advantage of using RestClient is that there is no need to add the additional dependency on Spring WebFlux to call remote REST APIs.The Spring team recommends using RestClient to call remote REST services unless Spring WebFlux or Project Reactor is in use, in which case WebClient is the suggested choice.

There has never been a better time to be a Spring and Java developer. Spring Boot 3.2 delivers huge runtime efficiencies with Project CRaC support (available in certain distributions of OpenJDK) and Project Loom, available as of Java 21.

https://openjdk.org/projects/crac/
The CRaC (Coordinated Restore at Checkpoint) Project researchescoordination of Java programs with mechanisms to checkpoint (makean image of, snapshot) a Java instance while it is executing.Restoring from the image could be a solution to some of theproblems with the start-up and warm-up times. The primary aim ofthe Project is to develop a newstandard mechanism-agnostic API to notify Java programs about thecheckpoint and restore events. Other research activities willinclude, but will not be limited to, integration with existingcheckpoint/restore mechanisms and development of new ones, changesto JVM and JDK to make images smaller and ensure they arecorrect.___________________________________________Java Helidon 4 Adopts Virtual Threads: Explore the Increased Performance and Improved DevExhttps://www.infoq.com/articles/helidon-4-adopts-virtual-threads/ 
The biggest challenge now is "to unlearn reactive"!--------------------------------------------
Java java.util.concurrent decission tree Can you show me a decission tree to pick up the most suitable object or or locking primitive or algorithm among the existing ones in the java.utils.concurrent package?ChatGPTI can't display visual diagrams directly, but I can guide you through a decision process to select a suitable object, locking primitive, or algorithm from the java.util.concurrent package in Java.Firstly, it's essential to consider what you need:Synchronization: If you need a simple locking mechanism to synchronize access to a shared resource, you might consider synchronized keyword, ReentrantLock, or ReadWriteLock.Concurrency control: If you need more advanced concurrency control, consider Semaphore, CountDownLatch, CyclicBarrier, or Phaser.Data structures: If you need thread-safe data structures, you could explore ConcurrentHashMap, ConcurrentLinkedQueue, CopyOnWriteArrayList, or BlockingQueue implementations (ArrayBlockingQueue, LinkedBlockingQueue, etc.).Task execution: For executing tasks concurrently, consider ExecutorService, ThreadPoolExecutor, or ForkJoinPool.Choosing the right one depends on the specific use case, level of concurrency needed, the nature of data sharing, and performance requirements. If you can provide more details about your scenario, I can offer more precise guidance! The scenario consist of an state machine that different threads want to update at random instants. Each update must be atomic and all threads must see the last updated state before trying to update it themself. ChatGPTFor an atomic update of a state machine where multiple threads need to see the latest state before updating it themselves, you might consider using:ReentrantReadWriteLock: It allows multiple threads to read the state concurrently while ensuring exclusive write access.AtomicReference or volatile variables: These can help in ensuring visibility of the latest state across threads.Here's a basic approach:Use AtomicReference to hold the state machine object.Implement a ReentrantReadWriteLock to control access. Multiple threads can concurrently read the state (using the read lock), but only one thread can write to it at a time (using the write lock).This combination ensures that threads can see the latest state before performing updates while allowing multiple concurrent reads.Remember to synchronize access to the state machine using these constructs to ensure thread safety and atomic updates----------------------------------------------------
Java, what is the difference between a monitor and a lockhttps://stackoverflow.com/questions/49610644/in-java-what-is-the-difference-between-a-monitor-and-a-lock 
LocksA lock is kind of data which is logically part of an object’s header on the heap memory. Each object in a JVM has this lock (or mutex) that any program can use to coordinate multi-threaded access to the object. If any thread want to access instance variables of that object; then thread must “own” the object’s lock (set some flag in lock memory area). All other threads that attempt to access the object’s variables have to wait until the owning thread releases the object’s lock (unset the flag).Once a thread owns a lock, it can request the same lock again multiple times, but then has to release the lock the same number of times before it is made available to other threads. If a thread requests a lock three times, for example, that thread will continue to own the lock until it has “released” it three times.Please note that lock is acquired by a thread, when it explicitly ask for it. In Java, this is done with the synchronized keyword, or with wait and notify.MonitorsMonitor is a synchronization construct that allows threads to have both mutual exclusion (using locks) and cooperation i.e. the ability to make threads wait for certain condition to be true (using wait-set).In other words, along with data that implements a lock, every Java object is logically associated with data that implements a wait-set. Whereas locks help threads to work independently on shared data without interfering with one another, wait-sets help threads to cooperate with one another to work together towards a common goal e.g. all waiting threads will be moved to this wait-set and all will be notified once lock is released. This wait-set helps in building monitors with additional help of lock (mutex).For more clarification refer -UNDERSTANDING THREADS, MONITORS AND LOCKSDifference between lock and monitor – Java Concurrency-------------------------------------------------------
Java leaningtech/cheerpj-meta: Browser JVM replacement for Java applications, applets, JNLP, Web Starthttps://github.com/leaningtech/cheerpj-meta 
-------------------------------------------------------Gatling Supports Java DSL for Java and Kotlin-Based Performance Testshttps://www.infoq.com/news/2023/09/gatling-java-dsl/ 
--------------------------------------Java 21 + grallvm tutorial 101https://spring.io/blog/2023/09/20/hello-java-21 
------------------------------------------
JDK 21 and JDK 22: What We Know So Farhttps://www.infoq.com/news/2023/09/java-21-so-far/ 
Java 21 whats new
----------------------------------Streamlining Code with Unnamed Patterns/Variables: A Comparative Study of Java, Kotlin, and Scalahttps://www.infoq.com/articles/comparative-study-java-kotlin-scala/?itm_source=infoq&itm_medium=popular_widget&itm_campaign=popular_content_list&itm_content=--------------------------------------java CompletableFuture allOf().join() vs CompletableFuture.join()
https://www.baeldung.com/java-completablefuture-allof-join?__s=aw56zebktqtoti1yt59p


Difference Between Map.clear() and Instantiating a New Map
A quick and practical comparison between Map.clear() and creating a new Map.

How to Get Notified When a Task Completes in Java Executors
Learn several options for receiving notifications on the completion of a task depending on how you're running it.

CompletableFuture allOf().join() vs. CompletableFuture.join()
Explore CompletableFuture.allOf() method and the differences between it and calling join() on multiple separate CompletableFuture instances.

What Is the Maximum Depth of the Java Call Stack?
Learn how to determine the maximum depth of the Java call stack.---------------------------------------------Java Gets a Boost with the Record Pattern, Enabling More Expressive Codinghttps://www.infoq.com/news/2023/05/java-gets-boost-with-record/-------------------------------------------https://www.baeldung.com/java-completablefuture-non-blocking  
OverviewHaving high performance and availability are essential parts of modern software development.One way to achieve this is through non-blocking and asynchronous programming. In Java, the CompletableFuture class provides a way to write non-blocking code. But is it truly non-blocking?In this tutorial, we’ll examine the situations when CompletableFuture is blocking and when it is non-blocking.2. CompletableFutureFirstly, let’s take a brief look at CompletableFuture class. It’s a powerful class introduced in Java 8 as part of the Concurrent API.Moreover, it implements the Future interface and represents the primary implementation of the CompletionStage interface. Thus, it offers nearly 50 different methods for creating and executing asynchronous computations.Why did we need CompletableFurure in the first place? Using the Future interface, we could only retrieve the result by calling the get() method. However, this method represents a blocking operation. In other words, it’ll block the current thread until the result of the task becomes available.If we need to perform additional actions on the result, we’ll end up with blocking operations.On the other hand, thanks to CompletionStage, CompletableFuture provides the ability to chain multiple computations together that can run concurrently. This functionality allows us to create a chain of tasks where the next task is triggered when the current task is completed.Furthermore, we can specify what should happen once we get the result from the future without blocking the current thread.The CompletableFuture class represents both the stage in dependent processes, where one stage's completion triggers another, and its result.3. Blocking vs. Non-blockingNext, let’s understand the difference between blocking and non-blocking processing.In the blocking operation, the calling thread waits until the operation in another thread completes before continuing with its execution:  Here, the tasks execute sequentially. Thread 1 is blocked by Thread 2. In other words, Thread 1 can’t continue with its execution until Thread 2 finishes processing its tasks.We can look at the blocking processing as synchronous operations.However, blocking operations in our system can cause performance issues, especially in applications that require high availability and scalability.In contrast, a non-blocking operation allows threads to perform multiple computations simultaneously without having to wait for each task to complete.The current thread can continue with its execution while the other threads perform tasks in parallel: In the example above, Thread 2 isn't blocking the execution of Thread 1. Furthermore, both threads are running their tasks concurrently.Besides improving the performance, we can decide what to do with the result once the non-blocking operation finishes with execution.4. CompletableFuture and Non-blocking OperationsThe main advantage of using CompletableFuture is its ability to chain multiple tasks together that will be executed without blocking the current thread. Therefore, we can say the CompletableFuture is non-blocking.Additionally, it provides several methods that allow us to perform tasks in a non-blocking way, including:supplyAsync(): executes a task asynchronously and returns a CompletableFuture representing the resultthenApply(): applies a function to the result of a previous task and returns a CompletableFuture representing the transformed resultthenCompose(): executes a task that returns a CompletableFuture and returns a CompletableFuture representing the result of the nested taskallOf(): executes several tasks in parallel and returns a CompletableFuture representing the completion of all tasksNext, let’s see a simple example. For instance, suppose we have two tasks we’d like to execute as non-blocking:CompletableFuture.supplyAsync(() -> "Baeldung") .thenApply(String::length) .thenAccept(s -> logger.info(String.valueOf(s)));After the task completes, it'll print the number 8 on the standard output.The computation runs in the background and returns a future. If we have multiple dependent actions, each action is represented by the stage. After one stage completes, it triggers the computation of other dependent stages.5. When Is CompletableFuture Blocking?Although CompletableFuture is used to perform non-blocking operations, it can still end up blocking the current thread in certain scenarios.In asynchronous communication, we usually have a callback mechanism to retrieve the result of the computation. However, CompletableFuture doesn't notify us upon its completion.If needed, we can retrieve the result in the calling thread using the get() method.Nevertheless, we need to be aware the get() method returns the result using blocking processing. If required, it waits for the computation to complete and then returns the result.Therefore, we’ll end up blocking the current thread until the future completes:CompletableFuture<String> completableFuture = CompletableFuture .supplyAsync(() -> "Baeldung") .thenApply(String::toUpperCase);assertEquals("BAELDUNG", completableFuture.get());Similarly, calling the join() method will block the current thread as well:CompletableFuture<String> completableFuture = CompletableFuture .supplyAsync(() -> "Blocking") .thenApply(s -> s + " Operation") .thenApply(String::toLowerCase);assertEquals("blocking operation", completableFuture.join());The main difference between these two methods is that the join() method doesn’t throw checked exceptions if the future completes exceptionally.Additionally, we can call the isDone() method to check whether the future is completed before obtaining the result.However, when it's necessary to obtain the computation result in the calling thread, we can create CompletableFuture, do other work in the current thread, and then call the get() or join() method. By giving it more time, it's more likely the Future will finish with computations before we get the result. But there's still no guarantee that the retrieval won't end up blocking the thread.6. ConclusionIn this article, we examined the scenarios when CompletableFuture is non-blocking and when it’s not.To sum up, CompletableFuture is non-blocking most of the time. However, if we call the get() or the join() methods to retrieve the result, they will block the current thread.As always, the entire source code is available over on GitHub.Get started with Spring 5 and Spring Boot 2, through the Learn Spring course:>> CHECK OUT THE COURSE
____________________________________
Java: Unleash the Power of Open Source Java Profilers: Comparing VisualVM, JMC, and async-profilerhttps://www.infoq.com/articles/open-source-java-profilers/ 
There are three major open-source profilers with different pros and cons: a simple profiler (VisualVM), a hackable profiler with lots of features (async-profiler), and a built-in profiler which obtains lots of additional information (JMC)

a slightly imprecise but easy-to-use tool with a simple UI (VisualVM)a built-in tool with information on GC and more (JFR)a tool that has lots of options and can show information on C/C++ code (async-profiler)
_____________________________ 
Which tools and technologies are new and exciting, proven, growing stale–report from Devoxx 2022	 Lucas Jellema October 14, 2022 Read Time:20 Minute, 3 Second
# JBang – install, manage and run Java with great ease, as a scripting language ? with an app store? – 
https://jbang.dev/ 
_____________________________ 
JReleaser – https://jreleaser.org/ – quick effortless way to release Java project! (Homebrew, Scoop, Chocolatey, Snapcraft, and others)
_____________________________ 
Git alternatives: Fossil, Plastic, Pijal  
_____________________________ 
https://meet.jit.si/: free tool for online meetings (Teams style)
_____________________________ 
JHipster Lite: next gen JHipster (JHipster LIte)for hexagonal (microservices) architectures. 
It still uses Spring Boot as the foundation for the backend of the application 
(although Quarkus was also mentioned as an option). Unlike traditional JHipster, Lite can
be used for non-web-applications as well.
_____________________________ 
gVisorEspresso – Java on Java (supported by GraalVM Truffle).
The Truffle framework allows programs written in various languages to 
all be executed on the same engine – often better than in their 
original runtimes – and also interact (interoperate) with each other. 
Recently Java was added to the collection of languages supported by 
Truffle. Code named Espresso – Java can now run on Truffle, similar 
to JavaScript, Python, WebAssembly, Ruby and others. And it is not 
just Java but other JVM languages as well, such as Scala and Kotlin. 
Medium Article on Java on Truffle.Dockerode – npm module for 
programmatic control of Docker containers  
https://github.com/apocas/dockerode Htmx (no) JavaScript webapps – 
access to AJAX, CSS Transitions, WebSockets and Server Sent Events 
directly in HTML, using attributes, so you can build modern user 
interfaces with the simplicity and power of hypertext – 
https://htmx.org/ CRaC (Coordinated Restore at Checkpoint) snapshot 
java applications while they execute – for fast startup from the 
initialized state. https://openjdk.org/projects/crac/ (Similar to 
criu for containers check https://criu.org/Docker, see for example 
https://blog.openj9.org/2022/09/26/fast-jvm-startup-with-openj9-criu-s
upport/ on OpenJ9 CRIU) https://www.sigstore.dev/: standardized 
auto.process for digitally signing OOSS project releases  
https://github.com/SigStore/cosign – Container Signing, Verification 
and Storage in OCI registry.Rekor – https://github.com/sigstore/rekor 
– enables software maintainers and build systems to record signed 
metadata to an immutable record. Other parties can then query said 
metadata to enable them to make informed decisions on trust and non-
_____________________________ 
Flowable – workflow engine (similar to Camunda’s products?) support bpmn, cmmn and dmn – https://github.com/flowable/flowable-engine 
 Error Prone (and refaster) (https://errorprone.info/) – (from Google) Using Error Prone to augment the compiler’s type analysis, you can catch more mistakes before they cost you time, or end up as bugs in production.Kcctl – kafka connect CLI – https://github.com/kcctl/kcctlMelrōse, a language to program and play music
_____________________________ 
 – https://ernestmicklei.com/melrose/introduction_melrose/Mustache Template
Language for creating dynamic content like HTML, configuration files – https://mustache.github.io/;
Baeldung: https://www.baeldung.com/mustache

________________________________
 OpenTelemetry – standard for publishing telemetry; SDKs for auto-instrumenting applications (client web, Java, .NET and others are coming) – https://opentelemetry.io/ OpenTelemetry is a collection of tools, APIs, and SDKs. Use it to instrument, generate, collect, and export telemetry data (metrics, logs, and traces) to help you analyze your software’s performance and behavior. Note: for Java, all SQL interactions are individually tracked and reported!Front End & User ExperienceQwik and partytown – very quick starting webapps – https://www.builder.io/blog/how-we-cut-99-percent-js-with-qwik-and-partytown  Partytown is used to move all third-party scripts to web-worker. Qwik – offers the fastest possible page load times. As users interact with the site, only the necessary parts of the site load on-demand. This precision lazy-loading is what makes Qwik so quick. https://github.com/builderio/qwikWebrtc – standard browser technology for direct communications between browsers (peer to peer)– for example for video, audio/voice, JavaScript APIs are available in major browsers  https://webrtc.org/Webpack Module Federation – the foundation for Microfrontends – https://webpack.js.org/concepts/module-federation/Workbox – npm module for ServiceWorkers – https://developer.chrome.com/docs/workbox/ Project Fugu – WebCapabilities https://www.chromium.org/teams/web-capabilities-fugu/  and demo apps: https://developer.chrome.com/blog/fugu-showcase/ Flaticon – collection of icons – including a large free library – https://www.flaticon.com/iconsWebAlmanac – The Web Almanac 2022 (published in September) is a comprehensive report on the state of the web. Also read this overview article: https://www.stefanjudis.com/blog/web-almanac-highlights-2022/StackBlitz – IDE & Node environment running inside the browser (powered by WebContainers on WebAssembly) – web app development fully browser basedRunKit – Node playground – https://npm.runkit.com/playground – It runs a full Node.js environment and already has all of npm’s 1,000,000+ packages pre-installedXKCD – https://xkcd.com/ – xkcd, sometimes styled XKCD, is a webcomic created in 2005 by American author Randall Munroe. you’re free to copy and share these comics (but not to sell them). And several conference presenters used cartoons from this site.Pexels – https://www.pexels.com/ – free stock photos, royalty free images & videos shared by creators: another source of images used by presentersExcalidraw – https://github.com/excalidraw  Excalidraw is a whiteboard tool that lets you easily sketch diagrams that have a hand-drawn feel to them. VS Code extension available.Developer Experiencehttps://backstage.spotify.com/ – framework for creating a Developer Portal. Create at Spotify. SDKMan – CLI for easy installing of and switching between different versions of JDK and other SDKs and libraries https://sdkman.io/Gitpod – a SaaS that provides a cloud based development environment – Linux VM with VS Code, 12 language runtimes and 25 additional tool pre-installed. It has a max of 12 GB RAM, plenty of diskspace. It is by far the quickest way to get started exploring any technology or running a tutorial or workshop. Gitpod accounts are created using a GitLab or GitHub account. The free plan has 50 hours of Gitpod workspace usage per monthTesting and Code Quality https://github.com/openrewrite/rewrite – rewrite source code (Java and some others supported): Automated software refactoring to keep up-to-date with API changes, fix vulnerabilities, and improve code quality.Error-Prone (define BugChecks to find undesirable coding in your code base) and Refaster (automated refactoring at scale by fixing code patterns using before and after templates. See: https://github.com/google/error-prone Picnic announced its own open source project that builds on Error Prone and Refaster with dozens of bug checks and over 500 refaster templates to improve the code: https://blog.picnic.nl/picnic-open-sources-error-prone-support-b23f9a7208b6 A concept bound to become quickly more important: the SBOM – software bill of materials. The register of all dependencies of an application – direct and indirect. Along with version and status (open source activity, commercial support, vulnerabilities, community “opinion”) for each dependency. To actively manage dependencies.Bots to scan the code base for outdated (newer versions are available) and vulnerable (CVEs are known for the currently used versions of libraries) dependencies and recommend and sometimes even apply upgrades to newer (stable) and safe versions. Available for use on GitHub (and perhaps GitLab in some cases): DependaBot, Renovate and Snyk.Playwright – test automation for end to end testing of web applications through browser automation (also for RPA) – programmatically accessible from Java, Node, Python and .Net. Watch Devoxx presentation by Alex Soto. To me it feels much easier and lighter wait than using SeleniumPact – Contract Testing: test all known interactions from specific consumers with “service providers (such as APIs)” https://docs.pact.io/ –Testcontainers – programmatically spin up containers to provide dependencies in integration tests – https://github.com/testcontainersFuzzing – a testing technique where large numbers of generated inputs are used in testing software – to find weak spots. A new feature in Go 18 (presented by Valentin Deleplace in this session https://youtube.com/watch?v=Zlf3s4EjnFU…)  and available for other languages through OSS-Fuzz. Fuzzing feels a little related to chaos engineering – though at a different (functional) level.Hey – for quickly generating load on an HTTP endpoint (demonstrated by Thomas Wuerthinger in his GraalVM talk) – see https://github.com/rakyll/heyAlso of course: JMeter, Gatling for load testingArchUnit  – https://www.archunit.org/ – to unit test (quality inspect feels a better word) Java applications in terms of “architecture”: forbidden class imports across packages in different layers or services (leading to lack of encapsulation and uncontrolled or undesired such as cyclic dependencies)Mutability (or Mutation) Testing – Faults (or mutations) are automatically seeded into your code, then your tests are run. If your tests fail then the mutation is killed, if your tests pass then the mutation lived – and the coverage of your tests is not optimal. In Java for example with http://pitest.org/ Rest-Assured – Testing and validating REST services in Java  https://rest-assured.io/ – see Rest API Testing (Automation) from Scratch -RestAssured Java course by Rahul Shetty on UdemyC4 model for visualizing software architecture – https://c4model.com/DataThe very broad topic of data – a mixed bag of tools and technologies to take a loot at:Trino – Distributed sql query executed against various sources
 https://trino.io/ Cube.dev – headless BI (model data, expose through APIs for reporting and analysis) – https://cube.dev/QuestDB – time series database with fast SQL – https://questdb.io/ CrateDB – Yugabyte – a high-performance transactional distributed SQL database for cloud-native applications – https://www.yugabyte.com/ArrangoDB – free and open-source native graph database system; a multi-model database system (Graph, Key/Value, Document) https://www.arangodb.com/MicroStream – apparently is a smart way to serialize Java object graphs (to file) and to deserialize them again – applying ACID constraints on the data manipulations. For querying it is suggested that Java Collection Streams APIs are applied – as we are dealing with Java objects.JOOQ – generates Java code from your database and lets you build type safe SQL queries through its fluent API  – https://www.jooq.org/ (open source for open source databases, paid for paid for databases)Jakarta EE NoSQL – API (such as JPA) for interacting with NoSQL databases – http://www.jnosql.org/spec/AI – Models, Sites, ToolsOne of the big themes for me at Devoxx 2022 are the incredible things AI can do. Here are some references to tools/sites to take a look at:DiffBlue (Cover) – Smart unit test generation from code interpretation by AI – VS Code extension available – https://www.diffblue.com/community-edition/download/CodeGeeX – Code Generation – live demo https://huggingface.co/spaces/THUDM/CodeGeeX and self hosted:  https://github.com/THUDM/CodeGeeX Once Upon A Bot – story generation including graphics – https://onceuponabot.com/ And here is the story I had generated for me: https://onceuponabot.com/story/3a181967-0e7f-4e3e-a928-cb1ed5feb38b (it a bit of a tear jerker)OpenAI Playground – try out many different models and what they can produce – sign up (for free) at: https://beta.openai.com/signup , then go to the overview page: https://beta.openai.com/overview Generate images from text “prompts” using KerasCV (Python) – https://keras.io/guides/keras_cv/generate_images_with_stable_diffusion/ Google Imagen Video – https://imagen.research.google/video/ – generated videos from text prompt. At this moment only a research paper and a demo.Kubernetes centered tools:so many tools have come into existence around Kubernetes, this deserves to be its own category.Service Mesh Istio & Kiali for monitoring IstioKDash – a simple and fast dashboad for K8S container image scanning (Clair or Trivy)cluster policies (OPA or Kyverno) the de facto Kubernetes threat detection engine: observing activities in the cluster: Falcodynamically applying cluster resource changes in response to events (Argo CD). party image scanning (Dive ) image signing strategies Notary ProjectKubescape, Kube Hunter, Kube-Bench.Knative – serverless model on Kubernetes cluster (dynamic and event driven scaling)KEDA – Kubernetes Event Driven Auto Scaling – https://keda.sh/ (Ready to be) Widely AdoptedgRPC – faster, lower overhead interactions than traditional HTTP/REST. gRPC over HTTP/2 is well established and SDKs are available for all main programming languages. gRPC on HTTP/3 is currently only supported with an SDK for .NET; others will soon follow. Note that HTTP/3 itself was published as a standard only recently: June 2022.GraalVM Native Image – A major component under the GraalVM umbrella is the native image generator. It is the enabler of serverless Java (functions). It will drive down costs of running Java applications (and it will reduce the carbon emissions as a result of running Java applications because of the reduced resource usage). Take a Java application. Compile it into a runnable jar. Then set the native image generator to do its magic. The result is an executable. A file that can be executed. A file with no dependencies other than on the Operating System it was created for. An executable that when executed starts up blazingly fast and uses far less memory than the corresponding Java application on a JVM would. In most instances the performance of the application is (initially) better than Java on the JIT compiler (regular JVM). GraalVM 22.3 – to be released in the week of 17 October 2022 – supports Java 19, including Virtual Threads! While JDK 19 is not an LTS, you can start using Virtual Threads in your code, bake the native image and run the fantastic scalable concurrency in production if you want.Support for runtime operations is being added to the native image: JFR (flight recorder) and JMX will be supported. In IntelliJ there is the option to debug a native image – with mapping to the original Java source code. I have not seen it, but I am already impressed!Note: RedHat has created Mandrel (https://github.com/graalvm/mandrel) – a downstream distribution of the GraalVM community edition. Mandrel’s main goal is to provide a native-image release specifically to support Quarkus. The aim is to align the native-image capabilities from GraalVM with OpenJDK and Red Hat Enterprise Linux libraries to improve maintainability for native Quarkus applicationsPostgreSQL seems the relational database of choice – for microservices and many other data persistence and processing use cases. Where at one point MySQL seemed the default open source database – briefly challenged by MariaDB – it is now clearly PostgreSQL that is on everyone’s mind. October 13th 2022 saw the release of PostgreSQL 15. Note: a new SQL operation introduced in this release is … MERGE. (“This release improves the developer experience with the addition of the popular MERGE command”). I think PostgreSQL is great. However, some of the compatibility claims from vendors trying to seduce companies into migrations may be somewhat exaggerated. Enterprise Integration with 300 types of conectors, running on Quarkus (native image) and Knative: Camel (https://github.com/apache/camel) & Karavan (UI for editing routes – https://github.com/apache/camel-karavan)Apache Airflow – not really new, still exciting and probably very widely in use. Apache Airflow is a workflow orchestrating tool that comes with many operators in its box that make it easy to extract, process and load data from and into many different sources. As such it is widely used for ETL processes, data pipelines that integrate systems and feed data lakes and the like (somewhat similar to Azure Data Factory for example). Note that Airflow can orchestrate ADF pipeline (and perhaps vice versa). An Airflow process is a DAG (directed acyclic graph) described in a Python program. In the DAG, operators are connected in logical flows, handing (references to) data to operate on to each other.Grafana – everyone seems to be using Grafana for creating (IT operational) dashboards. Often using Prometheus as the metrics collector and database.Containers obviously are a key element of software development – for setting up development environments, integration tests, build and delivery pipelines and as delivery and runtime format. It may not always be Docker anymore – the Docker Desktop license rules have not helped – but containers are clearly something all software engineers should master.Kubernetes is rapidly becoming the next generation application server (with containers the applications to be ran) – the omnipresent (and omnipotent) deployment platform. Applications (microservices please?!) are built and delivered as container image. Deployment is equal to running a Kubernetes Deployment that instantiates Pods based on the container images. Kubernetes locally (minikube, k3s,..) or in the cloud is quickly becoming the core focus of platform engineers – dealing with wide range of tools for all kinds of tasks. Monitoring, service mesh, tracing, logging, volume mapping, release management, GitOps are just some of the areas where tools are available. It seems that Kubernetes as a runtime platform should be a serious consideration for any organization operating at scale – especially when availability, rapid evolution, variable workloads, efficient resource usage and high degree of automation are relevant.Service Mesh seems the logical next thing to discuss once you have embraced the K8S cluster as the runtime platform for applications and especially when these applications are created microservice style. The service mesh (pattern) is about having the mesh handle outgoing and incoming netwerk calls – through the use of a proxy or sidecar that is configured from and interacts with a central control plane. The proxy – in conjunction with other proxies through the control plane – can enforce important policies (mTLS, routing, load balancing, authentication) and help collect runtime data (logging, monitoring metrics, trace data). Istio seems the de facto standard for K8S service mesh – although Kong (Mesh) and Dapr also have a claim (both very much absent from Devoxx). For monitoring Istio, a commonly presented tool is Kiali.JetBrain’s IntelliJ IDE(A)s are the clear favorite. No user ever seems to complain or to consider to go back to where they came from. VS Code is heavily used as well – especially for non-Java development – but for anything Java, there does not seem to be a real debate.The adoption rate of Kotlin is somewhat unclear to me. Kotlin is mentioned frequently, but when audiences are quizzed the actual usage of Kotlin seems pretty low (< 20% of conference attendees appear to be using it)  .Okta – to manage and secure user authentication into applications, and to build identity controls into applications, website web services and devices. I have not heard Active Directory even once. Some references to KeyCloak – and many to Okta. Then there is Autho – by Okta. Auth0 an authentication and authorization platform for your application with a free plan.Reconsider and perhaps retire?Some technologies are probably still fine – they did not all of a sudden keel over or anything. However, they have lost momentum, lost market share and real attention from the developer crowd and commercial sponsors and perhaps are not really evolving very much anymore. These are not technologies to start afresh on and candidates to move away from when you get that chance.It is quite hard to objectively determine when a tool or technology has reached that state (for everyone) so I am not doing that here now. I will do this very subjectively and from the perspective of my own organization.Java 8 and anything older is obsolete. Java 11 is the least we should be working on and upgrading to Java 17  (also LTS) should be on our roadmap in the near future. Java 21 (September 2023) is the next LTS after Java 17.With the many changes in Java 8 and Java 11 and beyond, many of the clear advantages of Scala of Java are no longer so apparent.Although Jakarta EE is under active and enthusiastic development, it is hard to see how with Spring(Boot) as key player and Quarkus as major contender there is a huge future for Jakarta EE generating excitement of developers around the world. I feel too harsh and I may not be well informed but that is my perception.What was not mentioned at all?Some topics I had expected to hear about did not appear on the Devoxx agenda and went also unmentioned in the sessions that I attended. Whether that is meaningful or not is impossible to say, but a little telling it may beBackstage – the Spotify platform for building a Developer PortalFlutter – cross platform front end application language from GoogleOracle and IBM – two large companies that used to dominate these conferences. I saw some people from Oracle (especially GraalVM team), no sessions or booth from IBMAlibaba – the number four public cloud in many assessments, but at all presentApache NetBeans (pka the Java IDE from Sun Microsystems) –NetBeans (as was expected) is fading into the backgroundMySql or MariaDB – previously the database darling at conferences such as Devoxx; this week hardly mentioned at all. PostgreSQL has taken over center stage.Kong – API Gateway and Service Mesh – not in any title or abstractDapr.io – an open source framwork for distributed applications and making it easier for the individual components in such applications  to talk to each other and to interact with generic facilities and platform components such as data stores, cloud services, message queues, file/storage systems. I like it, I have made contributions to it but it failed to make it into this conference.Puppet, Ansible, Salt – Infra as Code, Automation – the revolution started with these tools – but this year I have not come across them. In all fairness, the current favorite Terraform was not al that visible eitherVR/AR – Virtual and Augmented Reality: at some point very popular topics but not this yearCrypto Coins – Blockchain was a topic in a single session (down from XX session in earlier years) and crypto was not in any session’s title or abstractChatBot or conversational UI – despite all attention for AI and the progress in NLP I have not seen anyone talk on ChatBots or even CLI-like interfaces.Low Code (well, … perhaps a little bit?) – it is a developers’ conference. How much development goes into Low Code? Well, not writing code obviously, but the art of creating software or at least implementing functionality is very much part of Low Code development. Computer Assisted Programming – of Computer Aided Software Engineering – where have I heard that before? JHipster does some of this one could easily argue. DSLs perhaps lead to low code programs? For example the way integrations are programmed with Apache Camel in many cases to to require actual programming code.
Lucas Jellema, active in IT (and with Oracle) since 1994. Oracle ACE Director and Oracle Developer Champion. Solution architect and developer on diverse areas including SQL, JavaScript, Kubernetes & Docker, Machine Learning, Java, SOA and microservices, events in various shapes and forms and many other things. Author of the Oracle Press book Oracle SOA Suite 12c Handbook. Frequent presenter on user groups and community events and conferences such as JavaOne, Oracle Code, CodeOne, NLJUG JFall and Oracle OpenWorld
_________________________________________Java virtualthreads  vs Kotlin coroutineshttps://spring.io/blog/2022/10/11/embracing-virtual-threads This concept is very similar to Kotlin Coroutines. Is my understanding correct ? 
Virtual Threads is specific to the "Java" language and this will have the same performance benefit of how Kotlin coroutines work. Chuck C Dilip 9 months ago This is supported by the JVM where coroutines are a library. Coroutines will now be able to take advantage of Loom. It should perform better than coroutines until kotlin takes advantage of jdk 19. Urs Peter Chuck C 9 months ago edited Sorry to say that the above is not correct. Let me clarify:1. Coroutines is not a library, but a language feature of Kotlin. The relevant language keyword is called suspend, which allows methods to be suspended when executed with a Coroutine. There are of course many libraries that take advantage of that mechanism.2. Conceptually Coroutines are very similar to VirtualThreads. The identical parts are: lightweight threads and structured concurrency. But there are also some differences:
-- Coroutines are more feature rich than what Loom offers now, namely:--- context propagation (meaning let the same context, like a MDC, Transaction etc. be propagated across several Coroutines) is fully embedded in Coroutines. Loom is still experimenting with this part, which they call scope variables.--- Cancellation: Part of the Contract Coroutines offer is cancellation, no matter how nested a process tree might be. This is and will not be available in Loom. In certain use-cases this is a big omission for Loom.3. Coroutines can perfectly benefit from Loom: A Coroutine always relies on a thread for its execution. This Thread can also be a VirtualThread. The advantage of having a VirtualThread executing a Coroutine is that all IO operations, concurrency locks etc. will behave in a non-blocking fashion, wasting no resources. Where Coroutines had to use a dedicated Threadpool for old-fashioned blocking IO operations (the Dispatchers.IO pool) it can omit this one when executed by a VirtualThread.4.Considering the above, it is still possible to use bare-bone Loom rather than Coroutines for JVM based applications. (remember Kotlin has a growing native proposition (Android, Multiplatform) where Coroutines will always be needed). When using bare-bone Loom the usage within Kotlin will be considerably more user-friendly than with Java, due to some language features Kotlin offers (functional literals with receivers).Here a dummy example for Java:
 public Info fetchMultipleAvatars() {
 try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
 Future<avatar> reply1 = scope.fork(() -> 
 return restTemplate.getForEntity("/avatar", Avatar.class).getBody();
 );
 Future<avatar> reply2 = scope.fork(() -> 
 return restTemplate.getForEntity("/avatar", Avatar.class).getBody();
 );
 scope.join(); // Join both forks
 scope.throwIfFailed(); // ... and propagate errors
 // Here, both forks have succeeded, so compose their results
 return new Info(delay, List.of(reply1.get(), reply2.get()));
 } catch (ExecutionException | InterruptedException e) {
 throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, e.getMessage());
 }
}Counterpart in Kotlin - with a bit of glue code provided in virtualScope:
fun fetchMultipleAvatars() = virtualScope {
 val reply1 = async{ restTemplate.getForEntity<avatar>("/avatar").body() }
 val reply2 = async { restTemplate.getForEntity<avatar>("/avatar").body() }
 Info(delay, reply1.await(), reply2.await()))
 }So, as a conclusion: Kotlin might profit more from Loom than Java itself______________________________________________
Mocking the java.time API for Better Testability - DZone
https://dzone.com/articles/mocking-the-javatime-api-for-better-testability 

 dzone.com Mocking the java.time API for Better Testability Jasper Sprengers 7 - 9 minutes Date/times logic in code is where the messiness of the real world upsets the relatively straightforward rules of the digital realm. Blame the bewildering hodgepodge of edge cases on the movement of celestial bodies and pope Gregory XIII (of the Gregorian calendar) but deal with it you must. I’m sure you all know that the 31st of December can be in week 52 or 53, while the 1st of January can be in week 0 or 1 and that you know these rules by heart for various countries (oh yes!). I’m also confident you can hand-code the logic to calculate the difference in seconds between two representations that span multiple time zones as well as a jump in daylight saving time.Don't Wait for the Next Leap YearForgive my sarcasm. Edge cases with time should be tested, especially if your code has homegrown date/time logic (which you should keep to a minimum). Application code deals with time representations that are either passed as one of the java.time classes, or as strings in some serialized format, e.g. 2022-12-03. For this category, you make up enough salient edges and make sure they are covered in unit tests. But often the code needs to know what the current time is. This new, unpredictable timestamp may just end up in a log statement, but it can also be the input to much more business-critical logic. Whenever you reference any of the *.now() methods, your program has introduced a side effect and become less deterministic.The problem for traditional unit tests is obvious: We can’t afford to wait for the next leap day to ensure the code handles the 29th of February well.  So, we don’t usually test for it and hope all is well. I once witnessed an inexplicable crash that had the whole team puzzled. It disappeared the next day, on the first of March. It turned out just as we expected: a naïve, homegrown Date handling algorithm that would crash every four years.What's in store for Containers in 2023ContainersDZone's 2023 Containers Trend Report will explore the current state of containers, key trends and advancements in global containerization strategies, and constructive content for modernizing your software architecture.Four Strategies to Manipulate the ClockIn this tutorial, I will offer some strategies to help ensure that code that asks for the current time can still be properly unit-tested. The approach in all cases is to intercept or replace the default API calls with a call to a mock or test double that returns a date/time configured in the test, rendering our production code deterministic again. Now, the best strategy is not to query the current time in a method when you can also receive it as a parameter. Minimize the places where the code needs to ask the time. There are four basic strategies with which testing code can manipulate the clock.Wrap calls to the java.time API now() methods into a custom static classUse an injectable custom DateTime service.Inject a subclass of java.time.Clock.Intercept static calls to the now() methods with a mocking framework.The first three strategies are flexible in what you can handle but require some modest changes to the production code. The last option can only handle fixed dates but leaves your production code untouched, which can be a compelling reason to use it.You can find all code samples in the accompanying GitLab project:Strategy 1: A Static WrapperLet’s look at the simplest variant: a static class that wraps a call to LocalDateTime.now()In your production code, you use it as follows:Suppose we want it to always return a fixed instant. In our test, we can configure this as follows:After calling setFixed(..) in your test, you get the same value whenever the current date/time is queried. You have effectively stopped the clock. That may however not always be what you want. Our sample code registers the difference between two invocations to the current time and these should not be the same. We want to move the clock forward for our test, but not have it stop ticking. Easy, we configure it to add a given duration to the current time. Each option invalidates the other. Offsets in the past are not supported here, but I'm sure you can implement that yourself.We can run the test as follows:Strategy 2: Injecting a Custom Mutable DateTimeServiceSomething feels off with this approach, though. It’s not great that production code has access to these setter methods. There’s a valid point in not introducing testing utilities in non-test code. A better, slightly more involved, strategy is to use dependency injection and have a production version next to a mutable test version. This can look as follows:We define a simple DateTimeService interfaceWith the following production implementation:And a mutable version for testing:And we use it as follows:We have two implementations of the DateTimeService and only one of them is instantiated. Since the DateTimeServiceIntegrationTest runs under the ‘test’ profile, it picks the MutableDateTimeService instance. In production, Spring picks the default DateTimeServiceImpl.Strategy 3: Injecting a java.time.Clock InstanceA similar injection-based approach that does not require you to write and configure a boilerplate production implementation uses the java.time.Clock class. The java.time API has an abstract class Clock that you can add as an argument to all the now() methods. By picking a different Clock, you can pretend that you’re in Beijing or that it’s forever 29 February 2016. In production, all that is needed is to inject a Clock instance and use it as follows:Unless otherwise configured, Spring picks java.time.Clock.SystemClock. If, in your test, you want to use a fixed date or an offset, you can use Clock.fixed(..) or Clock.offset(..) respectively in a Spring configuration class:For test purposes, the standard implementations fall short if you want to manipulate your offset or fixed time dynamically because the fixed instants or offsets in Clock objects are immutable after construction. A likely use case would be to simulate thirty runs of a scheduled daily batch process, advancing the clock by 24 hours each time.  But Clock is not final, so we can make our own MutableClock version. It's very similar to all the other classes. Have a look at it in the gitlab project.Strategy 4: Intercepting Static Invocations With MockitoThe last mocking method is an altogether different beast. It does not need dependency injection and leaves your production code entirely untouched. It comes down to intercepting the static method calls to the time API and configuring the responses with the help of the Mockito mocking framework. Mocking static methods is no longer the hassle it once was. It comes standard with Mockito since 3.4.0 but you need to add the extra Mockito-inline dependency (see the pom.xml in the project).Final Advice: Don't DIYI hope you have found this tutorial useful. Let me close with a final word of advice, based on my experience with some clueless DIY date handling by inexperienced developers. The most compelling arguments for not re-inventing the wheel are the same reasons why you should never roll your own cryptography solution. Firstly, it’s harder than you think. The best wheel you can re-invent will still be unprepared for the bumpy road of unexpected edge cases. But more importantly, it’s a highly common requirement, so the generic solutions already handle almost everything you can possibly need. This goes also for any test utilities that I presented in this tutorial. Keep it simple.Opinions expressed by DZone contributors are their own. ____________________________
https://stackoverflow.com/questions/24491260/mocking-time-in-java-8s-java-time-api

Mocking time in Java 8's java.time AP Joda Time has a nice DateTimeUtils.setCurrentMillisFixed() to mock time. It's very practical in tests. Is there an equivalent in Java 8's java.time API? javadatetimemockingjava-8java-time Share Improve this question Follow edited Jan 8, 2020 at 13:47 JodaStephen 60.7k1515 gold badges9595 silver badges117117 bronze badges asked Jun 30, 2014 at 13:29 neu242 15.7k2020 gold badges7979 silver badges114114 bronze badges Add a comment 		 12 Answers Sorted by: 84 The closest thing is the Clock object. You can create a Clock object using any time you want (or from the System current time). All date.time objects have overloaded now methods that take a clock object instead for the current time. So you can use dependency injection to inject a Clock with a specific time:public class MyBean { private Clock clock; // dependency inject ... public void process(LocalDate eventDate) { if (eventDate.isBefore(LocalDate.now(clock)) { ... } } }See Clock JavaDoc for more details Share Improve this answer Follow answered Jun 30, 2014 at 13:57 dkatzel 31.1k33 gold badges6262 silver badges6767 bronze badges 14 Yes. In particular, Clock.fixed is useful in testing, while Clock.system or Clock.systemUTC might be used in the application. – Matt Johnson-Pint Jun 30, 2014 at 17:28 11 Shame that there isn't a mutable clock that allows me to set it to non-ticking time, but modify that time later (you can do this with joda). This would be useful for testing time-sensitive code, e.g. a cache with time-based expiries or a class that schedules events in the future. – bacar Dec 17, 2015 at 10:15 3 @bacar Clock is abstract class, you could create your own test Clock implementation – Bjarne Boström Feb 17, 2016 at 12:45 I believe that's what we ended up doing. – bacar Feb 17, 2016 at 12:47 	 Add a comment 31 I used a new class to hide the Clock.fixed creation and simplify the tests:public class TimeMachine { private static Clock clock = Clock.systemDefaultZone(); private static ZoneId zoneId = ZoneId.systemDefault(); public static LocalDateTime now() { return LocalDateTime.now(getClock()); } public static void useFixedClockAt(LocalDateTime date){ clock = Clock.fixed(date.atZone(zoneId).toInstant(), zoneId); } public static void useSystemDefaultZoneClock(){ clock = Clock.systemDefaultZone(); } private static Clock getClock() { return clock ; }}public class MyClass { public void doSomethingWithTime() { LocalDateTime now = TimeMachine.now(); ... }}@Testpublic void test() { LocalDateTime twoWeeksAgo = LocalDateTime.now().minusWeeks(2); MyClass myClass = new MyClass(); TimeMachine.useFixedClockAt(twoWeeksAgo); myClass.doSomethingWithTime(); TimeMachine.useSystemDefaultZoneClock(); myClass.doSomethingWithTime(); ...} Share Improve this answer Follow edited Jul 4, 2018 at 14:37 answered Mar 31, 2015 at 4:16 LuizSignorelli 1,4111111 silver badges99 bronze badges 7 What about thread-safety if several tests are run in parallel and change the TimeMachine clock? – youri Nov 16, 2016 at 15:08 1 You have to pass the clock to the tested object and use it when calling time related methods. And you could remove the getClock() method and use the field directly. This method add nothing but a few lines of code. – deamon Oct 24, 2017 at 13:23 1 Banktime or TimeMachine? – Emanuele Dec 6, 2017 at 15:19 I found it a bad practice to declare private static variables and then modify their values in static void methods. – belgoros Jun 6 at 9:22 	 Add a comment 20 I used a fieldprivate Clock clock;and thenLocalDate.now(clock);in my production code. Then I used Mockito in my unit tests to mock the Clock using Clock.fixed():@Mockprivate Clock clock;private Clock fixedClock;Mocking:fixedClock = Clock.fixed(Instant.now(), ZoneId.systemDefault());doReturn(fixedClock.instant()).when(clock).instant();doReturn(fixedClock.getZone()).when(clock).getZone();Assertion:assertThat(expectedLocalDateTime, is(LocalDate.now(fixedClock))); Share Improve this answer Follow answered Jun 28, 2017 at 7:17 Claas Wilke 1,95111 gold badge1818 silver badges2929 bronze badges Add a comment 8 I find using Clock clutters your production code.You can use JMockit or PowerMock to mock static method invocations in your test code.Example with JMockit:@Testpublic void testSth() { LocalDate today = LocalDate.of(2000, 6, 1); new Expectations(LocalDate.class) {{ LocalDate.now(); result = today; }}; Assert.assertEquals(LocalDate.now(), today);}EDIT: After reading the comments on Jon Skeet's answer to a similar question here on SO I disagree with my past self. More than anything else the argument convinced me that you cannot parallize tests when you mock static methods.You can/must still use static mocking if you have to deal with legacy code, though. Share Improve this answer Follow edited Jul 1, 2019 at 9:02 Patrick W 1,48544 gold badges1919 silver badges2727 bronze badges answered Apr 14, 2015 at 11:42 Stefan Haberl 9,73277 gold badges7272 silver badges8181 bronze badges 1 +1 for "using static mocking for legacy code" comment. So for new code, be encouraged to lean into Dependency Injection and inject a Clock (fixed Clock for tests, system Clock for production runtime). – David Groomes Apr 20, 2018 at 20:50 	 Add a comment 2 A bit late, but here it is what I use to mock time using the java.date API in Kotlin:val now = LocalDate.of(2021, Month.FEBRUARY, 19)val clock = Clock.fixed(Instant.ofEpochSecond( now.atStartOfDay().toEpochSecond(ZoneOffset.UTC)), ZoneId.systemDefault())and then you can pass your clock to the class to testval classToTest = MyClass(clock)Of course, inside your testable class you will use the clock to retrieve dates or times:class MyClass(private val clock: Clock = Clock.systemDefaultZone()) { // ... fun doSomething() = LocalDate.now(clock)... Share Improve this answer Follow answered Feb 19, 2021 at 18:43 Alex Facciorusso 2,27033 gold badges2020 silver badges3434 bronze badges what do you think about implementing without passing Clock? Any costs/benefits? What's the benefit of passing the clock? For example, if it's a time-unrelated class – Geoff Langenderfer Nov 10, 2021 at 4:44 
 So, first thing first: you pass Clock only if you actually need it. What I mean is if you are not getting any kind of date/time in your class you don't need to pass Clock, of course. Given that, usually the goal is trying to have single-responsibility classes, so only the classes that use an implementation based on dates will have that dependency. That said, the main advantage I believe is having a common contract and practice to follow for every class that needs a date/time. – Alex Facciorusso Nov 11, 2021 at 14:51 
	 Add a comment 1 I need LocalDate instance instead of LocalDateTime.
With such reason I created following utility class:public final class Clock { private static long time; private Clock() { } public static void setCurrentDate(LocalDate date) { Clock.time = date.toEpochDay(); } public static LocalDate getCurrentDate() { return LocalDate.ofEpochDay(getDateMillis()); } public static void resetDate() { Clock.time = 0; } private static long getDateMillis() { return (time == 0 ? LocalDate.now().toEpochDay() : time); }}And usage for it is like:class ClockDemo { public static void main(String[] args) { System.out.println(Clock.getCurrentDate()); Clock.setCurrentDate(LocalDate.of(1998, 12, 12)); System.out.println(Clock.getCurrentDate()); Clock.resetDate(); System.out.println(Clock.getCurrentDate()); }}Output:2019-01-031998-12-122019-01-03Replaced all creation LocalDate.now() to Clock.getCurrentDate() in project. Because it is spring boot application. Before test profile execution just set a predefined date for all tests:public class TestProfileConfigurer implements ApplicationListener<ApplicationPreparedEvent> { private static final LocalDate TEST_DATE_MOCK = LocalDate.of(...); @Override public void onApplicationEvent(ApplicationPreparedEvent event) { ConfigurableEnvironment environment = event.getApplicationContext().getEnvironment(); if (environment.acceptsProfiles(Profiles.of("test"))) { Clock.setCurrentDate(TEST_DATE_MOCK); } }}And add to spring.factories: org.springframework.context.ApplicationListener=com.init.TestProfileConfigurer Share Improve this answer Follow edited Feb 26, 2020 at 22:22 answered Jan 3, 2019 at 19:38 catch23 17.5k4242 gold badges143143 silver badges215215 bronze badges Add a comment 1 Here's a working way to override current system time to a specific date for JUnit testing purposes in a Java 8 web application with EasyMockJoda Time is sure nice (thank you Stephen, Brian, you've made our world a better place) but I wasn't allowed to use it.After some experimenting, I eventually came up with a way to mock time to a specific date in Java 8's java.time API with EasyMockWithout Joda Time APIWithout PowerMock.Here's what needs to be done:What needs to be done in the tested classStep 1Add a new java.time.Clock attribute to the tested class MyService and make sure the new attribute will be initialized properly at default values with an instantiation block or a constructor:import java.time.Clock;import java.time.LocalDateTime;public class MyService { // (...) private Clock clock; public Clock getClock() { return clock; } public void setClock(Clock newClock) { clock = newClock; } public void initDefaultClock() { setClock( Clock.system( Clock.systemDefaultZone().getZone() // You can just as well use // java.util.TimeZone.getDefault().toZoneId() instead ) ); } { initDefaultClock(); } // initialisation in an instantiation block, but // it can be done in a constructor just as well // (...)}Step 2Inject the new attribute clock into the method which calls for a current date-time. For instance, in my case I had to perform a check of whether a date stored in database happened before LocalDateTime.now(), which I replaced with LocalDateTime.now(clock), like so:import java.time.Clock;import java.time.LocalDateTime;public class MyService { // (...) protected void doExecute() { LocalDateTime dateToBeCompared = someLogic.whichReturns().aDate().fromDB(); while (dateToBeCompared.isBefore(LocalDateTime.now(clock))) { someOtherLogic(); } } // (...) }What needs to be done in the test classStep 3In the test class, create a mock clock object and inject it into the tested class's instance just before you call the tested method doExecute(), then reset it back right afterwards, like so:import java.time.Clock;import java.time.LocalDateTime;import java.time.OffsetDateTime;import org.junit.Test;public class MyServiceTest { // (...) private int year = 2017; // Be this a specific private int month = 2; // date we need private int day = 3; // to simulate. @Test public void doExecuteTest() throws Exception { // (...) EasyMock stuff like mock(..), expect(..), replay(..) and whatnot MyService myService = new MyService(); Clock mockClock = Clock.fixed( LocalDateTime.of(year, month, day, 0, 0).toInstant(OffsetDateTime.now().getOffset()), Clock.systemDefaultZone().getZone() // or java.util.TimeZone.getDefault().toZoneId() ); myService.setClock(mockClock); // set it before calling the tested method myService.doExecute(); // calling tested method myService.initDefaultClock(); // reset the clock to default right afterwards with our own previously created method // (...) remaining EasyMock stuff: verify(..) and assertEquals(..) } }Check it in debug mode and you will see the date of 2017 Feb 3 has been correctly injected into myService instance and used in the comparison instruction, and then has been properly reset to current date with initDefaultClock(). Share Improve this answer Follow edited Jul 8, 2020 at 22:50 Hashmatullah Noorzai 76133 gold badges1212 silver badges3434 bronze badges answered Aug 23, 2017 at 7:21 KiriSakow 92511 gold badge1212 silver badges2222 bronze badges Add a comment 1 I used java.time.Clock with mockito dependencytestImplementation("org.mockito:mockito-core")testImplementation("org.mockito:mockito-inline")The service class uses a Clock field which will be mocked on the test.@Servicepublic class TimeTestWithDateService { private final Clock clock = Clock.systemUTC(); public TimeTest plan(UUID orderId) { return TimeTest.builder() .id(UUID.randomUUID()) .orderId(orderId) .createdAt(ZonedDateTime.now(clock)) .plannedAt(ZonedDateTime.now(clock) .plusDays(1) .withHour(8) .truncatedTo(ChronoUnit.HOURS)) .build(); } public TimeTest ship(TimeTest timeTest) { return TimeTest.builder() .id(timeTest.getId()) .orderId(timeTest.getOrderId()) .createdAt(timeTest.getCreatedAt()) .shippedAt(ZonedDateTime.now(clock)) .build(); }}@Value@Builderpublic class TimeTest { private UUID id; private UUID orderId; private ZonedDateTime createdAt; private ZonedDateTime plannedAt; private ZonedDateTime shippedAt;}The unit test uses the Mockito.mockStatic to mock the Clock.@SpringBootTestpublic class TimeTestWithDateServiceTest { @Autowired private TimeTestWithDateService timeTestService; private static Clock clock; private static ZonedDateTime now; @BeforeAll static void setupClock() { clock = Clock.fixed( Instant.parse("2020-12-01T10:05:23.653Z"), ZoneId.of("Europe/Prague")); now = ZonedDateTime.now(clock); var clockMock = Mockito.mockStatic(Clock.class); clockMock.when(Clock::systemUTC).thenReturn(clock); } @Test void timeTest_is_planned() { var orderId = UUID.randomUUID(); var timeTest = timeTestService.plan(orderId); var tomorrowAt8am = now.plusDays(1).withHour(8).truncatedTo(ChronoUnit.HOURS); assertAll( () -> assertThat(timeTest).isNotNull(), () -> assertThat(timeTest.getId()).isNotNull(), () -> assertThat(timeTest.getOrderId()).isEqualTo(orderId), () -> assertThat(timeTest.getCreatedAt()).isEqualTo(now), () -> assertThat(timeTest.getPlannedAt()).isEqualTo(tomorrowAt8am), () -> assertThat(timeTest.getShippedAt()).isNull() ); } @Test void timeTest_is_shipped() { var timeTest = timeTestService.plan(UUID.randomUUID()); var shipped = timeTestService.ship(timeTest); assertAll( () -> assertThat(shipped).isNotNull(), () -> assertThat(shipped.getId()).isEqualTo(timeTest.getId()), () -> assertThat(shipped.getOrderId()).isEqualTo(timeTest.getOrderId()), () -> assertThat(shipped.getCreatedAt()).isEqualTo(timeTest.getCreatedAt()), () -> assertThat(shipped.getShippedAt()).isEqualTo(now) ); }} Share Improve this answer Follow edited Apr 1, 2022 at 12:43 answered Sep 11, 2021 at 11:21 Felipe 6,90388 gold badges4141 silver badges102102 bronze badges Add a comment 0 This example even shows how to combine Instant and LocalTime (detailed explanation of issues with the conversion)A class under testimport java.time.Clock;import java.time.LocalTime;public class TimeMachine { private LocalTime from = LocalTime.MIDNIGHT; private LocalTime until = LocalTime.of(6, 0); private Clock clock = Clock.systemDefaultZone(); public boolean isInInterval() { LocalTime now = LocalTime.now(clock); return now.isAfter(from) && now.isBefore(until); }}A Groovy testimport org.junit.Testimport org.junit.runner.RunWithimport org.junit.runners.Parameterizedimport java.time.Clockimport java.time.Instantimport static java.time.ZoneOffset.UTCimport static org.junit.runners.Parameterized.Parameters@RunWith(Parameterized)class TimeMachineTest { @Parameters(name = "{0} - {2}") static data() { [ ["01:22:00", true, "in interval"], ["23:59:59", false, "before"], ["06:01:00", false, "after"], ]*.toArray() } String time boolean expected TimeMachineTest(String time, boolean expected, String testName) { this.time = time this.expected = expected } @Test void test() { TimeMachine timeMachine = new TimeMachine() timeMachine.clock = Clock.fixed(Instant.parse("2010-01-01T${time}Z"), UTC) def result = timeMachine.isInInterval() assert result == expected }} Share Improve this answer Follow edited May 23, 2017 at 12:10 CommunityBot 111 silver badge answered Aug 12, 2016 at 13:03 banterCZ 1,50111 gold badge2121 silver badges3636 bronze badges Add a comment 0 With the help of PowerMockito for a spring boot test you can mock the ZonedDateTime.You need the following.AnnotationsOn the test class you need to prepare the service which uses the the ZonedDateTime.@RunWith(PowerMockRunner.class)@PowerMockRunnerDelegate(SpringRunner.class)@PrepareForTest({EscalationService.class})@SpringBootTestpublic class TestEscalationCases { @Autowired private EscalationService escalationService; //...}Test caseIn the test you can prepare a desired time, and get it in response of the method call. @Test public void escalateOnMondayAt14() throws Exception { ZonedDateTime preparedTime = ZonedDateTime.now(); preparedTime = preparedTime.with(DayOfWeek.MONDAY); preparedTime = preparedTime.withHour(14); PowerMockito.mockStatic(ZonedDateTime.class); PowerMockito.when(ZonedDateTime.now(ArgumentMatchers.any(ZoneId.class))).thenReturn(preparedTime); // ... Assertions } Share Improve this answer Follow answered Mar 18, 2019 at 13:04 pasquale 48955 silver badges88 bronze badges Add a comment 0 Use jmockit:Code:// Mocking time as 9amfinal String mockTime = "09:00:00"new MockUp<LocalTime>() { @Mock public LocalTime now() { return LocalTime.parse(mockTime); }};Imports:import mockit.MockUp;import mockit.Mock;Dependency:<groupId>org.jmockit</groupId><artifactId>jmockit</artifactId><version>1.41</version> Share Improve this answer Follow answered Jun 25, 2021 at 6:55 Arun 78588 silver badges1313 bronze badges Add a comment 0 here is the answer : https://gabstory.com/70?category=933660import com.nhaarman.mockitokotlin2.givenimport org.junit.jupiter.api.Assertions.assertEqualsimport org.junit.jupiter.api.BeforeEachimport org.junit.jupiter.api.Testimport org.junit.jupiter.api.extension.ExtendWithimport org.mockito.Mockimport org.mockito.Mockito.mockStaticimport org.mockito.junit.jupiter.MockitoExtensionimport org.springframework.data.projection.ProjectionFactoryimport org.springframework.data.projection.SpelAwareProxyProjectionFactoryimport java.time.Clockimport java.time.ZonedDateTime@ExtendWith(MockitoExtension::class)class MyTest { private val clock = Clock.fixed(ZonedDateTime.parse("2021-10-25T00:00:00.000+09:00[Asia/Seoul]").toInstant(), SEOUL_ZONE_ID) @BeforeEach fun setup() { runCatching { val clockMock = mockStatic(Clock::class.java) clockMock.`when`<Clock>(Clock::systemDefaultZone).thenReturn(clock) } } @Test fun today(){ assertEquals("2021-10-25T00:00+09:00[Asia/Seoul]", ZonedDateTime.now().toString()) }} Share Improve this answer Follow answered Nov 10, 2021 at 1:18 kokojustin 19033 silver badges1212 bronze badges Add a comment Highly active question. Earn 10 reputation (not counting the association bonus) in order to answer this question. The reputation requirement helps protect this question from spam and non-answer activity. Not the answer you're looking for? Browse other questions tagged javadatetimemockingjava-8java-time or ask your own question. The Overflow Blog 
 Improving time to first byte: Q&A with Dana Lawson of Netlify 
 What it’s like to be on the Python Steering Council (Ep. 592) Featured on Meta Colors update: A more detailed look Stack Overflow at WeAreDevelopers World Congress in Berlin Temporary policy: Generative AI (e.g., ChatGPT) is banned Launching 2 new collectives: PHP and NLP Conclusions from title-drafting and question-content assistance experiments... 		 		 	Linked	 									6								How to override current system time to a specific date in a Java 8 web application with EasyMock, without Joda Time, and without PowerMock?			 									1								How to make Java point to a different (Custom) Date/Time other than System Date/Time?			 									79								Time dependent unit tests			 									40								Java SE 8 TemporalAccessor.from issues when used with a java.time.Instant object			 									2								How do I simulate the passage of time with java.time.Clock?			 									3								Mockk current time			 									0								How to mock clock.millis() in Java			 									1								Java Mockito when-return on Object creation			 									2								How to unit test date related methods?			 									-1								how to mock timestamp and date function in java?					 See more linked questions 	 Related 2 Mocking the current time with JRE 1.4 1 Java Date Time discrepancy 84 Unit testing a class with a Java 8 Clock 96 How can I mock java.time.LocalDate.now() 3 tests for java.time API 0 Writing and testing convenience methods using Java 8 Date/Time classes 0 How to mock the minute value when mocking LocalDateTime? 0 How to mock clock.millis() in Java 0 How to mock datetime with java.time.clock? 2 How do I simulate the passage of time with java.time.Clock? Hot Network Questions How do I remove unsupported characters from a filename on Windows How to improve quality of mp3 output after applying filters? Resources for self-teaching philosophy Which side is the capacitor negative on this board? (IO/10 marking) How should I speak to a professor about extra credit that dropped my grade? Did Latin change less over time as compared to other languages? Custom y-axis Compression Dual Passport Filipino traveling from Saudi Arabia How to create a random zonogon? Are there linear orders with more cuts than elements of any size? Maximize "sudoku" occurrences in a sudoku What was the first rhythm game? Drop from co-authorship of manuscript Is it possible for a group/clan of 10k people to start their own civilization away from other people in 2050? Like the Amish but with more technology? Help with smoke detectors? Instance on Points with different parameters for each instance What should I do after I found a coding mistake in my masters thesis? Did Christopher Nolan intend to imply a conspiracy? Looking for title of a short story about astronauts helmets being covered in moondust How does the Buddhist pursue meaning? "Print this diamond" gone beautifully wrong Drawing complex nested brackets, horizontally curled Charging a high powered laptop on aircraft power Naming the intersection points of two paths in Tikz Question feed Stack Overflow QuestionsHelp Products TeamsAdvertisingCollectivesTalent Company AboutPressWork HereLegalPrivacy PolicyTerms of ServiceContact UsCookie SettingsCookie Policy Stack Exchange Network Technology Culture & recreation Life & arts Science Professional Business API Data BlogFacebookTwitterLinkedInInstagram Site design / logo © 2023 Stack Exchange Inc; user contributions licensed under CC BY-SA. rev 2023.7.21.43541 ____________________________
https://www.baeldung.com/java-override-system-time


