## Create zipped summary of java.util.concurrent:  [[{concurrency.101,PM.TODO]]

  - Inmmutable Objects are faster and thread-safe:
   https://docs.oracle.com/javase/tutorial/essential/concurrency/immutable.html

  - Concurrency Classes Video
@[https://www.youtube.com/watch?v=8yD0hHAz3cs&list=PLw8RQJQ8K1ySGcb3ZP66peK4Za0LKf728&index=4]

  - java.util.concurrent.locks.ReentrantLock vs synchronized { ... } block

  - example stack trace (extracted from Vert.X):
    at jdk.internal.misc.Unsafe.park(Native Method)
    at java.util.concurrent.locks.LockSupport.park
    at java.util.concurrent.LinkedTransferQueue.awaitMatch
    at java.util.concurrent.LinkedTransferQueue.xfer
    at java.util.concurrent.LinkedTransferQueue.take
    at java.util.concurrent.ThreadPoolExecutor.getTask
    at java.util.concurrent.ThreadPoolExecutor.runWorker
    at java.util.concurrent.ThreadPoolExecutor$Worker.run
[[}]]



[[{java,01_PM.TODO]]

## [[{]]
  @[https://www.programcreek.com/2013/03/hashmap-vs-treemap-vs-hashtable-vs-linkedhashmap/]
  @[https://www.programcreek.com/2015/12/top-10-java-utility-classes/]      @ma
  @[https://www.programcreek.com/2013/09/top-9-questions-for-java-map/]
  @[https://www.programcreek.com/2013/09/top-10-questions-for-java-collections/]
  @[https://www.programcreek.com/2013/09/top-8-diagrams-for-understanding-java/]
  @[https://www.programcreek.com/2013/09/top-10-faqs-of-java-strings/]
  @[https://www.programcreek.com/2013/09/top-10-methods-for-java-arrays/]
  @[https://www.programcreek.com/2013/09/top-10-websites-for-advanced-level-java-developers/]
  @[https://www.programcreek.com/2013/08/top-books-for-advanced-level-java-developers/]
[[}]]


## https://blog.frankel.ch/jvm-security/4/ [[{jvm,security}]]


## SPARTA (anti-malware)
  - Aimed at preventing malware from appearing in an app store.
  - provides an information-flow type-checker customized to Android
    but can also be applied to other domains.
  @[https://checkerframework.org/sparta/]
    The paper "Collaborative verification of information flow for a
    high-assurance app store" appeared in CCS 2014.

## Java 9 to 13 in a Nutshell!!!: @ma
  https://bentolor.github.io/java9to13/#/_preview_features_preview_12

## Guava Collections [[{data_structures,qa.data]]
- Widely used Google Core Libraries for Java 6+.
  with as advanced collection types
  https://www.baeldung.com/guava-sets?
[[}]]
######################################################
## Is Java 17 a Glass Half Full?
  https://www.infoq.com/news/2021/07/java-17-glass/

  Overall, the features present in Java 17 are broadly following the
  expected pattern, as InfoQ previously reported on. The unfortunate
  truth is that of the major projects that have been the major areas of
  JDK development in the last three years (Loom, Valhalla, Amber and
  Panama) - none are complete as of the release of Java 17.

  This means that the feature set of Java 17 will be more modest than
  many developers hoped.

  For example, The Algebraic Data Types feature (comprising Records and
  Sealed Types) is complete as of 17. This is a major step forward in
  terms of data modeling and enhancing the OO capabilities of the Java
  language. However, the Pattern Matching feature which complements and
  builds upon algebraic data types is only present as a Preview feature
  in Java 17 (and only in a fairly rudimentary form at that).

## Architecture of a Geospatial Application with Java
  https://www.baeldung.com/java-geospatial-applications

## Eclipse Memory Analyzer Open Source Project
  https://www.eclipse.org/mat/
  - fast and feature-rich Java heap analyzer that helps you find
    memory leaks and reduce memory consumption.
  - Use the Memory Analyzer to analyze productive heap dumps with
    hundreds of millions of objects, quickly calculate the retained sizes
    of objects, see who is preventing the Garbage Collector from
    collecting objects, run a report to automatically extract leak
    suspects.

## Java 17, the Next Long-Term Support Release, is Now Available
  https://www.infoq.com/news/2021/09/java17-released/

## JDK Mission Control 8.1.0 Released!
  https://foojay.io/today/jdk-mission-control-8-1-0-released/

## https://github.com/topics/snippets-collection

## Scala 3 Overhauls Language for Better Developer Experience
  https://www.infoq.com/news/2021/06/scala-3-overhaul/

 1) Another significant difference between ReentrantLock and the
synchronized keyword is fairness. The synchronized keyword doesn't
support fairness. Any thread can acquire lock once released, no
preference can be specified, on the other hand, you can make
ReentrantLock fair by specifying fairness property while creating an
instance of ReentrantLock. Fairness property provides a lock to the
longest waiting thread, in case of contention.

 2) The second difference between synchronized and Reentrant lock is
tryLock() method. ReentrantLock provides a convenient tryLock()
method, which acquires lock only if its available or not held by any
other thread. This reduces the blocking of thread waiting for lock-in
Java applications.

 3) One more worth noting the difference between ReentrantLock and
synchronized keyword in Java is, the ability to interrupt Thread
while waiting for Lock. In case of a synchronized keyword, a thread
can be blocked waiting for a lock, for an indefinite period of time
and there was no way to control that. ReentrantLock provides a method
called lockInterruptibly(), which can be used to interrupt thread
when it is waiting for lock. Similarly, tryLock() with timeout can be
used to timeout if the lock is not available in certain time period. [[}]]

## JAVA DONT's:
  https://dzone.com/articles/we-should-write-java-code-differently?edition=598293#

## Complete how to write files in Guava

## aborted compilation of a multi-module (like AbsisParentPom)  [[{maven]]
  can be restarted (from the last failed module) with '--resume-from' option like:
$ $ mvn --resume-from=com.myCompany.myModule:MyArtifact \
$   $ clean install -P myProfile -DskipTests=true            [[}]]


## Java Erasure
  Type Erasure is a technique employed the Java compiler to support the use of Generics.
@[https://developer.ibm.com/recipes/tutorials/java-language-type-erasure/]

## High Perf Persistence
  https://www.reddit.com/r/linux/comments/ajkfs0/github_trimstraythepracticallinuxhardeningguide/

## Kryo serialization lib [[{]]
  - Object graph serialization library:
   @[https://github.com/EsotericSoftware/kryo]
    Kryo is a fast and efficient binary object graph serialization
    framework for Java. The goals of the project are high speed, low
    size, and an easy to use API. The project is useful any time objects
    need to be persisted, whether to a file, database, or over the
    network.

     Kryo can also perform automatic deep and shallow copying/cloning.
    This is direct copying from object to object, not object to bytes to
    object.  [[}]]

## java_lang.101,qa.billion_dolar_mistake:
  Optional (1.8+)

  Optional<Integer> highestNumber
      = itemList.stream()
        .reduce((int1, int2) ->               ← Reduce returns Optional
                (int1 > int2) ? int1 : int2);

  Optional Evolution
  https://dzone.com/articles/java-optional-api-evolution?edition=699391

[[{01_PM.TODO]]
# Secomp JVM Integration
@[https://docs.sonarqube.org/latest/requirements/requirements/]
https://en.wikipedia.org/wiki/Seccomp
http://people.apache.org/~rmuir/es-coverage/post-query-refactoring/org.elasticsearch.bootstrap/Seccomp.java.html
seccomp filter  Non-portable linux/amd64 only security protection, preventing non
                authorized calls to kernel.


By default, Elasticsearch uses seccomp filter. On most distribution
this feature is activated in the kernel. If  distributions without
this featur you have to explicitly deactivate this security layer
by updating sonar.search.javaAdditionalOpts in
$SONARQUBEHOME/conf/sonar.properties_:

sonar.search.javaAdditionalOpts=-Dbootstrap.system_call_filter=false

You can check if seccomp is available on your kernel with:

$ grep SECCOMP /boot/config-$(uname -r)

If your kernel has seccomp, you will see:

CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
CONFIG_SECCOMP_FILTER=y
CONFIG_SECCOMP=y
[[}]]

## Clean JSON Notes.
## @[https://www.baeldung.com/java-json-binding-api]

## Compact monitoring notes: jcmd, Visual Recorder,  CRaSH shell
  Eclipse Mem.Analizer

## https://eclipse-ee4j.github.io/jakartaee-tutorial/ @ma
  https://www.uml-diagrams.org/java-ejb-uml-profile-diagram-example.html
  https://www.uml-diagrams.org/java-ejb-state-machine-diagram-example.html

## https://www.uml-diagrms.org/java-7-api-uml-package-diagram-example.html
  https://www.uml-diagrams.org/examples/java-servlet-25-api-package-diagram-example.html
  https://www.uml-diagrams.org/examples/java-servlet-30-api-package-diagram-example.html
  https://www.uml-diagrams.org/java-thread-uml-state-machine-diagram-example.html

## https://www.uml-diagrams.org/tomcat-server-uml-composite-structure-diagram-example.html
  https://www.uml-diagrams.org/web-application-clusters-uml-deployment-diagram-example.html


## https://github.com/google/re2j
  linear time regular expression matching in Java
  If you use regular expression patterns with a high degree of
  alternation, your code may run faster with RE2/J. In the worst case,
  the java.util.regex matcher may run forever, or exceed the available
  stack space and fail; this will never happen with RE2/J.

## weekly Inside Java Newscast:
  https://www.youtube.com/playlist?list=PLX8CzqL3ArzX8ZzPNjBgji7rznFFiOr58

## Who-is-Who:
  https://nipafx.dev/nicolai-parlog/
  Java developer advocate at Oracle

## plans for Java in 2022.
  https://www.youtube.com/watch?v=4Y3LijiBxRA
  focus on the four main Java projects:
  · https://openjdk.java.net/projects/amber
  · https://openjdk.java.net/projects/loom
  · https://openjdk.java.net/projects/panama/
  · https://openjdk.java.net/projects/valhalla
    The goal of Project Valhalla is to explore and incubate advanced
    Java VM and Language feature candidates such as:
    · Value types
    · Generic specialization
    · Enhanced volatiles
    · and possibly othe related topics, such as reified generics

## https://openjdk.java.net/jeps/0


## Testing add notes:    @ma
  • mockito,
    https://github.com/mockito/mockito/wiki/Features-And-Motivations
    "...Mockito has very slim API, almost no time is needed to start mocking.
      There is only one kind of mock, there is only one way of creating
      mocks. Just remember that stubbing goes before execution,
      verifications of interactions go afterwards... "

## Add notes on JUnit parameterized tests.
  https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests

## Apple has open-sourced GCGC, a tool for Java Garbage Collector (GC)
  logs visualization based on Python 3 and pandas.
  https://www.infoq.com/news/2022/01/apple-gcgc-java/
  https://github.com/apple/GCGC

## GCGC uses a Jupyter notebook to analyze and visualize GC log files. A
  notebook is provided for the analysis and it generates plots and
  tables from collected GC information.

## https://theboreddev.com/understanding-java-streams @ma?

## Data Oriented Programming in Java
   https://www.infoq.com/articles/data-oriented-programming-java/

## cache2k - Java Caching –https://cache2k.org/

## Java 18
  https://www.infoq.com/news/2022/03/java18-released/
## Failsafe 3.2 Released with New Resilience Policies
  https://www.infoq.com/news/2022/02/failsafe-resilience-3/

## 101: Six Features From Java 12 to 17 to Get Excited About!
  https://www.infoq.com/articles/six-features-jdk12-to-jdk17/

## log4j, Log4Shell: A new fix, details of active attacks, and risk mitigation recommendations
  https://www.helpnetsecurity.com/2021/12/15/log4shell-mitigation/

## E-book Collection Page | Red Hat DeveloperLot of books about quarkus!!!
  https://developers.redhat.com/e-books
## Introducing the KivaKit Framework
  https://www.infoq.com/articles/introducing-kivakit/

## concurrency, 101? Measuring ForkJoinPool Parallelism
  https://www.javaspecialists.eu/archive/Issue297-Measuring-ForkJoinPool-Parallelism.html

## Why SOLID principles are still the foundation for modern software architecture [[{]]
https://stackoverflow.blog/2021/11/01/why-solid-principles-are-still-the-foundation-for-modern-software-architecture/ 
  - Single responsibility principle Original definition: “There should
    never be more than one reason for a class to change.”If you write a
    class with many concerns, or “reasons to change”, then you need
    to change the same code whenever any of those concerns has to change.
    This increases the likelihood that a change to one feature will
    accidentally break a different feature.
  - Open-closed principle Original definition: “Software entities should
    be open for extension, but closed for modification.”This is part of
    the design of languages like Java—you can create classes and extend
    them (by creating a subclass), but you can’t modify the original
    class. One reason for making things “open for extension” is to
    limit the dependency on the author of the class—if you need a
    change to the class, you’d constantly need to ask the original
    author to change it for you, or you’d need to dive into it to
    change it yourself. What’s more, the class would start to
    incorporate many different concerns, which breaks the single
    responsibility principle.The reason for closing classes for
    modification is that we may not trust any and all downstream
    consumers to understand all the “private” code we use to get our
    feature working, and we want to protect it from unskilled hands

  - Liskov substitution principle Original definition:
   “If S is a subtype of T, then objects of type T may be replaced with
    objects of type S without altering any of the desirable properties of the program.”
  - Interface segregation principle Original Definition:
    “Many client-specific interfaces are better than one
    general-purpose interface.”In OO, you can think of this as
    providing a “view” into your class. Rather than giving your full
    implementation to all your clients, you create interfaces on top of
    them with just the methods relevant to that client, and ask your
    clients to use those interfaces. 
  - Dependency inversion principle Original definition:
   “Depend upon abstractions, not concretions.”In OO, this means
    that clients should depend on interfaces rather than concrete classes
    as much as possible. This ensures that code is relying on the
    smallest possible surface area—in fact, it doesn’t depend on code
    at all, just a contract defining how that code should behave. As with
    other principles, this reduces the risk of a breakage in one place
    causing breakages elsewhere accidentally.
[[}]]

## persistence: No More MultipleBagFetchException Thanks to Multiset Nested Collections SQL and jOOQ.
  https://blog.jooq.org/no-more-multiplebagfetchexception-thanks-to-multiset-nested-collections/
______________________________
## Troubleshooting Java Applications with Eclipse Jifa [[{]]
  https://www.infoq.com/news/2022/02/eclipse-jifa/ 
The analytic engine currently has two parts: the Heap Dump Analysis
service based on Eclipse Memory Analyzer (MAT) and the GC Log
Analysis service which supports the G1, Parallel GC, Serial GC, CMS
and ZGC garbage collection algorithms. The GC Log Analysis Service
can process logs from Java 8 and 11, while support for Java 17 is
under development

Eclipse Jifa’s heap dump analysis, based on Eclipse MAT, provides
detailed documentation about analyzing heap dumps

Vue 2.0 and Vert.x are used for the frontend and backend, respectively.

There are several ways to deploy Eclipse Jifa: only one worker, one
master and several workers or the Kubernetes model.
Java: Compressed GraalVM Native Images: the best startup for Java
apps comes in tiny packages
https://medium.com/graalvm/compressed-graalvm-native-images-4d233766a214
[[}]]

## Azul Launches Java Cloud Compiler
  https://www.infoq.com/news/2022/02/azul-cloud-compiler/ 
  Azul Intelligence Cloud introduces a third option that bridges the
  benefits of JIT (peak performance) with the benefits of AOT (fast
  startup time). As teams often run the same code across many systems,
  the JRE communicates with an organization’s shared JIT server so
  that each JRE does not need to do the same observation and
  optimization cycle. The cloud compiler can then also perform deeper
  analysis, using CPU resources that are isolated from the running
  application. Resulting applications can reach peak performance in the
  network time needed to transfer this information and run with the
  improved code. In tests described at QCon, the time to peak
  performance was faster and throughput was between 25 to 100%
  faster.
https://www.baeldung.com/java-weekly-425


## Java, quarkus + neo4j,...:
  https://www.infoq.com/news/2021/10/java-news-roundup-oct04-2021/

## Security: Detect and block Log4j exploitation attempts with CrowdSec
  The OOSS & collaborative IPS
https://crowdsec.net/blog/detect-block-log4j-exploitation-attempts/

## https://github.com/JakeWharton/RxRelay
  Subjects and Relays allow to bridge non-Rx APIs into Rx easily, and without
  the worry of accidentally triggering a terminal state.

## JAVA Example Architecute:
  In the case of Java, we may add new libraries (with all its
  transitive dependencies) for each of the “microservicilitities”,
  such as Resiliency4J for resiliency, Jaeger for tracing, or
  Micrometer for monitoring.

## JAVA JDK version, JVM version, javac -source/-target/-release/ ... related info: [[{java,01_PM.TODO}]]
  https://stackoverflow.com/questions/43102787/what-is-the-release-flag-in-the-java-9-compiler

# JVM Journey to Cloud-native [[{cloud.101,01_PM.TODO]]
(by BellSoft)
## JDK 9 : Compact Strings
          HTTP/2 client
## JDK 10: Docker awareness
## JDK 11: ZGC
## JDK 12: Return unused memory
          Shenandoah GC
## JDK 13: Uncommit unused memory for ZGC
## JDK 14: JFR Event Streaming
## JDK 15: Reimplement Datagram Socker API
          Hidden Classes

## JDK 16: Elastic metaspace
          Alpine Linux port

[[}]]

# JPA Summary [[{01_PM.TODO]]
## Java: Migrating from JPA 2.x to 3.0
  https://thorben-janssen.com/migrating-jpa-2-x-to-3-0/?ck_subscriber_id=935368299
## https://www.javacodegeeks.com/2015/02/jpa-tutorial.html
[[}]]


# JDeps [[{devops.101,java_lang.debugging,01_PM.TODO]]
## JDeps: dependency analysis tool for Java bytecode (class files and JARs).
@[https://nipafx.dev/jdeps-tutorial-analyze-java-project-dependencies/]

$ $ jdeps sh-2.6.3.jar       ←  -verbose:class will list dependencies between classes
  sh-2.6.3.jar → java.base      (vs aggregating them to package level)
  sh-2.6.3.jar → java.datatransfer
  sh-2.6.3.jar → java.desktop
  sh-2.6.3.jar → java.logging
  sh-2.6.3.jar → java.prefs
  sh-2.6.3.jar → java.sql
  sh-2.6.3.jar → java.xml
  sh-2.6.3.jar → not found
     edu.udo.sh → com.beust.jcommander  not found
     edu.udo.sh → edu.udo.sh.data       sh-2.6.3.jar
     edu.udo.sh → edu.udo.sh.gui        sh-2.6.3.jar
     edu.udo.sh → edu.udo.sh.gui.util   sh-2.6.3.jar
     edu.udo.sh → edu.udo.sh.util       sh-2.6.3.jar
     edu.udo.sh → java.io               java.base
     edu.udo.sh → java.lang             java.base
     edu.udo.sh → javax.swing           java.desktop
     edu.udo.sh → org.slf4j             not found
  [... truncated many more package dependencies ...]
[[}]]

# GraalVM Summary [[{jvm.graalvm,cloud.k8s,scalability.jvm,01_PM.TODO]]
@[http://www.graalvm.org/]
@[https://technology.amis.nl/2018/11/23/comparing-jvm-performance-zulu-openjdk-openjdk-oracle-jdk-graalvm-ce/]
@[https://www.reddit.com/r/java/comments/acarqq/graalvm_in_2018/]

- Graal: How to Use the New JVM JIT Compiler in Real Life
  @[https://www.infoq.com/presentations/graal-jvm-jit/]

- GraalVM Native Image
@[https://www.graalvm.org/docs/reference-manual/native-image/]
 "native-image"  utility:
 - ahead-of-time compiler to a   standalone executable .
 - JVM is replaced with necesary  components (memory mngr,
   Thread scheduler) in "Substrate VM" runtime:
   Substrate VM runtime is actually the name for the runtime components
   (like the deoptimizer, garbage collector, thread scheduling etc.).
 - Result has faster startup time and lower runtime memory .
 - It statically analyses which classes and methods are reachable
   and used during application execution and passes all this
   reachable code as the input to the GraalVM compiler for
   ahead-of-time compilation into native-library.
Ex Ussage:
@[https://github.com/web3j/svm/blob/master/generate_native_image.sh]
  # tested with graalvm 19.3.1
  ./gradlew spotlessApply
  ./gradlew build
  ./gradlew shadowJar  // ← create fat JARs, relocate packages for apps/libs
  cd "build/libs" || exit
  native-image \
     -cp svm-1.0-SNAPSHOT-all.jar \
     org.web3j.svm.MainKt \
     --no-fallback \
     --enable-https \
     --enable-http
[[}]]



# Quarkus (GraalVM) Framework [[{jvm.graalvm,cloud.k8s,scalability.jvm,01_PM.TODO]]
@[https://quarkus.io/guides/]
@[https://quarkus.io/guides/kogito-guide]
@[https://marketplace.visualstudio.com/items?itemName=kie-group.vscode-extension-kogito-bundle]
..
@[https://www.infoq.com/news/2019/03/redhat-release-quarkus]

Extracted from "Hibernate with Panache" by Emmanuel Bernard.
""" Quarkus is Supersonic Subatomic Java. extremely fast with low memory footprint""".
@[https://quarkus.io/guides/hibernate-orm-panache-guide]
Hibernate ORM is the de facto JPA implementation and offers you the full
breadth of an Object Relational Mapper. It makes complex mappings possible,
but it does not make simple and common mappings trivial. Hibernate ORM with
Panache focuses on making your entities trivial and fun to write in Quarkus.

  Panache example:
  @Entity
  public class Person extends PanacheEntity {
      public String    name;
      public LocalDate birth;
      public Status    status;

      public static Person      findByName(String name) {
        return find("name", name).firstResult();
      }
      public static List<Person> findAlive           () {
        return list("status", Status.Alive);
      }
      public static void       deleteStefs           () {
        delete("name", "Stef");
      }
  }
[[}]]

# AsyncAPI.org [[{async/reactive.101,standards.openapi,qa.*,01_PM.TODO]]
@[https://www.asyncapi.org/]
- Building the future of event-driven architectures.
- Open source tools to easily build and maintain your event-driven architecture.
- All powered by the AsyncAPI specification, the industry standard for defining
  asynchronous APIs.
[[}]]

# Sign/Verify JARs [[{devops,security.cryptography,01_PM.TODO]]
@[https://docs.oracle.com/javase/9/tools/jarsigner.htm]

$ $ jarsigner file01.jar $keystore_alias   ← Sign Jar. use flag -sigalg ... to set sign. algorithm

$ $ jarsigner -verify file01.jar           ← Verify jar
[[}]]

# Guava VisibleForTesting[qa] [[{data_structures.*,concurrency.*,qa.testing,01_PM.TODO]]
[[{data_structures.*,concurrency.*,qa.testing,01_PM.TODO]]
REF: @[https://stackoverflow.com/questions/6913325/annotation-to-make-a-private-method-public-only-for-test-classes]
@[https://guava.dev/releases/19.0/api/docs/com/google/common/annotations/VisibleForTesting.html]
[[}]]

# Javalin: Kiss Kotlin/Java web framework [[{01_PM.radar]]
@[https://javalin.io]
- Inspired by Javascript KOA.js framework

- Ex: Declare server and API in the same place
  | import io.javalin.ApiBuilder.*;
  | import io.javalin.Javalin;
  |
  | Javalin app = Javalin.create(config -> {
  |     config.defaultContentType = "application/json";
  |     config.addStaticFiles("/public");
  |     config.enableCorsForAllOrigins();
  | }).routes(() -> {
  |     path("users", () -> {
  |         get(UserController::getAll);
  |         post(UserController::create);
  |         path(":user-id", () -> {
  |             get(UserController::getOne);
  |             patch(UserController::update);
  |             delete(UserController::delete);
  |         });
  |         ws("events", userController::webSocketEvents);
  |     });
  | }).start(port);
[[}]]

[[{]]scalability.native_code" >
# JNR(JNI/UNIX friendly)
( used by Netty and others...)
-@[https://github.com/jnr/jnr-ffi]
   load native libraries without writing JNI code by hand, or using tools such as SWIG.
-@[https://github.com/jnr/jnr-unixsocket]
   jnr-unixsocket: UNIX domain sockets (AF_UNIX) for Java
-@[https://github.com/jnr/jnr-enxio]
   Java Native Runtime Enhanced X-platform I/O
-@[https://github.com/jnr/jnr-x86asm]
   Pure java x86 and x86_64 assembler
-@[https://github.com/jnr/jnr-a64asm]
  AArch64 assembler for the Java Native Runtime
-@[https://github.com/jnr/jnr-process]
  A ProcessBuilder look-alike based entirely on native POSIX APIs
-...
[[}]]


# JAAS [[{security.aaa,01_PM.TODO]]
@[https://en.wikipedia.org/wiki/Java_Authentication_and_Authorization_Service]
- In UNIX, by default we authenticate against /etc/passwd, but the
  (P)lugable (A)uthentication (M)odule (PAM), allows to check against other sources.
  JAAS is similar to PAM for Java, allowing to offer a common AAA front-end to
  file/ddbb/LDAP/... backends.
[[}]]

# Eclipse Microprofile [[{standards.jee.microprofile,01_PM.TODO]]
@[https://dzone.com/articles/microprofile-5-things-you-need-to-know]

- launched at JavaOne 2016 to address the shortcomings in the Enterprise Java microservices space.

- MicroProfile specifies a collection of Java EE APIs and technologies which together
  form a core baseline microservice that aims to deliver application portability across multiple runtimes.

- MicroProfile 1.0 spec includes a subset of the 30+ Java Enterprise specifications:
  - JAX-RS 2.0 for RESTful endpoints
  - CDI 1.1 for extensions and dependency injection
  - JSON-P 1.0 for processing JSON messages.

- MicroProfile 1.2  (September 2017) include:
  - Configuration 1.1
  - Fault Tolerance
  - JWT
  - Metrics
  - Health Check

- MicroProfile 2.0 (Future). It is expected it will align all APIs to Java EE 8.

- vendors runtime support:
  - WebSphere Liberty IBM
  - TomEE from Tomitribe
  - Payara
  - RedHat's WildFly Swarm
  - KumuluzEE.

- Community support:
  - London Java Community
  - SOUJava
  - ...

- key code sample consists of four microservices and a front-end application.
  Vendor            |     JAR |      StartUp
                    | size/Mb | Time in Secs
  WebSphere Liberty |   35    |            7
  WildFly Swarm     |   65    |            6
  Payara            |   33    |            5
  TomEE             |   35    |            3
  KumuluzEE*        |   11    |            2

- CDI-Centric Programming Model
  - Context and Dependency Injection specification
  - Two of its most powerful features are interceptors and observers.
    - Interceptors perform cross-cutting tasks that are orthogonal to business logic
      such as auditing, logging, and security
    - The baked-in event notification model implements the observer
      pattern to provide a powerful and lightweight event notification system
      that can be leveraged system-wide.
[[}]]

# JavaPoet [[{java_lang,01_PM.TODO]]
@[https://github.com/square/javapoet]
- Library/API for generating .java source files.
- Useful for things like:
  - annotation processing
  - interacting with metadata files (e.g., database schemas, protocol formats).
  - Transpiler (language A → Java Src ).
    keeping a single source of truth for the metadata .
[[}]]

# R2DBC API [[{async/reactive,persistence.sql,01_PM.TODO]]
@[https://www.infoq.com/news/2018/10/springone-r2dbc]
## Project initiated by Pivotal to provide an async/reactive alternative to JDBC.

  WARN : Since Spring Data R2dbc evolved very quickly, thre are plenty
         of breaking changes introduced since Spring 5.2 and Spring
         Data R2dbc 1.2.
         breaking changes (Compared to Spring Data R2dbc 1.1):
           · Spring Data R2dbc 1.1 DatabaseClient was split into two parts.
             a simple new DatabaseClient is part of Spring framework, as an
             alternative of Jdbc.
           · Another part of the old DatabaseClient is reorganized into a new
             class R2dbcEntityTemplate which acts as the role of JdbcTemplate.
  Ex:
  connectionFactory.create()
    .flatMapMany ( conn ->
       conn.createStatement ( "SELECT value FROM test" )
          .execute()
            .flatMap (result ->
              result.map(( row, metadata -→ row.get("value"))))

  spring:
    r2dbc:                 ← ... (src/main/resources/)application.yml  example:
      username: XXX
      password: XXX
      url: r2dbc:postgresql://...:5432/ddbb_app01
      pool:
        max-create-connection-time: 5s
        initial-size: 5        ←················ probably much lower numbers than
        max-size: 10                             those used for JDBC.
[[}]]

# Nailgun [[{devops.containarization,scalability.jvm,01_PM.TODO]]
- Nailgun is a client, protocol, and server for running Java programs
  from the command line without incurring the JVM startup overhead.

- Programs run in the server (which is implemented in Java), and are
  triggered by the client (written in C), which handles all I/O.

@[https://github.com/facebook/nailgun]
[[}]]

# 9 Profiling tools [[{java_lang.profiling,01_PM.TODO]]
@[https://blog.idrsolutions.com/2014/06/java-performance-tuning-tools/]
[[}]]

# A Year with Java 11 in Production!  [[{01_PM.TODO]]
@[https://www.infoq.com/presentations/java-11-production-story/?itm_source=www.oficina24x7.com]
Andrzej Grzesik talks about Revolut’s experience in running Java 11
in production for over a year. He talks about the doubts they had,
some pain points and gains, as well as surprises that surprised them.
He discusses tools, alternative JVM languages, and some 3rd party
products.
[[}]]

# Aviam:Light Weight JVM [[{jvm,01_PM.TODO]]
https://readytalk.github.io/avian/  ("Embedded java")
Avian is a lightweight virtual machine and class library designed to
provide a useful subset of Java’s features, suitable for building
self-contained applications.

From Mike's blog: https://blog.plan99.net/kotlin-native-310ffac94af2
  | Enter Avian
  |
  |     “Avian is a lightweight virtual machine and class library
  |    designed to provide a useful subset of Java’s features, suitable
  |    for building self-contained applications.”
  |
  | So says the website. They aren’t joking. The example app demos
  | use of the native UI toolkit on Windows, MacOS X or Linux. It’s not
  | a trivial Hello World app at all, yet it’s a standalone
  | self-contained binary that clocks in at only one megabyte. In
  | contrast, “Hello World” in Go generates a binary that is 1.1mb in
  | size, despite doing much less.
  |
  | Avian can get these tiny sizes because it’s fully focused on
  | doing so: it implements optimisations and features the standard
  | HotSpot JVM lacks, like the use of LZMA compression and ProGuard to
  | strip the standard libraries. Yet it still provides a garbage
  | collector and a JIT compiler.
[[}]]

# R2DBC [[{persistence.sql,async/reactive,01_PM.radar]]
https://www.infoq.com/news/2018/10/springone-r2dbc
  Experimental Reactive Relational Database Connectivity Driver, R2DBC, Announced at SpringOne
[[}]]
# jEnv [[{devops,01_PM.TODO]]
@[http://www.jenv.be/]

 command line tool to help you forget how to set the JAVA_HOME environment variable:

  Configuration:
 $ jenv add /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home
   oracle64-1.6.0.39 added
 $ jenv add /Library/Java/JavaVirtualMachines/jdk17011.jdk/Contents/Home
   oracle64-1.7.0.11 added

  Ussage:
  List managed JDKs

  $ jenv versions
    system
    oracle64-1.6.0.39
    * oracle64-1.7.0.11 (set by /Users/hikage/.jenv/version)

  $ jenv global oracle64-1.6.0.39 Configure global version
  $ jenv local oracle64-1.6.0.39 Configure local version (per directory)
  $ jenv shell oracle64-1.6.0.39 Configure shell instance version
[[}]]

# SmallRye Mutiny [[{async/reactive.rxjava,async/reactive,02_doc_has.comparative,qa,01_PM.TODO]]
@[https://smallrye.io/smallrye-mutiny/]

## SmallRye Mutiny is a reactive programming library. Wait? Another one?  Yes!
## Mutiny is designed after having experienced many issues with other
  Reactive programming libraries and having seen many developers lost
  in an endless sequence of flatMap. Mutiny takes a different approach.
  First, Mutiny does not provide as many operators as the other famous
  libraries, focusing instead on the most used operators. Furthermore,
  Mutiny provides a more guided API, which avoids having classes with
  hundreds of methods that cause trouble for even the smartest IDE.
  Finally, Mutiny has built-in converters from and to other reactive
  programing libraries, so you can always pivot.
[[}]]



# Netty [[{async/reactive.io.network,02_doc_has.comparative,01_PM.radar,01_PM.backlog]]
- One Framework to rule them all by Norman Maurer
@[https://www.youtube.com/watch?v=DKJ0w30M0vg]
──────────────────────────────────────────────
# Apache MINA:Netty Alt.
## Apache MINA vs Netty: https://www.youtube.com/watch?v=A2pWsxPWJuc
## network application framework which helps users develop high
  performance and high scalability network applications easily. It provides an
  abstract event-driven asynchronous API over various transports such as TCP/IP
  and UDP/IP via Java NIO.

## Apache MINA is often called:
  - NIO framework library
  - client server framework library, or
  - a networking socket library

## Apache MINA comes with many subprojects :
  - Asyncweb : An HTTP server build on top of MINA asynchronous framework
  - FtpServer : A FTP server
  - SSHd : A Java library supporting the SSH protocol
  - Vysper : An XMPP server
[[}]]
[[}]]


# SwarmCache [[{scalability.distributed,scalability.cache,persistence.jpa,01_PM.low_code,01_PM.TODO]]
SwarmCache is a simple but effective distributed cache. It uses IP
multicast to efficiently communicate with any number of hosts on a
LAN. It is specifically designed for use by clustered,
database-driven web applications. Such applications typically have
many more read operations than write operations, which allows
SwarmCache to deliver the greatest performance gains. SwarmCache uses
JavaGroups internally to manage the membership and communications of
its distributed cache.

Wrappers have been written that allow SwarmCache to be used with the
Hibernate and JPOX persistence engines.
[[}]]

# bytes java [[{01_PM.backlog]]
@[https://github.com/patrickfav/bytes-java]
- utility library that makes it easy to create, parse, transform,
  validate and convert byte arrays in Java
[[}]]

# 3 NIO ways to read files [[{async/reactive.io,persistence.fs,01_PM.TODO]]
@[https://howtodoinjava.com/java7/nio/3-ways-to-read-files-using-java-nio/]
- read small file using ByteBuffer and RandomAccessFile
- FileChannel and ByteBuffer to read large files
- Example 3: Reading a file using memory-mapped files in Java
[[}]]

# JLink [[{devops.containarization,01_PM.TODO]]
@[https://docs.oracle.com/javase/9/tools/jlink.htm]
- You can use the jlink tool to assemble and optimize a set of modules
  and their dependencies into a custom runtime image

TODO:
@[https://medium.com/azulsystems/using-jlink-to-build-java-runtimes-for-non-modular-applications-9568c5e70ef4]
[[}]]

[[{java_lang.configuration,standards.JSR330,qa,02_doc_has.comparative,Spring,standards.JSR330]]
# Spring vs Google Guice
@[https://www.baeldung.com/guice-spring-dependency-injection]
────────────────────────
# Dependency injection
@[http://www.theserverside.com/feature/Spring-vs-Guice-The-Clash-of-the-IOC-Containers]
A: t's important to realize that Dagger was created after Guice, by one
of Guice's creators ("Crazy Bob" Lee) after his move to Square:
- Spring was originally released in October 2002.
- Google originally publicly released Guice in March 2007.
- JSR-330 formalized javax.inject annotations in October 2009,
  with heavy input from Google (Bob Lee), Spring, and other industry
  players.
- Square originally released Dagger 1 publicly in May 2013.
- Google originally released Dagger 2 publicly in April 2015.
- Square marked Dagger 1 as deprecated 10 days ago,
  on September 15, 2016.
# JSR-330: Provider<MyTargetBean>
@[http://javax-inject.github.io/javax-inject/]

FROM https://github.com/google/guice/wiki/JSR330
- JSR-330 standardizes annotations like @Inject and the Provider
  interfaces for Java platforms.
- It doesn't currently specify how applications are configured, so it
  has no analog to Guice's modules.
[[}]]

# Crypto.API(JCA) [{security.cryptography,security.secret_mng,security.aaa,01_PM.TODO]]
  WARN : Prefer a high level cryptographic API like Google Tink
         when possible.

  - See also:
    - Cryptography map:
    @[../General/cryptography_map.html]

    - Bounce Castle FIPS JCA provider
    @[https://www.bouncycastle.org/fips-java/BCFipsIn100.pdf]

    PKCS#11 Ref.guide : [TODO]
  @[https://docs.oracle.com/javase/7/docs/technotes/guides/security/p11guide.html]
  About PCKS#11: @[http:./../General/cryptography_map.html?topics=pkcs]
[[}]]

# Loading properties [[{java_lang.configuration,01_PM.low_code,01_PM.TODO]]
NOTE: Probably is better to use ENV.VARs to simplify compatibility
      with container deployments.

Config properties files located in .../src/main/resources/db_config.properties

InputStream is = getClass().getResurceAsStream("/db_config.properties");
Properties props = new Properties();
props.load(is);
is.close();

└ How to add comments to properties file:
  https://www.tutorialspoint.com/how-to-read-write-data-from-to-properties-file-in-java
[[}]]

# XML Stream parsing [[{persistence.xml,01_PM.TODO]]
[TODO]: Write summary of best XML libraries.
@[https://github.com/FasterXML/aalto-xml]
@[http://www.studytrails.com/java/xml/aalto/java-xml-aalto-stax-async-basic/]
@[https://docs.oracle.com/javase/tutorial/jaxp/stax/why.html]
@[https://gist.github.com/shvalb/38cc8f454ee84a2032d2b341a9b8aeae]
@[http://www.studytrails.com/java/xml/aalto/java-xml-aalto-introduction/]
@[https://gist.github.com/shvalb/38cc8f454ee84a2032d2b341a9b8aeae]
[[}]]

# CGLIB library [[{JVM.101,01_PM.TODO]]
- CGLIB library: Used for bytecode generation/method injection (Used by
  Spring Framework for example).
[[}]]

# Spring Reactor/Spring-Async [[{async/reactive.rxjava,async/reactive,02_doc_has.comparative,01_PM.TODO]]
@[https://ordina-jworks.github.io/reactive/2016/12/12/Reactive-Programming-Spring-Reactor.html]
@[https://spring.io/blog/2013/05/13/reactor-a-foundation-for-asynchronous-applications-on-the-jvm]
@[https://spring.io/guides/gs/async-method/]
## Q:"Why Reactor when there's already RxJava2?"
   - RxJava2 is java 6 while for Reactor the Spring team decided to go all in
     and focus only on Java 8. This means that you can make use of all the new
     and fancy Java 8 features.
     - If you are going to use Spring 5, Reactor might be the better option.
     - But if you are happy with your RxJava2, there is no direct need to migrate to Reactor."""

[[}]]

# Example JVM config.  [[{jvm,scalability.jvm,01_PM.TODO]]
Server version:        Apache Tomcat/8.x
Server built:          unknown
Server number:         8.0.x
OS Name:               Linux
OS Version:            3.10.0-1062.9.1.el7.x86_64
Architecture:          amd64
Java Home:             /ec/local/appserver/u000/app/java/jdk1.8.0_121-strong/jre
JVM Version:           1.8.0_121-b13
JVM Vendor:            Oracle Corporation
Command line argument: -Djava.util.logging.config.file=.../logging.properties
Command line argument: -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager
Command line argument: -Djdk.tls.ephemeralDHKeySize=2048
Command line argument: -Djava.protocol.handler.pkgs=org.apache.catalina.webresources
Command line argument: -Xms1536m
Command line argument: -Xmx1536m
Command line argument: -XX:MetaspaceSize=512m
Command line argument: -XX:MaxMetaspaceSize=512m
Command line argument: -XX:MaxDirectMemorySize=1G
Command line argument: -XX:+UseParallelGC
Command line argument: -XX:ParallelGCThreads=4
Command line argument: -XX:+UseParallelOldGC
Command line argument: -XX:LargePageSizeInBytes=4m
Command line argument: -XX:-BindGCTaskThreadsToCPUs
Command line argument: -Djava.awt.headless=true
Command line argument: -Dsun.net.inetaddr.ttl=60
Command line argument: -Dsun.net.inetaddr.negative.ttl=5
Command line argument: -Djava.io.tmpdir=/_tmp
Command line argument: -Dfile.encoding=UTF-8
Command line argument: -XX:ErrorFile=./logs/fatal_error/hs_err_pid%p.log
Command line argument: -Dcom.sun.management.jmxremote=true
Command line argument: -Dcom.sun.management.jmxremote.login.config=Tomcat
Command line argument: -Djava.security.auth.login.config=..../login.config
Command line argument: -Dcom.sun.management.jmxremote.access.file=.../jmxremote.access
Command line argument: -Dcom.sun.management.jmxremote.ssl=false
Command line argument: -Djava.rmi.server.hostname=tcsn0201.cc.cec.eu.int
Command line argument: -Dcom.sun.management.jmxremote.ssl.need.client.auth=false
Command line argument: -verbose:gc
Command line argument: -Xloggc:....API_TEST-gc.log
Command line argument: -XX:+PrintGCDetails
Command line argument: -XX:+PrintGCTimeStamps
Command line argument: -XX:+PrintTenuringDistribution
Command line argument: -XX:+PrintGCApplicationConcurrentTime
Command line argument: -XX:+PrintGCApplicationStoppedTime
Command line argument: -Djava.endorsed.dirs=.../tomcat8/endorsed
Command line argument: -Dcatalina.base=...
Command line argument: -Dcatalina.home=...
Command line argument: -Djava.io.tmpdir=.../temp
[[}]]

# mvn: Default Wrapper in 3.7 [[{DevOps.maven,01_PM.TODO]]
https://www.infoq.com/news/2020/04/maven-wrapper/
<hr/>
# Java on VC.Studio
https://devblogs.microsoft.com/java/java-on-visual-studio-code-update-february-2020/?WT.mc_id=social-reddit-marouill
[[}]]

# JHSDB [[{java_lang.debugging,monitoring.forensic,01_PM.TODO]]
https://docs.oracle.com/en/java/javase/12/tools/jhsdb.html
- You use the jhsdb tool to attach to a Java process or to a core dump
  from a crashed Java Virtual Machine (JVM).

- jhsdb is a Serviceability Agent (SA) tool. Serviceability Agent (SA)
  is a JDK component used to provide snapshot debugging, performance
  analysis and to get an in-depth understanding of the Hotspot JVM and
  the Java application executed by the Hotspot JVM.

- Even though native debuggers like gdb are available for examining the
  JVM, unlike jhsdb, these native debuggers do not have an inbuilt
  understanding of the data structures in Hotspot and hence, are not
  able to throw insights on the Java application being executed. jhsdb
  knows about the locations and address ranges of crucial components of
  the JVM like the Java heap, heap generations, regions, code cache,
  etc.
[[}]]

# GraalVM Native Image [[{devops.containarization,scalability.jvm.graalvm,cloud.serverless,01_PM.TODO]]
@[https://jamesward.com/2020/05/07/graalvm-native-image-tips-tricks/]

| FROM oracle/graalvm-ce:20.0.0-java11 as builder
| WORKDIR /app
| COPY . /app
|
| RUN gu install native-image
|
| # Build the app (via Maven, Gradle, etc) and create the native image
| FROM scratch
| COPY --from=builder /app/target/my-native-image /my-native-image
| ENTRYPOINT ["/my-native-image"]

- to build a statically linked native image:
  --static

  ...Luckily GraalVM has a way to also include the necessary system
  libraries in the static native image with musl libc:
  - In your Dockerfile download the musl bundle for GraalVM:

| RUN curl -L -o musl.tar.gz \
|     https://github.com/gradinac/musl-bundle-example/releases/download/v1.0/musl.tar.gz && \
|     tar -xvzf musl.tar.gz

  And then add a native-image parameter that points to the extracted location of the bundle, like:

  -H:UseMuslC=bundle/

  Now your native image will include the standard library system calls that are needed!

- If AOT thing fails, it will fallback to just running the app in the JVM.
  To avoid it running on the JVM:
  --no-fallback

- FAIL-FAST: Don't Defer Problems to Runtime
  - make sure native-image is NOT being run with any of these params:
    --report-unsupported-elements-at-runtime
    --allow-incomplete-classpath
    -H:+ReportUnsupportedElementsAtRuntime

- Reflection Woes:
  - reflection happens at runtime, making it hard for an AOT complier.
  - you can tell GraalVM about what needs reflection access,
    but this can quickly get a bit out-of-hand, hard to derive and maintain.
  - Micronaut and Quarkus do a pretty good job generating the reflection
    configuration at compile time but you might need to augment the
    generated config. (tricky with shaded transitive dependencies).

  - To reliably generate a reflection config you need to exercise as many
    execution code paths as possible, ideally by running unit/integration tests.
  - GraalVM has a way to keep track of reflection and output the configuration.
    - Run the app on GraalVM and use a special Java agent that will be able to
      see the reflective calls.
    STEPS:
      - grab GraalVM Community Edition:
      - set JAVA_HOME and PATH.
      - from release assets grab the right native-image-installable-svm-BLAH.jar file
        and extract it in the root of your GraalVM JAVA_HOME directory.
      - run tests with parameter:
        -agentlib:native-image-agent=config-output-dir=src/graal"
        (This will generate the reflection config (and possibly other configs for
         dynamic proxies, etc).
      - tell native-image about those configs, like:
        -H:ReflectionConfigurationFiles=src/graal/reflect-config.json

   - For Quarkus & Micronaut see their docs (Quarkus / Micronaut) for details on
     how to add your own reflection config files.
[[}]]

# Async Servlets 3.0+: [[{async/reactive.servlets,standards.jee.servlets,01_PM.TODO]]
https://www.infoworld.com/article/2077995/java-concurrency-asynchronous-processing-support-in-servlet-3-0.html
[[}]]

# Real-World Java 9 [[{async/reactive.101,java_lang.flow_api,java_lang.101,01_PM.TODO]]
@[https://www.infoq.com/presentations/java9-flow-stream-api/?utm_source=oficina24x7.com]

## Real-World Java 9:
  Trisha Gee shows via live coding how we can use the new Flow API to
  utilize Reactive Programming, how the improvements to the Streams API
  make it easier to control real-time streaming data and how the
  Collections convenience methods simplify code. She talks about other
  Java 9 features, including some of the additions to interfaces and
  changes to deprecation.
[[}]]

# Deplo WAR to k8s with JKube [[{devops.containarization,standards.jee.war,cloud.k8s]]
@[https://developers.redhat.com/blog/2020/07/27/deploy-your-java-web-application-into-the-cloud-using-eclipse-jkube/]

## JKube Maven  converts war (dependent of a container) into cloud-native app.

  - pom.xml:
    <!-- ... -->
    <packaging>war</packaging>
    <!-- ... -->
    <properties>
      <maven.compiler.source>11</maven.compiler.source>
      <maven.compiler.target>11</maven.compiler.target>
      <failOnMissingWebXml>false</failOnMissingWebXml>  ← configure maven-war-plugin so
                                                          that it won't fail due
      <!-- ... -->                                        to a missing web.xml file.

      <jkube.enricher.jkube-service.type>NodePort</jkube.enricher.jkube-service.type>
      └────────────────────────────────┬────────────────────────────────────────────┘
      configure JKube to create service-resource manifest using NodePort as the spec.type.

    </properties>
    <dependencies>
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>${version.spring}</version>
      </dependency>
      <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>4.0.1</version>
        <scope>provided</scope>
      </dependency>
    </dependencies>
    <build>
      <plugins>
        <plugin>
          <groupId>org.eclipse.jkube</groupId>
          <artifactId>kubernetes-maven-plugin</artifactId> ← Alt: openshift-maven-plugin.
          <version>${version.jkube}</version>
        </plugin>
        <!-- ... -->
      </plugins>
    </build>

## example project contains three Java classes:
  └ ExampleInitializer: replaces standard WEB-INF/web.xml
    registering Spring's DispatcherServlet directly.

       final AnnotationConfigWebApplicationContext context
              = new AnnotationConfigWebApplicationContext();
       context.register(ExampleConfiguration.class);
       context.setServletContext(servletContext);
       final ServletRegistration.Dynamic dsr
              = servletContext.addServlet("dispatcher",
                new DispatcherServlet(context));
       dsr.setLoadOnStartup(1);
       dsr.addMapping("/");

  └ ExampleConfiguration: Spring-specific config enabling Spring MVC.

  └ ExampleResource: standard Spring @RestController.

- Deploy to Kubernetes:
    $ mvn clean package    ← generate war in target/
    $ mvn k8s:build        ← Build OCI image (webapp/example:latest)
                             using jkube/jkube-tomcat9-binary-s2i by default.
                             Alternatives like Jetty can be used
    $ mvn k8s:resource     ← create required cluster config resource manifests
    $ mvn k8s:apply        ← apply to (kubectl configured) cluster
    $ kubectl get pod      ← Verify that app is running
    $ mvn k8s:log          ← Retrieve app Logs
[[}]]


# Conclave [[{security.secret_mng,01_PM.TODO]]
https://medium.com/corda/conclave-beta-3-graalvm-mail-more-5038bd6d50da
Today we’re announcing a new beta release of Conclave, a platform
that makes it easy to use secure hardware enclaves with Java. You can
use enclaves to:
- Solve complex multi-party data problems, by running programs on a
  computer that prevents the hardware owner from seeing the
  calculations.
- Protect sensitive data from the cloud.
- Make your hosted service auditable and trustworthy.
- Upgrade privacy on distributed ledger platforms like Corda.
[[}]]

# Checkpointing outside the JVM [[{scalability.JVM,DevOps,01_PM.TODO]] #[jvm_app_checkpoint]
@[https://developers.redhat.com/blog/2020/10/15/checkpointing-java-from-outside-of-java/]
When OpenJDK‘s Java virtual machine (JVM) runs a Java application,
it loads a dozen or so classes before it starts the main class.

  STANDARD JVM START "WARM-UP"  vs   NEW APPROACH: WARM UP ONCE
  ----------------------------       ---------------------------
 - runs method several hundred       - 1st  run : WARM Up once and checkpoint
   times before optimizing it.       - Next runs: restore checkpointed app.
  cost of long startup times.          Start time seconds → millisecs!!!

  Checkpoint inside JVM HOW-TO:  [TODO]
@[https://www.jfokus.se/jfokus19-preso/Checkpointing-Java.pdf]

  Checkpoint Outside JVM HOW-TO:
        - Under the hood it uses Linux Checkpoint/Restore in Userspace (CRIU).
        @[https://www.criu.org/Main_Page]

  $ CONSOLE 1                              CONSOLE
  $ $ setsid java -XX:-UsePerfData \     $ $ sudo criu dump -t $pid \    ← stops and checkpoint
  $     -XX:+UseSerialGC Scooby          $    --shell-job -o dump.log      app

                                         $ $ sudo restore --shell-job \  ← Restore app
                                         $    -d -vvv -o restore.log
[[}]]

# Jrpip: Low code RMI [[{architecture.distributed,01_PM.low_code,01_PM.TODO]] #[jrpip]
  Let developers concentrate on logic vs network plumbing and TCP errors.
- Jrpip mplements remote interface method invocation which allows different
  Java processes to interact with one another.
- designed to increase developer efficiency by providing useful features, such as
  the ability to deploy in any servlet container, interface
  implementation that doesn’t require RemoteException and automatic
  retries with once-execute semantics.
- efficient binary protocol that is streamed, reducing memory
  consumption and garbage collector issues.

- See also notes on gRPC:
  @[./java_map.html?query=grpc]
  @[../WebTechnologies/map.html?topics=grpc&showSearchMenu=false]
[[}]]

# SMTP: Sending mail [[{messaging.mail.smtp,security.notifications]]
- Based on AWS guide @[https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-using-smtp-java.html]
  but applies to any standard SMTP e-mail server.

  - pom coordinates:
    <dependency>
        <groupId>com.sun.mail</groupId>
        <artifactId>javax.mail</artifactId>
        <version>1.6.2</version>
    </dependency>

  import java.util.Properties;

  import javax.mail.Message;
  import javax.mail.Session;
  import javax.mail.Transport;
  import javax.mail.internet.InternetAddress;
  import javax.mail.internet.MimeMessage;

  public class SendMailThroughSMTP {

      static final String
          FROM     = "...", // ← in AWS this address must be verified
          FROMNAME = "...", // ← Human readable FROM
          TO       = "...", // ← in AWS if sending account is still in the
                            //   sandbox this address must be  case-sensitive  verified.

          CONFIGSET = "ConfigSet", // ← Configuration Set name used for this message.
                                   //  If commented out remove header below.   *
          BODY      = String.join( "\n",
              "<h1>header</h1>", "html line2", "html line3", "..." ),
          SMTP_HOST = "email-smtp.us-west-2.amazonaws.com",
          SMTP_USERNAME = "..." , //  *
          SMTP_PASSWORD = "...";
          // SMTP_HOST REF: https://docs.aws.amazon.com/ses/latest/DeveloperGuide/regions.html#region-endpoints

      static final int PORT = 587; // The port you will connect to on the Amazon SES SMTP endpoint.


      public static void main(String[] args) throws Exception {
          final Properties props = System.getProperties();
          props.put("mail.smtp.port"           , PORT  );
          props.put("mail.transport.protocol"  , "smtp");
          props.put("mail.smtp.starttls.enable", "true");
          props.put("mail.smtp.auth"           , "true");
          Session session = Session.getDefaultInstance(props); // ← represents mail session

          final MimeMessage
              msg = new MimeMessage(session);    // ← Build message
              msg.setFrom(new InternetAddress(FROM,FROMNAME));
              msg.setRecipient(
                     Message.RecipientType.TO,
                     new InternetAddress(TO));
              msg.setSubject(MAIL_SUBJECT);
              msg.setContent(HTML_BODY,"text/html");
              msg.setHeader(                     // Remove if not using a configuration set
                     "X-SES-CONFIGURATION-SET",
                     CONFIGSET);

          final Transport transport =            // ← Create transport
              session.getTransport();

          try { // Send the message.
              transport.connect(SMTP_HOST, SMTP_USERNAME, SMTP_PASSWORD); // Connect to SMTP using username/pass
              transport.sendMessage(msg, msg.getAllRecipients());    // Send email.
          } catch (Exception ex) {
              // process and rethrow
          }
          finally { transport.close(); }
      }
  }

   *  : More info at
       https://docs.aws.amazon.com/ses/latest/DeveloperGuide/using-configuration-sets.html

   *  : AWS note, SMTP credentials are different to AWS credentials.
        SMTP username credential is 20-chars (letters and numbers)
[[}]]

# jFleet [[{scalability.persistence,persistence.jpa,persistence.sql,01_PM.TODO]]
@[https://github.com/jerolba/jfleet]
· JFleet is a Java library which persist in database large collections
  of Java POJOs as fast as possible, using the best available technique
  in each database provider, achieving it with alternate persistence
  methods from each JDBC driver implementation.

· Its goal is to store a large amount of information in a single table
  using available batch persistence techniques.

· despite being able to use JPA annotations to map Java objects to
  tables and columns, JFleet is not an ORM.
[[}]]

# JVM Anatomy [[{jvm.101,01_PM.TODO]]
https://shipilev.net/jvm-anatomy-park/
https://shipilev.net/jvm-anatomy-park/22-safepoint-polls/
[[}]]

# Java Class Library (JCL, rt.jar) [[{java_lang.101,01_PM.TODO]]
rt.jar contains the Java Class Library (JCL)
https://en.wikipedia.org/wiki/Java_Class_Library

- The Java Class Library (JCL) is a set of dynamically loadable
  libraries that Java applications can call at run time. Because the
  Java Platform is not dependent on a specific operating system,
  applications cannot rely on any of the platform-native libraries.
  Instead, the Java Platform provides a comprehensive set of standard
  class libraries, containing the functions common to modern operating
  systems.

- Java Class Library (JCL) is almost entirely written in Java, except
  for the parts that need direct access to the hardware and operating
  system (such as for I/O or bitmap graphics). The classes that give
  access to these functions commonly use Java Native Interface wrappers
  to access operating system APIs.

- The Java Class Library (rt.jar) is located in the default bootstrap
  classpath[1] and does not have to appear in the classpath declared
  for the application. The runtime uses the bootstrap class loader to
  find the JCL.

  The Java Module System (part of the Java 9 release) broke the
  monolithic "rt.jar" JAR file and modularized the JCL itself in
  several modules with specified dependencies.
[[}]]

# Java Threading resources [[{concurrency,01_PM.TODO]]
@[https://avaldes.com/?s=java+thread]

- Java Thread, Concurrency and Multithreading Tutorial
- Java Threads and Concurrent Locks with Examples
  https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html
- Java Thread Deadlock Example and Thread Dump Analysis using VisualVM
- Java Thread Starvation and Livelock with Examples
- Examining Volatile Keyword with Java Threads
- Java Threads Wait, Notify and NotifyAll Example
[[}]]

# JIMFS [[{async/reactive.io,persistence.fs,01_PM.TODO]]
@[https://github.com/google/jimfs]
- Jimfs supports almost all the APIs under java.nio.file:
  - Create/delete/move/Copy  files/dirs.
  - Read/write files with FileChannel/SeekableByteChannel/InputStream/OutputStream/...
  - Symbolic links.
  - Hard links to regular files.
  - SecureDirectoryStream, for operations relative to an open directory.
  - Glob and regex path filtering with PathMatcher.
  - Watching for changes to a directory with a WatchService.
  - Built-in (file) attribute views that can be supported include
    "basic", "owner", "posix", "unix", "dos", "acl" and "user".
- Simple ussage:
  import com.google.common.jimfs.Configuration;
  import com.google.common.jimfs.Jimfs;
  ...

  // For a simple file system with Unix-style paths and behavior:
  final FileSystem fs = Jimfs.newFileSystem(Configuration.unix());
  final Path foo = fs.getPath("/foo");
  Files.createDirectory(foo);
  final Path hello = foo.resolve("hello.txt");
  Files.write(hello, ImmutableList.of("hello world"), StandardCharsets.UTF_8);


[[}]]

# Java Poet [[{01_PM.backlog]]
@[https://github.com/square/javapoet]
## Java API for generating .java source files.
## useful for:
  - transpiling: Custom language to java.
  - annotation processing
  - interacting with metadata files (database schemas, protocol formats,...).

## Avoid boilerplate while also keeping a  single source of truth .
[[}]]

# Storing HttpSessions to Redis [[{persistence.session,scalability.cache,architecture.distributed]]
@[https://github.com/AmadeusITGroup/HttpSessionReplacer]
AmadeusITGroup/HttpSessionReplacer: Store JEE Servlet HttpSessions in Redis
[[}]]

# Dekorate k8s annotations [[{cloud.k8s,01_PM.backlog]]
@[https://developers.redhat.com/blog/2021/03/17/using-dekorate-to-generate-kubernetes-manifests-for-java-applications/]
## ex:
  JAVA ANOTATION INPUT
  ====================
  @KubernetesApplication(
     name = "hello-world-fwless-k8s",
     ports = @Port(name = "web", containerPort = 8080),
     expose = true,
     host = "fw-app.127.0.0.1.nip.io",
     imagePullPolicy = ImagePullPolicy.Always
  )

  Kubernetes Output:
  ====================
  · target/classes/META-INF/dekorate/kubernetes.yml
    Use like:
  $ $ kubectl create ns demo
  $ $ kubectl apply -f kubernetes.yml -n demo
  · target/classes/META-INF/dekorate/kubernetes.json

## Integration with Jib to generate OCI images is also available.
[[}]]

# Servlet servers Arch [[{01_PM.TODO,standards.jee.servlets]]
embedded servers usually comprise two logical components:

┌───────────────────────────────────┬────────────────────────────────
│  LOGICAL COMPONENT                │  TOMCAT equivalent
├───────────────────────────────────┼────────────────────────────────
│  a web server component           │  Coyote
│  listening for HTTP requests and  │
│  returning HTTP responses         │
├───────────────────────────────────┼────────────────────────────────
│  an execution context to make     │  Catalina, based on Servlet API
│  a Java web application interact  │  (usually called the Servlet
│  with the web server.             │  Container)
└───────────────────────────────────┴────────────────────────────────
[[}]]

# Yourkit profiler [[{java_lang.profiling,01_PM.radar]]
@[https://www.yourkit.com/java/profiler/features/]
## Yourkit: commercial (non OOSS) profiler with advanced features
## Tight integration with your IDE
## "Smart what if"  allows to evaluate performance gains of supposed optimizations
  without re-profiling the application.
## CPU call tree
## Flame graphs
## Database queries and web requests:
  - display slow SQL queries and web requests.
  (support for MongoDB, Cassandra, HBase,...)

## Memory profiling: object heap, traversing of object graph.
  The Profiler chooses the best way to show you a content of a HashMap, String, ... ).
  For each object you can see how much memory it retains, and what happens when
  particular reference in object graph does not exist.
  This saves time, and lets you estimate the expected memory leak fix without changing the code.

## Memory profiling:

## 40+ comprehensive inspections are waiting to make your code faster and more efficient.

## Profiler knows a lot about typical issues in Java applications and automatically finds them.

## Report inefficient collections and I/O operations.

## Find/Resolve thread synchronization issues.
  It is possible to combine thread states with HTTP requests and SQL queries to get
  the full picture how the requests are processed by your applications.

## Exception profiling: Massive exception throwing is a common but often hidden
  performance problem.

## Deobfuscate the code on the fly restoring original class, method and field names of
  applications obfuscated with ProGuard, yGuard, Zelix KlassMaster, Allatori, and other
  popular Java obfuscators.

## control profiling overhead up to production profiling.

## Extensible API to create custom probes.

## Command line support. (UI free).

## free licenses for non-commercial open source projects.
  Special offers for educational and scientific organizations.
[[}]]

## LMAX Disruptor: High Perf Inter-Thread Messaging Library [[{concurrency,01_PM.radar]]
@[https://lmax-exchange.github.io/disruptor/]

See also:
@[https://www.infoq.com/articles/High-Performance-Java-Inter-Thread-Communications/]

@[https://www.infoq.com/news/2013/05/lmax-zing]
LMAX Exchange Getting Up To 50% Improvement in Latency From Azul's Zing JVM
Interesting points about GC tunning.
[[}]]

## Tribe: reliable multicast [[{java_lang.io.multicast,architecture.distributed,scalability.distributed]]
                            [[doc_has.comparative,qa,01_PM.low_code,01_PM.radar]]
REF: @[http://tribe.ow2.org/]
- Unlike JGroups, Tribe only targets reliable multicast
 (no probabilistic delivery) and is optimized for cluster
 communications.

## JGroups multicast
@[http://www.jgroups.org/]
- toolkit for reliable multicast communication.
- point-to-point FIFO communication channels (basically TCP)
- Targets high performance cluster environments.

- Unlike JGroups, Tribe only targets reliable multicast
  (no probabilistic delivery) and is optimized for
  cluster communications.
[[}]]

# OSV.io [[{scalability.unikernel,security,devops,01_PM.backlog]]
- @[http://osv.io/]
  versatile modular unikernel designed to run unmodified Linux
  applications securely on micro-VMs in the cloud. Built from the ground up for
  effortless deployment and management of micro-services and serverless apps,
  with superior performance. (Includes CRaSH shell)
[[}]]

# Excellent Java Blog (spanish)
  @[https://picodotdev.github.io/blog-bitix/tags/java/">Excellent Java Blog (spanish)

# @[https://github.com/akullpp/awesome-java] Awesome Java

# Amazon CodeGuru [[{qa.testing,cloud.aws,devops,01_PM.backlog]]
- Powered by IA.
- CodeGuru consists of two components
– Amazon CodeGuru Profiler:
helps developers find an application’s most expensive lines
of code along with specific visualizations and recommendations
on how to improve code to save money.
- Amazon CodeGuru Reviewer:
helps enhance the quality of code by scanning for critical issues,
identifying bugs, and recommending how to remediate them.

  ┌→ Write Code
  |    |
  |    v
  |  Review Code  ← CodeGuru Reviewer
  |    |
  |    v
  |  Test App     ← CodeGuru Profiler
  |    |
  |    v
  |  Deploy App
  |    |
  |    v
  |  Run App      ← CodeGuru Profiler
  |    |
  └----┘

- Profiler supports application written
in Java virtual machine (JVM) languages such as Clojure,
JRuby, Jython, Groovy, Kotlin, Scala, and Java.
- Reviewer’s bug-fixing recommendations currently support
Java code stored in GitHub, AWS CodeCommit, or Bitbucket.
[[}]]

# Java, Soft. Arch: E.C.S. Dominon favors composition over inheritance
https://www.reddit.com/r/java/comments/z5yj0i/dominion_vs_artemis_the_missing_benchmarks_link/
Entity Component System (ECS) architecture promotes data-oriented
programming. It’s all about data (components) andfirst-class
functions (systems) that operate on data.This means that, unlike OOP,
data and operations are not encapsulated together in objects, which
are called entities inECS.Entities model the business objects of the
user application, and the entity promotes “composition over
inheritance” bygrouping a dynamic list of components to define its
specific features.

# Spring Batch 5.0GA
  https://www.reddit.com/r/java/comments/z3vmb2/spring_batch_50_goes_ga/

# What's New in Spring Framework 6.x
 · spring-projects/spring-framework Wiki · GitHub
https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-6.x/
Juergen Hoeller edited this page Nov 11, 2022 · 27 revisions s
Entire framework codebase based on Java 17 source code level
now.Migration from javax to jakarta namespace for Servlet, JPA,
etc.Runtime compatibility with Jakarta EE 9 as well as Jakarta EE 10
APIs.Compatible with latest web servers: Tomcat 10.1, Jetty 11,
Undertow 2.3.Early compatibility with virtual threads (in preview as
of JDK 19).General Core RevisionUpgrade to ASM 9.4 and Kotlin
1.7.Complete CGLIB fork with support for capturing CGLIB-generated
classes.Comprehensive foundation for Ahead-Of-Time
transformations.First-class support for GraalVM native images (see
related Spring Boot 3 blog post).Core ContainerBasic bean property
determination without java.beans.Introspector by default.AOT
processing support in GenericApplicationContext
(refreshForAotProcessing).Bean definition transformation based on
pre-resolved constructors and factory methods.Support for early proxy
class determination for AOP proxies and configuration
classes.PathMatchingResourcePatternResolver uses NIO and module path
APIs for scanning, enabling support for classpath scanning within a
GraalVM native image and within the Java module path,
respectively.DefaultFormattingConversionService supports ISO-based
default java.time type parsing.Data Access and TransactionsSupport
for predetermining JPA managed types (for inclusion in AOT
processing).JPA support for Hibernate ORM 6.1 (retaining
compatibility with Hibernate ORM 5.6).Upgrade to R2DBC 1.0 (including
R2DBC transaction definitions).Removal of JCA CCI support.Spring
MessagingRSocket interface client based on @RSocketExchange service
interfaces.Early support for Reactor Netty 2 based on Netty 5
alpha.Support for Jakarta WebSocket 2.1 and its standard WebSocket
protocol upgrade mechanism.General Web RevisionHTTP interface client
based on @HttpExchange service interfaces.Support for RFC 7807
problem details.Unified HTTP status code handling.Support for Jackson
2.14.Alignment with Servlet 6.0 (while retaining runtime
compatibility with Servlet 5.0).Spring MVCPathPatternParser used by
default (with the ability to opt into PathMatcher).Removal of
outdated Tiles and FreeMarker JSP support.Spring WebFluxNew PartEvent
API to stream multipart form uploads (both on client and server).New
ResponseEntityExceptionHandler to customize WebFlux exceptions and
render RFC 7807 error responses.Flux return values for non-streaming
media types (no longer collected to List before written).Early
support for Reactor Netty 2 based on Netty 5 alpha.JDK HttpClient
integrated with WebClient.ObservabilityDirect Observability
instrumentation with Micrometer Observation in several parts of the
Spring Framework. The spring-web module now requires
io.micrometer:micrometer-observation:1.10+ as a compile
dependency.RestTemplate and WebClient are instrumented to produce
HTTP client request observations.Spring MVC can be instrumented for
HTTP server observations using the new
org.springframework.web.filter.ServerHttpObservationFilter.Spring
WebFlux can be instrumented for HTTP server observations using the
new
org.springframework.web.filter.reactive.ServerHttpObservationFilter.In
tegration with Micrometer Context Propagation for Flux and Mono
return values from controller methods.TestingSupport for testing
AOT-processed application contexts on the JVM or within a GraalVM
native image.Integration with HtmlUnit 2.64+ request parameter
handling.Servlet mocks (MockHttpServletRequest, MockHttpSession) are
based on Servlet API 6.0 now.

# https://www.reddit.com/r/java/comments/z1s58l/spring_6_migration_guide/

# Porting Million Lines of Code from Java to Kotlin at Meta
  https://www.infoq.com/news/2022/11/meta-port-java-kotlin/

# Getting Ready for Spring Framework 6 - Spring Framework Guru
  https://springframework.guru/getting-ready-for-spring-framework-6/

# BellSoft Introduces Alpaquita Linux
  https://www.infoq.com/news/2022/10/java-news-roundup-sep26-2022/
  BellSoft has introduced Alpaquita Linux, an operating system tailored
  for the Java programming language. Based on Alpine Linux, this new
  operating system: enables the effective containerization of Java
  applications developed with Liberica JDK; improves security; contains
  new features for better performance; and allows developers to take
  advantage of native image technology through the Liberica Native
  Image Kit. InfoQ will follow up with a more detailed news story.

# Project Loom: Revolution in Java Concurrency or Obscure Implementation Detail?
  https://www.infoq.com/presentations/loom-java-concurrency/
    Project Loom: Revolution in Java Concurrency or Obscure
  Implementation Details Summary Tomasz Nurkiewicz explores what Loom
  is, how it's implemented, what problems it solves, its shortcomings,
  and will it make reactive programming obsolete? Bio Tomasz Nurkiewicz
  works in the e-commerce sector. Involved in open-source, DZone’s
  Most Valuable Blogger, used to be very active on StackOverflow.
  Author, trainer, conference speaker, technical reviewer, runner.
  Claims that code not tested automatically is not a feature but just a
  rumor. Wrote a book on RxJava for O’Reilly. About the conference
  QCon Plus is a virtual conference for senior software engineers and
  architects that covers the trends, best practices, and solutions
  leveraged by the world's most innovative software organizations.
  				INFOQ EVENTS

  	Oct 24-28 (In-Person, San Francisco)

# Nurkiewicz: I'd like to talk about Project Loom, a very new and
exciting initiative that will land eventually in the Java Virtual
Machine. Most importantly, I would like to briefly explain whether
it's going to be a revolution in the way we write concurrent
software, or maybe it's just some implementation detail that's going
to be important for framework or library developers, but we won't
really see it in real life. The first question is, what is Project
Loom? The question I give you in the subtitle is whether it's going
to be a revolution or just an obscure implementation detail. My name
is Tomasz Nurkiewicz.First of all, we would like to understand how we
can create millions of threads using Project Loom. This is an
overstatement. In general, this will be possible with Project Loom.
As you probably know, these days, it's only possible to create
hundreds, maybe thousands of threads, definitely not millions. This
is what Project Loom unlocks in the Java Virtual Machine. This is
mainly possible by allowing you to block and sleep everywhere,
without paying too much attention to it. Blocking, sleeping, or any
other locking mechanisms were typically quite expensive, in terms of
the number of threads we could create. These days, it's probably
going to be very safe and easy. The last but the most important
question is, how is it going to impact us developers? Is it actually
so worthwhile, or maybe it's just something that is buried deeply in
the virtual machine, and it's not really that much needed?Before we
actually explain, what is Project Loom, we must understand what is a
thread in Java? I know it sounds really basic, but it turns out
there's much more into it. First of all, a thread in Java is called a
user thread. Essentially, what we do is that we just create an object
of type thread, we parse in a piece of code. When we start such a
thread here on line two, this thread will run somewhere in the
background. The virtual machine will make sure that our current flow
of execution can continue, but this separate thread actually runs
somewhere. At this point in time, we have two separate execution
paths running at the same time, concurrently. The last line is
joining. It essentially means that we are waiting for this background
task to finish. This is not typically what we do. Typically, we want
two things to run concurrently.This is a user thread, but there's
also the concept of a kernel thread. A kernel thread is something
that is actually scheduled by your operating system. I will stick to
Linux, because that's probably what you use in production. With the
Linux operating system, when you start a kernel thread, it is
actually the operating system's responsibility to make sure all
kernel threads can run concurrently, and that they are nicely sharing
system resources like memory and CPU. For example, when a kernel
thread runs for too long, it will be preempted so that other threads
can take over. It more or less voluntarily can give up the CPU and
other threads may use that CPU. It's much easier when you have
multiple CPUs, but most of the time, this is almost always the case,
you will never have as many CPUs as many kernel threads are running.
There has to be some coordination mechanism. This mechanism happens
in the operating system level.User threads and kernel threads aren't
actually the same thing. User threads are created by the JVM every
time you say newthread.start. Kernel threads are created and managed
by the kernel. That's obvious. This is not the same thing. In the
very prehistoric days, in the very beginning of the Java platform,
there used to be this mechanism called the many-to-one model. In the
many-to-one model. The JVM was actually creating user threads, so
every time you set newthread.start, a JVM was creating a new user
thread. However, these threads, all of them were actually mapped to a
single kernel thread, meaning that the JVM was only utilizing a
single thread in your operating system. It was doing all the
scheduling, so making sure your user threads are effectively using
the CPU. All of this was done inside the JVM. The JVM from the
outside was only using a single kernel thread, which means only a
single CPU. Internally, it was doing all this back and forth
switching between threads, also known as context switching, it was
doing it for ourselves.There was also this rather obscure
many-to-many model, in which case you had multiple user threads,
typically a smaller number of kernel threads, and the JVM was doing
mapping between all of these. However, luckily, the Java Virtual
Machine engineers realized that there's not much point in duplicating
the scheduling mechanism, because the operating system like Linux
already has all the facilities to share CPUs and threads with each
other. They came up with a one-to-one model. With that model, every
single time you create a user thread in your JVM, it actually creates
a kernel thread. There is one-to-one mapping, which means
effectively, if you create 100 threads, in the JVM you create 100
kernel resources, 100 kernel threads that are managed by the kernel
itself. This has some other interesting side effects. For example,
thread priorities in the JVM are effectively ignored, because the
priorities are actually handled by the operating system, and you
cannot do much about them.It turns out that user threads are actually
kernel threads these days. To prove that that's the case, just check,
for example, jstack utility that shows you the stack trace of your
JVM. Besides the actual stack, it actually shows quite a few
interesting properties of your threads. For example, it shows you the
thread ID and so-called native ID. It turns out, these IDs are
actually known by the operating system. If you know the operating
system's utility called top, which is a built in one, it has a switch
-H. With the H switch, it actually shows individual threads rather
than processes. This might be a little bit surprising. After all, why
does this top utility that was supposed to be showing which processes
are consuming your CPU, why does it have a switch to show you the
actual threads? It doesn't seem to make much sense.However, it turns
out, first of all, it's very easy with that tool to show you the
actual Java threads. Rather than showing a single Java process, you
see all Java threads in the output. More importantly, you can
actually see, what is the amount of CPU consumed by each and every of
these threads? This is useful. Why is that the case? Does it mean
that Linux has some special support for Java? Definitely not. Because
it turns out that not only user threads on your JVM are seen as
kernel threads by your operating system. On newer Java versions, even
thread names are visible to your Linux operating system. Even more
interestingly, from the kernel point of view, there is no such thing
as a thread versus process. Actually, all of these are called tasks.
This is just a basic unit of scheduling in the operating system. The
only difference between them is just a single flag, when you're
creating a thread rather than a process. When you're creating a new
thread, it shares the same memory with the parent thread. When you're
creating a new process, it does not. It's just a matter of a single
bit when choosing between them. From the operating system's
perspective, every time you create a Java thread, you are creating a
kernel thread, which is, in some sense you're actually creating a new
process. This may actually give you some overview like how
heavyweight Java threads actually are.First of all, they are Kernel
resources. More importantly, every thread you create in your Java
Virtual Machine consumes more or less around 1 megabyte of memory,
and it's outside of heap. No matter how much heap you allocate, you
have to factor out the extra memory consumed by your threads. This is
actually a significant cost, every time you create a thread, that's
why we have thread pools. That's why we were taught not to create too
many threads on your JVM, because the context switching and memory
consumption will kill us.This is where Project Loom shines. This is
still work in progress, so everything can change. I'm just giving you
a brief overview of how this project looks like. Essentially, the
goal of the project is to allow creating millions of threads. This is
an advertising talk, because you probably won't create as many.
Technically, it is possible, and I can run millions of threads on
this particular laptop. How is it achieved? First of all, there's
this concept of a virtual thread. A virtual thread is very
lightweight, it's cheap, and it's a user thread. By lightweight, I
mean you can really allocate millions of them without using too much
memory. There's a virtual thread. Secondly, there's also a carrier
thread. A carrier thread is the real one, it's the kernel one that's
actually running your virtual threads. Of course, the bottom line is
that you can run a lot of virtual threads sharing the same carrier
thread. In some sense, it's like an implementation of an actor system
where we have millions of actors using a small pool of threads. All
of this can be achieved using a so-called continuation. Continuation
is a programming construct that was put into the JVM, at the very
heart of the JVM. There are actually similar concepts in different
languages. Continuation, the software construct is the thing that
allows multiple virtual threads to seamlessly run on very few carrier
threads, the ones that are actually operated by your Linux system.I
will not go into the API too much because it's subject to change. As
you can see, it's actually fairly simple. You essentially say
Thread.startVirtualThread, as opposed to new thread or starting a
platform thread. A platform thread is your old typical user threads,
that's actually a kernel thread, but we're talking about virtual
threads here. We can create a thread from scratch. You can create it
using a builder method, whatever. You can also create a very weird
ExecutorService. This ExecutorService doesn't actually pull threads.
Typically, ExecutorService has a pool of threads that can be reused
in case of new VirtualThreadExecutor, it creates a new virtual thread
every time you submit a task. It's not really a thread pool, per se.
You can also create a ThreadFactory if you need it in some API, but
this ThreadFactory just creates virtual threads. That's very simple
API.The API is not the important part, I would like you to actually
understand what happens underneath, and what impact may it have on
your code bases. A virtual thread is essentially a continuation plus
scheduler. A scheduler is a pool of physical called carrier threads
that are running your virtual threads. Typically, a scheduler is just
a fork join pool with a handful of threads. You don't need more than
one to four, maybe eight carrier threads, because they use the CPU
very effectively. Every time a virtual thread no longer needs a CPU,
it will just give up the scheduler, it will no longer use a thread
from that scheduler, and another virtual thread will kick in. That's
the first mechanism. How does the virtual thread and the scheduler
know that the virtual thread no longer needs a scheduler?This is
where continuations come into play. This is a fairly convoluted
explanation. Essentially, a continuation is a piece of code that can
suspend itself at any moment in time and then it can be resumed later
on, typically on a different thread. You can freeze your piece of
code, and then you can unlock it, or you can unhibernate it, you can
wake it up on a different moment in time, and preferably even on a
different thread. This is a software construct that's built into the
JVM, or that will be built into the JVM.Let's look into a very simple
pseudo-code here. This is a main function that calls foo, then foo
calls bar. There's nothing really exciting here, except from the fact
that the foo function is wrapped in a continuation. Wrapping up a
function in a continuation doesn't really run that function, it just
wraps a Lambda expression, nothing specific to see here. However, if
I now run the continuation, so if I call run on that object, I will
go into foo function, and it will continue running. It runs the first
line, and then goes to bar method, it goes to bar function, it
continues running. Then on line 16, something really exciting and
interesting happens. The function bar voluntarily says it would like
to suspend itself. The code says that it no longer wishes to run for
some bizarre reason, it no longer wishes to use the CPU, the carrier
thread. What happens now is that we jump directly back to line four,
as if it was an exception of some kind. We jump to line four, we
continue running. The continuation is suspended. Then we move on, and
in line five, we run the continuation once again. Will it run the foo
function once more? Not really, it will jump straight to line 17,
which essentially means we are continuing from the place we left off.
This is really surprising. Also, it means we can take any piece of
code, it could be running a loop, it could be doing some recursive
function, whatever, and we can all the time and every time we want,
we can suspend it, and then bring it back to life. This is the
foundation of Project Loom. Continuations are actually useful, even
without multi-threading.Continuations that you see in here are
actually quite common in different languages. You have coroutines or
goroutines, in languages like Kotlin and Go. You have async/await in
JavaScript. You have generators in Python, or fibers in Ruby. All of
these are actually very similar concepts, which are finally brought
into the JVM. What difference does it make? Let's see how thread
sleep is implemented. It used to be simply a function that just
blocks your current thread so that it still exists on your operating
system. However, it no longer runs, so it will be woken up by your
operating system. A new version that takes advantage of virtual
threads, notice that if you're currently running a virtual thread, a
different piece of code is run.This piece of code is quite
interesting, because what it does is it calls yield function. It
suspends itself. It voluntarily says that it no longer wishes to run
because we asked that thread to sleep. That's interesting. Why is
that? Before we actually yield, we schedule unparking. Unparking or
waking up means basically, that we would like ourselves to be woken
up after a certain period of time. Before we put ourselves to sleep,
we are scheduling an alarm clock. This scheduling will wake us up. It
will continue running our thread, it will continue running our
continuation after a certain time passes by. In between calling the
sleep function and actually being woken up, our virtual thread no
longer consumes the CPU. At this point, the carrier thread is free to
run another virtual thread. Technically, you can have millions of
virtual threads that are sleeping without really paying that much in
terms of the memory consumption.This is our Hello World. This is
overblown, because everyone says millions of threads and I keep
saying that as well. That's the piece of code that you can run even
right now. You can download Project Loom with Java 18 or Java 19, if
you're cutting edge at the moment, and just see how it works. There
is a count variable. If you put 1 million, it will actually start 1
million threads, and your laptop will not melt and your system will
not hang, it will simply just create these millions of threads. As
you already know, there is no magic here. Because what actually
happens is that we created 1 million virtual threads, which are not
kernel threads, so we are not spamming our operating system with
millions of kernel threads. The only thing these kernel threads are
doing is actually just scheduling, or going to sleep, but before they
do it, they schedule themselves to be woken up after a certain time.
Technically, this particular example could easily be implemented with
just a scheduled ExecutorService, having a bunch of threads and 1
million tasks submitted to that executor. There is not much
difference. As you can see, there is no magic here. It's just that
the API finally allows us to build in a much different, much easier
way.Here's another code snippet of the carrier threads. The API may
change, but the thing I wanted to show you is that every time you
create a virtual thread, you're actually allowed to define a
carrierExecutor. In our case, I just create an executor with just one
thread. Even with just a single thread, single carriers, or single
kernel thread, you can run millions of threads as long as they don't
consume the CPU all the time. Because, after all, Project Loom will
not magically scale your CPU so that it can perform more work. It's
just a different API, it's just a different way of defining tasks
that for most of the time are not doing much. They are sleeping
blocked on a synchronization mechanism, or waiting on I/O. There's no
magic here. It's just a different way of performing or developing
software.There's also a different algorithm or a different initiative
coming as part of Project Loom called structured concurrency. It's
actually fairly simple. There's not much to say here. Essentially, it
allows us to create an ExecutorService that waits for all tasks that
were submitted to it in a try with resources block. This is just a
minor addition to the API, and it may change.The reason I'm so
excited about Project Loom is that finally, we do not have to think
about threads. When you're building a server, when you're building a
web application, when you're building an IoT device, whatever, you no
longer have to think about pooling threads, about queues in front of
a thread pool. At this point, all you have to do is just creating
threads every single time you want to. It works as long as these
threads are not doing too much work. Because otherwise, you just need
more hardware. There's nothing special here. If you have a ton of
threads that are not doing much, they're just waiting for data to
arrive, or they are just locked on a synchronization mechanism
waiting for a semaphore or CountDownLatch, whatever, then Project
Loom works really well. We no longer have to think about this low
level abstraction of a thread, we can now simply create a thread
every time for every time we have a business use case for that. There
is no leaky abstraction of expensive threads because they are no
longer expensive. As you can probably tell, it's fairly easy to
implement an actor system like Akka using virtual threads, because
essentially what you do is you create a new actor, which is backed by
a virtual thread. There is no extra level of complexity that arises
from the fact that a large number of actors has to share a small
number of threads.A few use cases that are actually insane these
days, but they will be maybe useful to some people when Project Loom
arrives. For example, let's say you want to run something after eight
hours, so you need a very simple scheduling mechanism. Doing it this
way without Project Loom is actually just crazy. Creating a thread
and then sleeping for eight hours, because for eight hours, you are
consuming system resources, essentially for nothing. With Project
Loom, this may be even a reasonable approach, because a virtual
thread that sleeps consumes very little resources. You don't pay this
huge price of scheduling operating system resources and consuming
operating system's memory.Another use case, let's say you're building
a massive multiplayer game, or a very highly concurrent server, or a
chat application like WhatsApp that needs to handle millions of
connections, there is actually nothing wrong with creating a new
thread per each player, per each connection, per each message even.
Of course, there are some limits here, because we still have a
limited amount of memory and CPU. Anyways, confront that with the
typical way of building software where you had a limited worker pool
in a servlet container like Tomcat, and you had to do all these fancy
algorithms that are sharing this thread pool, and making sure it's
not exhausted, making sure you're monitoring the queue. Now it's
easy, every time a new HTTP connection comes in, you just create a
new virtual thread, as if nothing happens. This is how we were taught
Java 20 years ago, then we realized it's a poor practice. These days,
it may actually be a valuable approach again.Another example. Let's
say we want to download 10,000 images. With Project Loom, we simply
start 10,000 threads, each thread per each image. That's just it.
Using the structured concurrency, it's actually fairly simple. Once
we reach the last line, it will wait for all images to download. This
is really simple. Once again, confront that with your typical code,
where you would have to create a thread pool, make sure it's
fine-tuned. There's a caveat here. Notice that with a traditional
thread pool, all you had to do was essentially just make sure that
your thread pool is not too big, like 100 threads, 200 threads, 500,
whatever. This was the natural limit of concurrency. You cannot
download more than 100 images at once, if you have just 100 threads
in your standard thread pool.With this approach with Project Loom,
notice that I'm actually starting as many concurrent connections, as
many concurrent virtual threads, as many images there are. I
personally don't pay that much price for starting these threads
because all they do is just like being blocked on I/O. In Project
Loom, every blocking operation, so I/O like network typically, so
waiting on a synchronization mechanism like semaphores, or sleeping,
all these blocking operations are actually yielding, which means that
they are voluntarily giving up a carrier thread. It's absolutely fine
to start 10,000 concurrent connections, because you won't pay the
price of 10,000 carrier or kernel threads, because these virtual
threads will be hibernated anyway. Only when the data arrives, the
JVM will wake up your virtual thread. In the meantime, you don't pay
the price. This is pretty cool. However, you just have to be aware of
the fact that the kernel threads of your thread pools were actually
just natural like limit to concurrency. Just blindly switching from
platform threads, the old ones, to virtual threads will change the
semantics of your application.To make matters even worse, if you
would like to use Project Loom directly, you will have to relearn all
these low level structures like CountDownLatch or semaphore to
actually do some synchronization or to actually do some throttling.
This is not the path I would like to take. I would definitely like to
see some high level frameworks that are actually taking advantage of
Project Loom.Do we have such frameworks and what problems and
limitations can we reach here? Before we move on to some high level
constructs, so first of all, if your threads, either platform or
virtual ones have a very deep stack. This is your typical Spring Boot
application, or any other framework like Quarkus, or whatever, if you
put a lot of different technologies like adding security, aspect
oriented programming, your stack trace will be very deep. With
platform threads, the size of the stack trace is actually fixed. It's
like half a megabyte, 1 megabyte, and so on. With virtual threads,
the stack trace can actually shrink and grow, and that's why virtual
threads are so inexpensive, especially in Hello World examples, where
all what they do is just like sleeping most of the time, or
incrementing a counter, or whatever. In real life, what you will get
normally is actually, for example, a very deep stack with a lot of
data. If you suspend such a virtual thread, you do have to keep that
memory that holds all these stack lines somewhere. The cost of the
virtual thread will actually approach the cost of the platform
thread. Because after all, you do have to store the stack trace
somewhere. Most of the time it's going to be less expensive, you will
use less memory, but it doesn't mean that you can create millions of
very complex threads that are doing a lot of work. It's just an
advertising gimmick. It doesn't hold true for normal workloads. Keep
that in mind. There's no magic here.Another thing that's not yet
handled is preemption, when you have a very CPU intensive task. Let's
say you have 4 CPU cores, and you create 4 platform threads, or 4
kernel threads that are doing very CPU intensive work, like crunching
numbers, cryptography, hashing, compression, encoding, whatever. If
you have 4 physical threads, or platform threads doing that, you're
essentially just maxing your CPU. If instead you create 4 virtual
threads, you will basically do the same amount of work. It doesn't
mean that if you replace 4 virtual threads with 400 virtual threads,
you will actually make your application faster, because after all,
you do use the CPU. There's not much hardware to do the actual work,
but it gets worse. Because if you have a virtual thread that just
keeps using the CPU, it will never voluntarily suspend itself,
because it never reaches a blocking operation like sleeping, locking,
waiting for I/O, and so on. In that case, it's actually possible that
you will only have a handful of virtual threads that never allow any
other virtual threads to run, because they just keep using the CPU.
That's the problem that's already handled by platform threads or
kernel threads because they do support preemption, so stopping a
thread in some arbitrary moment in time. It's not yet supported with
Project Loom. It may be one day, but it's not yet the case.There's
also a whole list of unsupported APIs. One of the main goals of
Project Loom is to actually rewrite all the standard APIs. For
example, socket API, or file API, or lock APIs, so lock support,
semaphores, CountDownLatches. All of these APIs are sleep, which we
already saw. All of these APIs need to be rewritten so that they play
well with Project Loom. However, there's a whole bunch of APIs, most
importantly, the file API. I just learned that there's some work
happening. There's a list of APIs that do not play well with Project
Loom, so it's easy to shoot yourself in the foot.One more thing. With
Project Loom, you no longer consume the so-called stack space. The
virtual threads that are not running at the moment, which is
technically called pinned, so they are not pinned to a carrier
thread, but they are suspended. These virtual threads actually reside
on heap, which means they are subject to garbage collection. In that
case, it's actually fairly easy to get into a situation where your
garbage collector will have to do a lot of work, because you have a
ton of virtual threads. You don't pay the price of platform threads
running and consuming memory, but you do get the extra price when it
comes to garbage collection. The garbage collection may take
significantly more time. This was actually an experiment done by the
team behind Jetty. After switching to Project Loom as an experiment,
they realized that the garbage collection was doing way more work.
The stack traces were actually so deep under normal load, that it
didn't really bring that much value. That's an important
takeaway.Another question is whether we still need reactive
programming. If you think about it, we do have a very old class like
RestTemplate, which is like this old school blocking HTTP client.
With Project Loom, technically, you can start using RestTemplate
again, and you can use it to, very efficiently, run multiple
concurrent connections. Because RestTemplate underneath uses HTTP
client from Apache, which uses sockets, and sockets are rewritten so
that every time you block, or wait for reading or writing data, you
are actually suspending your virtual thread. It seems like
RestTemplate or any other blocking API is exciting again. At least
that's what we might think, you no longer need reactive programming
and all these like WebFluxes, RxJavas, Reactors, and so on.Project
Loom addresses just a tiny fraction of the problem, it addresses
asynchronous programming. It makes asynchronous programming much
easier. However, it doesn't address quite a few other features that
are supported by reactive programming, namely backpressure, change
propagation, composability. These are all features or frameworks like
Reactor, or Akka, or Akka streams, whatever, which are not addressed
by Loom because Loom is actually quite low level. After all, it's
just a different way of creating threads.Should you just blindly
install the new version of Java whenever it comes out and just switch
to virtual threads? I think the answer is no, for quite a few
reasons. First of all, the semantics of your application change. You
no longer have this natural way of throttling because you have a
limited number of threads. Also, the profile of your garbage
collection will be much different. We have to take that into
account.When will Project Loom be available? It was supposed to be
available in Java 17, we just got Java 18 and it's still not there.
Hopefully, it will be ready when it's ready. Hopefully, we will live
into that moment. I'm experimenting with Project Loom for quite some
time already. It works. It sometimes crashes. It's not vaporware, it
actually exists.I leave you with a few materials which I collected,
more presentations and more articles that you might find interesting.
Quite a few blog posts that explain the API a little bit more
thoroughly. A few more critical or skeptic points of view, mainly
around the fact that Project Loom won't really change that much. It's
especially for the people who believe that we will no longer need
reactive programming because we will all just write our code using
plain Project Loom. Also, my personal opinion, that's not going to be
the case, we will still need some higher level abstraction.Cummins:
How do you debug it? Does it make it harder to debug? Does it make it
easier to debug? What tooling support is there? Is there more tooling
support coming?Nurkiewicz: The answer is actually twofold. On one
hand, it's easier, because you no longer have to hop between threads
so much, in reactive programming or asynchronous programming in
general. What you typically do is that you have a limited number of
threads, but you jump between threads very often, which means that
stack traces are cut in between, so you don't see the full picture.
It gets a little bit convoluted, and frameworks like Reactor try to
somehow reassemble the stack trace, taking into account that you are
jumping between thread pools, or some asynchronous Netty threads. In
that case, Loom makes it easier, because you can survive, you can
make a whole request just in a single thread, because logically,
you're still on the same thread, this thread is being paused. It's
being unpinned, and pinned back to a carrier thread. When the
exception arises, this exception will show the whole stack trace
because you're not jumping between threads. What you typically do is
that when you want to do something asynchronous, you put it into a
thread pool. Once you're in a thread pool, you lose the original
stack trace, you lose the original thread.In case of Project Loom,
you don't offload your work into a separate thread pool, because
whenever you're blocked your virtual thread has very little cost. In
some sense, it's going to be easier. However, you will still be
probably using multiple threads to handle a single request. That
problem doesn't really go away. In some cases, it will be easier but
it's not like an entirely better experience. On the other hand, you
now have 10 times or 100 times more threads, which are all doing
something. These aren't really like Java threads. You won't, for
example, see them on a thread dump. This may change but that's the
case right now. You have to take that into account. When you're doing
a thread dump, which is probably one of the most valuable things you
can get when troubleshooting your application, you won't see virtual
threads which are not running at the moment.If you are doing the
actual debugging, so you want to step over your code, you want to
see, what are the variables? What is being called? What is sleeping
or whatever? You can still do that. Because when your virtual thread
runs, it's a normal Java thread. It's a normal platform thread
because it uses carrier thread underneath. You don't really need any
special tools. However, you just have to remember on the back of your
head, that there is something special happening there, that there is
a whole variety of threads that you don't see, because they are
suspended. As far as JVM is concerned, they do not exist, because
they are suspended. They're just objects on heap, which is
surprising.Cummins: It's hard to know which is worse, you have a
million threads, and they don't turn up in your heap thread dump, or
you have a million threads and they do turn up in your heap
dump.Nurkiewicz: Actually, reactive is probably the worst here
because you have million ongoing requests, for example, HTTP
requests, and you don't see them anywhere. Because with reactive,
with truly asynchronous APIs, HTTP database, whatever, what happens
is that you have a thread that makes a request, and then absolutely
forgets about that request until it gets a response. A single thread
handles hundreds of thousands of requests concurrently or truly
concurrently. In that case, if you make a thread dump, it's actually
the worst of both worlds, because what you see is just a very few
reactive threads like Netty, for example, which is typically used.
These native threads are not actually doing any business logic,
because most of the time, they are just waiting for data to be sent
or received. Troubleshooting a reactive application using a thread
dump is actually very counterproductive. In that case, virtual
threads are actually helping a little bit, because at least you will
see the running threads.Cummins: It's probably like a lot of things
where when the implementation moves closer to our mental model,
because nobody has a mental model of thread pools, they have a mental
model of threads, and so then when you get those two closer together,
it means that debugging is easier.Nurkiewicz: I really love the quote
by Cay Horstmann, that you're no longer thinking about this low level
abstraction of a thread pool, which is convoluted. You have a bunch
of threads that are reused. There's a queue, you're submitting a
task. It stands in a queue, it waits in that queue. You no longer
have to think about it. You have a bunch of tasks that you need to
run concurrently. You just run them, you just create a thread and get
over it. That was the promise of actor systems like Akka, that when
you have 100,000 connections, you create 100,000 actors, but actors
reuse threads underneath, because that's how JVM works at the moment.
With virtual threads, you just create a new virtual thread per
connection, per player, per message, whatever. It's closer,
surprisingly, to an Erlang model, where you were just starting new
processes. Of course, it's really far away from Erlang still, but
it's a little bit closer to that.Cummins: Do you think we're going to
see a new world of problem reproduction ickiness, where some of us
are on Java 19 and taking advantage of threads, and some of us are
not. At the top level, it looks similar, but then once you go
underneath the behavior is really fundamentally different. Then we
get these non-reproducible things where it's the timing dependency
plus a different implementation means that we just spend all our time
chasing weird threading variations.Nurkiewicz: I can give you even a
simpler example of when it can blow up. We used to rely on the fact
that thread pool is the natural way of throttling tasks. When you
have a thread pool of 20 threads, it means you will not run more than
20 tasks at the same time. If you just blindly replace
ExecutorService with this virtual thread, ExecutorService, the one
that doesn't really pull any threads, it just starts them like crazy,
you no longer have this throttling mechanism. If you naively refactor
from Java 18 to Java 19, because Project Loom was already merged to
project 19, to the master branch. If you just switch to Project Loom,
you will be surprised, because suddenly, the level of concurrency
that you achieve on your machine is way greater than you expected.You
might think that it's actually fantastic because you're handling more
load. It also may mean that you are overloading your database, or you
are overloading another service, and you haven't changed much. You
just changed a single line that changes the way threads are created
rather than platform, then you move to the virtual threads. Suddenly,
you have to rely on these low level CountDownLatches, semaphores, and
so on. I barely remember how they work, and I will either have to
relearn them or use some higher level mechanisms. This is probably
where reactive programming or some higher level abstractions still
come into play. From that perspective, I don't believe Project Loom
will revolutionize the way we develop software, or at least I hope it
won't. It will significantly change the way libraries or frameworks
can be written so that we can take advantage of them.

# Web Tech, sof Arch:  Apache ShenYu: Java Responsive API Gateway Announced as Apache Top-Level Project
  https://www.infoq.com/news/2022/09/shenyu-gateway/ 

# JEP 429: Extent-Local Variables to Promote Immutability in Java
  https://www.infoq.com/news/2022/09/extent-local-variables-java/

# Announcing Conclave SDK 1.3 and Open Source
  https://www.conclave.net/blog/announcing-conclave-sdk-1-3-and-open-source
We are pleased to announce the release of version 1.3 of the Conclave
SDK. This is an important milestone for confidential computing as it
enables confidential workloads in the cloud with the KDS. You can
find out more about the KDS, what it is and how you can benefit from
it, in the release notes, along with all the other fixes and
improvements in 1.3.
However, that’s not all! 1.3 is also the first release of the core
SDK to be open source. We are pleased to announce the SDK code is
publicly available under Apache 2.0 and is available for you to
download or view at https://github.com/R3Conclave/conclave-core-sdk.
Before we explain why we’ve open sourced the Conclave SDK, perhaps
this is the first time you’re hearing of Conclave or confidential
computing.What is Conclave?
Conclave is R3’s privacy preserving platform enabling you to write
secure confidential applications with ease. With the core SDK you can
create Intel® SGX enclaves using high-level languages such as Java,
Kotlin, and JavaScript. It has a simple but powerful high-level API
which hides the low-level complexities of using SGX so that you can
spend more time concentrating on your enclave’s business logic. The
core SDK also powers Conclave Cloud, our privacy-preserving SaaS
platform for deploying confidential even-driven workloads in the
cloud.
Confidential computing protects data at rest and in transit as well
as during processing. Trusted Execution Environments (TEEs) such as
SGX use hardware to provide a secure region of the CPU, an enclave,
in which code and data are physically isolated and cannot be tampered
with, not even by the system or cloud administrator. It enables use
cases which were previously not possible, such as sharing of
confidential data for analysis or fraud detection.Why have we open
sourced Conclave?
Confidential computing is all about trust. It is about removing the
need to trust your cloud service provider, or your application
service provider, or any software stack in between. This includes
R3’s Conclave. We are open sourcing so that you can verify and
audit Conclave yourself and remove R3 from your trust model.
We also feel it’s vitally important that we build and grow a
community around Conclave, and that is best achieved when the product
is open source. By increasing transparency and allowing
accessibility, we want to foster collaboration within the ecosystem
to boost innovation and accelerate the adoption of confidential
computing technologies.  
Involving the community in the development of Conclave makes sure we
are building the right toolkit for our users. To that end, we would
love to hear your thoughts and suggestions and we can’t wait to see
your contributions to make Conclave even better. Hit us up on our
Discord or mailing list and share your ideas with us, and if you have
contributions you’d like to make then have a read of our
contribution guidelines.Next steps
If this is the first time you’re hearing of Conclave, then no
worries! Download our hello world sample and see how easy it is to
build enclaves in languages like Java and Kotlin. If you have already
used Conclave before, then you’ll be pleased to know that using
Conclave is now even easier. Have a read of our release notes and
learn about the improvements and new features we’ve added in 1.3.
Java and Kotlin are just the beginning. We want to expand the
Conclave API to other programming languages as well. If you like what
you see with Conclave but find it lacking due to it not supporting
your language of choice, then do let us know. Or if you find any bugs
or have suggestions for other improvements, then ping us on Discord
or GitHub.
Happy coding!

# spring: https://www.reddit.com/r/java/comments/zlnhbz/just_a_command_line_toolkit_for_developing_spring/

# Ver "Programmer's Guide to JDK Flight Recorder" en YouTubehttps://youtu.be/K1ApBZGiT-Y

# Resilience4j 2.0.0 Delivers Support for JDK 17
  https://www.infoq.com/news/2022/12/resilience4j-2-0-0/

# Consolidated JDK 19 Release Notes
  https://www.oracle.com/java/technologies/javase/19all-relnotes.html

# quartz alternatives, batch, schedule task runners "cron".
  https://www.reddit.com/r/java/comments/zariyv/is_quartz_abandoned/See alternatives

# JVM Options Explorer - OpenJDK11 HotSpot 101https://chriswhocodes.com/ 

# https://github.com/ben-manes/caffeine  [[{scalability.cache]]
  high performance, near optimal caching library.
  LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
      .maximumSize(10_000)
      .expireAfterWrite(Duration.ofMinutes(5))
      .refreshAfterWrite(Duration.ofMinutes(1))
      .build(key -> createExpensiveGraph(key));

  - Features:
    - automatic loading of entries into cache: optionally asynchronously
    - size-based eviction: when a maximum is exceeded based on frequency and recency
    - time-based expiration of entries, measured since last access or last write
    - asynchronously refresh when the first stale request for an entry occurs
    - keys automatically wrapped in weak references
    - values automatically wrapped in weak or soft references
    - notification of evicted (or otherwise removed) entries
    - writes propagated to an external resource
    - accumulation of cache access statistics

  - Community provided integration:
    - Play Framework: High velocity web framework
    - Micronaut: A modern, full-stack framework
    - Spring Cache: As of Spring 4.3 & Boot 1.4
    - Quarkus: Supersonic Subatomic Java
    - Scaffeine: Scala wrapper for Caffeine
    - ScalaCache: Simple caching in Scala
    - Camel: Routing and mediation engine
    - JHipster: Generate, develop, deploy
    - Aedile: Kotlin wrapper for Caffeine
  [[}]]


# Thorben Janssen  (newsletter)
  """
  Domain Driven Design (DDD) adoption has massively grown.
   One of the reasons is that the concept of "bounded-contexts" fits incredibly
  well with microservices-design .... You will soon recognize some of the
  DDD's design principles ovelaping with JPA:
    Both use entities, identifiers, and value objects.
  - Do they really mean the same in both contexts?
  - What about DDD's concept of an aggregate? (1+ entities):
     This might sound like you shouldn't use JPA if you want to follow DDD
     design principles. But that's not the case. They actually fit very
     well together if you follow a few simple rules when implementing your
     JPA entity mappings.
  """

# Spring Shell Reference Documentation
  https://docs.spring.io/spring-shell/docs/3.0.0/docs/index.html

# Eclipse Migration Toolkit for Java (EMT4J) [[{]]]
  Adoptium has introduced the Eclipse Migration Toolkit for Java
  (EMT4J), an open source Eclipse project capable of analyzing and
  upgrading applications from Java 8 to Java 11 and from Java 11 to
  Java 17. EMT4J will support upgrading to future LTS versions.

  https://www.infoq.com/news/2022/12/eclipse-migration-toolkit-java/
[[}]]

# Profiler in 240 Lines of Pure Java [[{JAVA_LANG.PROFILING]]
  https://foojay.io/today/writing-a-profiler-in-240-lines-of-pure-java/
  JVM safepoint: point in time where the JVM has a known defined
state, and all threads have stopped. JVM itself needs safepoints to
do major garbage collections, Class definitions, method
deoptimizations, and more. Threads are regularly checking whether
they should get into a safepoint, for example, at method entry, exit,
or loop backjumps. A profiler that only profiles at a safepoint have
an inherent bias because it only includes frames from the locations
inside methods where Threads check for a safepoint. The only
advantage is that the stack-walking at safepoints is slightly less
error-prone, as there are fewer mutations of heap and stack.
Further read: Java Safepoint and Async Profiling by Seetha Wenner,
the more technical one by JP Bempel, or the classic article
Safepoints: Meaning, Side Effects and Overheads by Nitsan Wakart. To
conclude: Safepoint-biased profilers don't give you a holistic view
of your application, but can still be helpful to analyze major
performance issues where you look at the bigger picture.This article
aims to develop a tiny Java profiler in pure Java code that everyone
can understand. Profilers are not rocket science, and ignoring
safepoint-bias, we can write a usable profiler that outputs a flame
graph in just 240 lines of code.You can find the whole project on
GitHub.
[[}]]
------------------------------------------------

# JEP 444: Virtual Threads Arrive in JDK 21 2023-05 [[{scalability.101]]
  Ushering a New Era of Concurrency
  https://www.infoq.com/news/2023/04/virtual-threads-arrives-jdk21/ [[scalability,concurrency]]

Virtual Threads, promoted from Candidate to Proposed to Target status for JDK 21.

finalize based on feedback from the previous two rounds of preview:
JEP 436, Virtual Threads (Second Preview), delivered in JDK 20;
JEP 425, Virtual Threads (Preview), delivered in JDK 19.

Java now has two types of threads:
- traditional threads, platform or OS "wrapper" threads
- virtual threads:  "many" virtual threads per OS thread.
  OFFERING COMPATIBILITY WITH EXISTING JAVA CODE
 path to benefit from enhanced performance and resource
utilization. Consider the following example:try (var executor =
Executors.newVirtualThreadPerTaskExecutor()) { IntStream.range(0,
10_000).forEach(i -> { executor.submit(() -> {
Thread.sleep(Duration.ofSeconds(1)); return i; }); });}The JDK can
now run up to 10,000 concurrent virtual threads on a small number of
operating system (OS) threads, as little as one, to execute the
simple code above that involves sleeping for one second.Virtual
threads are designed to work with thread-local variables and
inheritable thread-local variables, just like platform threads.
However, due to the large number of virtual threads that can be
created, developers should use thread-local variables with caution.
To assist with the migration to virtual threads, the JDK provides a
system property, jdk.traceVirtualThreadLocals, that triggers a stack
trace when a virtual thread sets the value of any thread-local
variable.The java.util.concurrent package now includes support for
virtual threads. The LockSupport API has been updated to gracefully
park and unpark virtual threads, enabling APIs that use LockSupport,
such as Locks, Semaphores, and blocking queues, to function
seamlessly with virtual threads. The
Executors.newThreadPerTaskExecutor(ThreadFactory) and
Executors.newVirtualThreadPerTaskExecutor() methods provide an
ExecutorService that creates a new thread for each task, facilitating
the migration and interoperability with existing code that uses
thread pools and ExecutorService.Networking APIs in the java.net and
java.nio.channels packages now support virtual threads, enhancing
efficiency in concurrent applications. Blocking operations on a
virtual thread free up the underlying platform thread, while I/O
methods in the Socket, ServerSocket and DatagramSocket classes have
been made interruptible. This update promotes consistent behavior and
improved performance for Java developers working with concurrent
applications.The java.io package, which provides APIs for streams of
bytes and characters, has been updated to avoid pinning when used in
virtual threads. Pinning in virtual threads refers to a lightweight
thread being "stuck" to a specific platform thread, limiting
concurrency and flexibility due to blocking operations.
BufferedInputStream, BufferedOutputStream, BufferedReader,
BufferedWriter, PrintStream, and PrintWriter now use an explicit lock
instead of a monitor when used directly. The stream decoders and
encoders used by InputStreamReader and OutputStreamWriter now use the
same lock as their enclosing InputStreamReader or
OutputStreamWriter.Java Native Interface (JNI) has introduced a new
function, IsVirtualThread, to test if an object is a virtual thread.
The JNI specification otherwise remains unchanged.The debugging
architecture, consisting of the JVM Tool Interface (JVM TI), the Java
Debug Wire Protocol (JDWP), and the Java Debug Interface (JDI), has
been updated to support virtual threads. All three interfaces now
support virtual threads, with new capabilities and methods added to
handle thread start and end events and bulk suspension and resumption
of virtual threads.JDK Flight Recorder (JFR) now supports virtual
threads with new events such as jdk.VirtualThreadStart,
jdk.VirtualThreadEnd, jdk.VirtualThreadPinned, and
jdk.VirtualThreadSubmitFailed. These events provide insight into the
behavior of virtual threads in the application.Java Management
Extensions (JMX) will continue to support only platform threads
through the ThreadMXBean interface. A new method in the
HotSpotDiagnosticsMXBean interface generates the new-style thread
dump to support virtual threads.While virtual threads bring
significant performance improvements, developers should be aware of
compatibility risks due to changes in existing APIs and their
implementations. Some of these risks include revisions to the
internal locking protocol in the java.io package and source and
binary incompatible changes that may impact code that extends the
Thread class.Virtual threads mark a significant milestone in Java's
journey to support highly concurrent and scalable applications. With
a more efficient and lightweight threading model, developers can now
handle millions of tasks with ease and better utilize system
resources. Developers can leverage more details on JEP 425, which can
be found in this InfoQ news story and this JEP Café screen cast by
José Paumard, Java developer advocate with the Java Platform Group
at Oracle.

[[}]]

# Billions of Messages Per Minute Over TCP/IP [[{io.serialization,io.scalability,scalability.network,JVM,]]
  https://www.infoq.com/articles/billions-messages-minute/ 
  Chronicle Wire library: provides high-performance transformations
  of state in Java objects between their internal JVM representation
  and a format that allows that state to be persisted or communicated
  to another Java process.  
  It grew from Chronicle Queue project, which offers single digit
  microsecond latencies for messaging between JVMs on the same machine,
  or stable latencies of tens of microseconds between machines,
  as throughput scales to millions of messages per second.
[[}]]

# Java's Collections Framework Gets a Makeover  [[{data_structures]]
  https://www.infoq.com/news/2023/03/collections-framework-makeover/
  New Sequenced Collection Types
[[}]]

# VertX Mutiny Zero by Julien Ponge
  Quarkus Insights 120
  https://www.linkedin.com/feed/update/activity:7038552356413693952

  latest developments around Mutiny, Mutiny Zero and switching from legacy Reactive Streams to JDK Flow.
  https://www.youtube.com/watch?v=RRs4DJJUSx8

#  gradle 8.0 GA release [[{DEVOPS.GRADLE]]
- enhancements to Kotlin DSL (alternative to Groovy DSL).
- upgrades to Kotlin 1.8 and JDK 11.
- improvements in buildSrc builds;
- configuration cache: incubating new feature
- improvements in Java toolchains.
- Shortly after the GA release, a patch release, Gradle 8.0.1,
  provides fixes for these issues:
[[}]]

# WireMock Spring Boot Simplifies WireMock Configuration [[{SPRING.testing]]
  https://www.infoq.com/news/2023/03/wiremock-spring-boot/
[[}]]
[[java,01_PM.TODO}]]


* Recheck tool Guides: java launcher, keytool

* java.lang.StrictMath
